/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./View.ts":
/*!*****************!*\
  !*** ./View.ts ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_map_controls_1 = __webpack_require__(/*! @here/harp-map-controls */ "./node_modules/@here/harp-map-controls/index.js");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "./node_modules/@here/harp-mapview/index.js");
const defaultTheme = "resources/berlin_tilezen_base.json";
class View {
    constructor(args) {
        this.canvas = args.canvas;
        this.theme = args.theme === undefined ? defaultTheme : args.theme;
        this.mapView = this.initialize();
    }
    initialize() {
        const mapView = new harp_mapview_1.MapView({
            canvas: this.canvas,
            theme: this.theme,
            decoderUrl: "decoder.bundle.js"
        });
        harp_mapview_1.CopyrightElementHandler.install("copyrightNotice")
            .attach(mapView)
            .setDefaults([
            {
                id: "here.com",
                label: "HERE",
                link: "https://legal.here.com/terms",
                year: 2019
            }
        ]);
        harp_map_controls_1.MapControls.create(mapView);
        return mapView;
    }
}
exports.View = View;


/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const View_1 = __webpack_require__(/*! ./View */ "./View.ts");
const THREE = __webpack_require__(/*! three */ "three");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "./node_modules/@here/harp-mapview/index.js");
const harp_omv_datasource_1 = __webpack_require__(/*! @here/harp-omv-datasource */ "./node_modules/@here/harp-omv-datasource/index.js");
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
// Physics variables
var collisionConfiguration;
var dispatcher;
var broadphase;
var solver;
var physicsWorld;
var transformAux1;
const clock = new THREE.Clock();
const dynamicObjects = [];
const canvas = document.getElementById("map");
const app = new View_1.View({
    canvas
});
const mapView = app.mapView;
// center the camera to Singapore
const singapore = new harp_geoutils_1.GeoCoordinates(1.3029095, 103.8494058, 0);
// choose a center for the physics world
const physicsWorldCenter = mapView.projection.projectPoint(singapore, new THREE.Vector3());
class PhysicsDataSource extends harp_omv_datasource_1.OmvDataSource {
    constructor(params) {
        super(params);
    }
    getTile(tileKey) {
        const omvTile = super.getTile(tileKey);
        omvTile.tileLoader.waitSettled().then((value) => {
            if (value !== harp_mapview_1.TileLoaderState.Ready) {
                return;
            }
            for (const geometry of omvTile.tileLoader.decodedTile.geometries) {
                if (geometry.type === harp_datasource_protocol_1.GeometryType.ExtrudedPolygon) {
                    geometry.vertexAttributes.forEach((vertexAttribute) => {
                        try {
                            if (vertexAttribute.name !== "position") {
                                return;
                            }
                            if (vertexAttribute.type !== "float") {
                                console.log("position vertex attribute needs to be float.");
                                return;
                            }
                            if (geometry.index === undefined) {
                                console.log("No index buffer defined.");
                                return;
                            }
                            if (geometry.index.type !== "uint32") {
                                console.log("index buffer needs to be uint32.");
                                return;
                            }
                            const positions = new Float32Array(vertexAttribute.buffer);
                            const indices = new Uint32Array(geometry.index.buffer);
                            const mesh = new Ammo.btTriangleMesh(true /*use32bitIndices*/);
                            for (let i = 0; i < indices.length; i += 3) {
                                const v0 = new Ammo.btVector3(positions[indices[i] * 3], positions[indices[i] * 3 + 1], positions[indices[i] * 3 + 2]);
                                const v1 = new Ammo.btVector3(positions[indices[i + 1] * 3], positions[indices[i + 1] * 3 + 1], positions[indices[i + 1] * 3 + 2]);
                                const v2 = new Ammo.btVector3(positions[indices[i + 2] * 3], positions[indices[i + 2] * 3 + 1], positions[indices[i + 2] * 3 + 2]);
                                mesh.addTriangle(v0, v1, v2);
                            }
                            const shape = new Ammo.btBvhTriangleMeshShape(mesh, true, true);
                            // Tile origin relative to the center of our physics simulation.
                            const tileOrigin = omvTile.center.clone().sub(physicsWorldCenter);
                            console.log(omvTile.center, tileOrigin);
                            var mass = 0; // make it unmoveable
                            var localInertia = new Ammo.btVector3(0, 0, 0);
                            shape.calculateLocalInertia(mass, localInertia);
                            var transform = new Ammo.btTransform();
                            transform.setIdentity();
                            transform.setOrigin(new Ammo.btVector3(tileOrigin.x, tileOrigin.y, tileOrigin.z));
                            var motionState = new Ammo.btDefaultMotionState(transform);
                            var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
                            var body = new Ammo.btRigidBody(rbInfo);
                            physicsWorld.addRigidBody(body);
                        }
                        catch (error) {
                            console.log(error);
                        }
                    });
                }
            }
        });
        return omvTile;
    }
}
const omvDataSource = new PhysicsDataSource({
    baseUrl: "https://xyz.api.here.com/tiles/herebase.02",
    apiFormat: harp_omv_datasource_1.APIFormat.XYZOMV,
    styleSetName: "tilezen",
    maxZoomLevel: 17,
    authenticationCode: "AB5W33i5bYqI2dY_cDYIcG0"
});
mapView.addDataSource(omvDataSource);
// make map full-screen
mapView.resize(window.innerWidth, window.innerHeight);
// react on resize events from the browser.
window.addEventListener("resize", () => {
    mapView.resize(window.innerWidth, window.innerHeight);
});
mapView.lookAt(singapore, 500);
mapView.addEventListener(harp_mapview_1.MapViewEventNames.Render, (event) => {
    updatePhysics(clock.getDelta());
});
// constantly animate to update the physics.
mapView.beginAnimation();
Ammo().then(function (AmmoLib) {
    initPhysics();
});
function updatePhysics(deltaTime) {
    if (!physicsWorld) {
        // physics not initialized yet
        return;
    }
    physicsWorld.stepSimulation(deltaTime, 10);
    // Update objects
    for (var i = 0, il = dynamicObjects.length; i < il; i++) {
        var objThree = dynamicObjects[i];
        var objPhys = objThree.userData.physicsBody;
        var ms = objPhys.getMotionState();
        if (ms) {
            ms.getWorldTransform(transformAux1);
            var p = transformAux1.getOrigin();
            var q = transformAux1.getRotation();
            objThree.position.set(p.x(), p.y(), p.z());
            objThree.position.add(physicsWorldCenter);
            objThree.position.sub(mapView.worldCenter);
            objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());
        }
    }
}
function initPhysics() {
    collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
    dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
    broadphase = new Ammo.btDbvtBroadphase();
    solver = new Ammo.btSequentialImpulseConstraintSolver();
    physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
    physicsWorld.setGravity(new Ammo.btVector3(0, 0, -9.82));
    transformAux1 = new Ammo.btTransform();
    generateGroundPlane();
    function addObjects() {
        setTimeout(addObjects, 500);
        generateObject();
    }
    addObjects();
}
function createObjectMaterial() {
    var c = Math.floor(Math.random() * (1 << 24));
    return new THREE.MeshPhongMaterial({ color: c });
}
function generateGroundPlane() {
    const shape = new Ammo.btStaticPlaneShape(new Ammo.btVector3(0, 0, 1), 0);
    var mass = 0; // make it unmoveable
    var localInertia = new Ammo.btVector3(0, 0, 0);
    shape.calculateLocalInertia(mass, localInertia);
    var transform = new Ammo.btTransform();
    transform.setIdentity();
    transform.setOrigin(new Ammo.btVector3(0, 0, 0));
    var motionState = new Ammo.btDefaultMotionState(transform);
    var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
    var body = new Ammo.btRigidBody(rbInfo);
    physicsWorld.addRigidBody(body);
}
function generateObject() {
    if (!mapView) {
        return;
    }
    var numTypes = 4;
    var objectType = Math.ceil(Math.random() * numTypes);
    var threeObject = null;
    var shape = null;
    var objectSize = 10;
    var margin = 0.05;
    switch (objectType) {
        case 1:
            // Sphere
            var radius = 1 + Math.random() * objectSize;
            threeObject = new THREE.Mesh(new THREE.SphereGeometry(radius, 20, 20), createObjectMaterial());
            shape = new Ammo.btSphereShape(radius);
            shape.setMargin(margin);
            break;
        case 2:
            // Box
            var sx = 1 + Math.random() * objectSize;
            var sy = 1 + Math.random() * objectSize;
            var sz = 1 + Math.random() * objectSize;
            threeObject = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), createObjectMaterial());
            shape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
            shape.setMargin(margin);
            break;
        case 3:
            // Cylinder
            var radius = 1 + Math.random() * objectSize;
            var height = 1 + Math.random() * objectSize;
            threeObject = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, height, 20, 1), createObjectMaterial());
            shape = new Ammo.btCylinderShape(new Ammo.btVector3(radius, height * 0.5, radius));
            shape.setMargin(margin);
            break;
        default:
            // Cone
            var radius = 1 + Math.random() * objectSize;
            var height = 2 + Math.random() * objectSize;
            threeObject = new THREE.Mesh(new THREE.CylinderGeometry(0, radius, height, 20, 2), createObjectMaterial());
            shape = new Ammo.btConeShape(radius, height);
            break;
    }
    threeObject.position.set(0, 0, 10);
    threeObject.position.add(mapView.worldCenter).sub(physicsWorldCenter);
    threeObject.renderOrder = 1000;
    var mass = objectSize * 5;
    var localInertia = new Ammo.btVector3(0, 0, 0);
    shape.calculateLocalInertia(mass, localInertia);
    var transform = new Ammo.btTransform();
    transform.setIdentity();
    var pos = threeObject.position;
    transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
    var motionState = new Ammo.btDefaultMotionState(transform);
    var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
    var body = new Ammo.btRigidBody(rbInfo);
    threeObject.userData.physicsBody = body;
    mapView.scene.add(threeObject);
    dynamicObjects.push(threeObject);
    physicsWorld.addRigidBody(body);
}


/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/Techniques */ "./node_modules/@here/harp-datasource-protocol/lib/Techniques.js"));
__export(__webpack_require__(/*! ./lib/TechniqueParams */ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js"));
__export(__webpack_require__(/*! ./lib/InterpolatedProperty */ "./node_modules/@here/harp-datasource-protocol/lib/InterpolatedProperty.js"));
__export(__webpack_require__(/*! ./lib/InterpolatedPropertyDefs */ "./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js"));
__export(__webpack_require__(/*! ./lib/WorkerServiceProtocol */ "./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js"));
__export(__webpack_require__(/*! ./lib/WorkerTilerProtocol */ "./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js"));
__export(__webpack_require__(/*! ./lib/WorkerDecoderProtocol */ "./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js"));
__export(__webpack_require__(/*! ./lib/DecodedTile */ "./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js"));
__export(__webpack_require__(/*! ./lib/TileInfo */ "./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js"));
__export(__webpack_require__(/*! ./lib/ThemeVisitor */ "./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js"));


/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
/**
 * Returns an array with the data type specified as parameter.
 *
 * @param attr specifies which type of data is being stored in the array
 */
function getArrayConstructor(attr) {
    switch (attr) {
        case "float":
            return Float32Array;
        case "uint16":
            return Uint16Array;
        case "uint32":
            return Uint32Array;
    }
}
exports.getArrayConstructor = getArrayConstructor;
/**
 * Geometry types supported by [[Geometry]] objects.
 */
var GeometryType;
(function (GeometryType) {
    GeometryType[GeometryType["Unspecified"] = 0] = "Unspecified";
    GeometryType[GeometryType["Point"] = 1] = "Point";
    GeometryType[GeometryType["Line"] = 2] = "Line";
    GeometryType[GeometryType["SolidLine"] = 3] = "SolidLine";
    GeometryType[GeometryType["Text"] = 4] = "Text";
    GeometryType[GeometryType["TextPath"] = 5] = "TextPath";
    GeometryType[GeometryType["ExtrudedLine"] = 6] = "ExtrudedLine";
    GeometryType[GeometryType["Polygon"] = 7] = "Polygon";
    GeometryType[GeometryType["ExtrudedPolygon"] = 8] = "ExtrudedPolygon";
    GeometryType[GeometryType["Object3D"] = 9] = "Object3D";
    GeometryType[GeometryType["Other"] = 1000] = "Other";
})(GeometryType = exports.GeometryType || (exports.GeometryType = {}));
/**
 * Returns the projection object specified in the parameter.
 *
 * @param projectionName string describing projection to be used
 */
function getProjection(projectionName) {
    switch (projectionName) {
        case "mercator":
            return harp_geoutils_1.mercatorProjection;
        case "webMercator":
            return harp_geoutils_1.webMercatorProjection;
        case "sphere":
            return harp_geoutils_1.sphereProjection;
        case "normalizedEquirectangular":
            return harp_geoutils_1.normalizedEquirectangularProjection;
        case "equirectangular":
            return harp_geoutils_1.equirectangularProjection;
        default:
            throw new Error(`Unknown projection ${projectionName}`);
    } // switch
}
exports.getProjection = getProjection;
/**
 * String with the projection's name.
 *
 * @param projection `Projection` object containing the name of the projection to retrieve
 */
function getProjectionName(projection) {
    if (projection === harp_geoutils_1.mercatorProjection) {
        return "mercator";
    }
    else if (projection === harp_geoutils_1.webMercatorProjection) {
        return "webMercator";
    }
    else if (projection === harp_geoutils_1.sphereProjection) {
        return "sphere";
    }
    else if (projection === harp_geoutils_1.normalizedEquirectangularProjection) {
        return "normalizedEquirectangular";
    }
    else if (projection === harp_geoutils_1.equirectangularProjection) {
        return "equirectangular";
    }
    throw new Error("Unknown projection");
}
exports.getProjectionName = getProjectionName;


/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExponentialInterpolant.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExponentialInterpolant.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const three_1 = __webpack_require__(/*! three */ "three");
class ExponentialInterpolant extends three_1.Interpolant {
    constructor() {
        super(...arguments);
        /**
         * Exponent value. Defaults to `2.0`.
         */
        this.exponent = 2.0;
    }
    // Note: We need to disable linting here as tslint thinks this function is never used, though it
    // indeed is called by ``Interpolant.evaluate(level)``.
    // tslint:disable-next-line
    interpolate_(i1, t0, t, t1) {
        const result = this.resultBuffer;
        // TODO: Remove when Interpolant types are fixed.
        const values = this.sampleValues;
        const stride = this.valueSize;
        const offset1 = i1 * stride;
        const offset0 = offset1 - stride;
        const weight1 = Math.pow((t - t0) / (t1 - t0), this.exponent);
        const weight0 = 1 - weight1;
        for (let i = 0; i !== stride; ++i) {
            result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
        }
        return result;
    }
}
exports.ExponentialInterpolant = ExponentialInterpolant;


/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/InterpolatedProperty.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/InterpolatedProperty.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const three_1 = __webpack_require__(/*! three */ "three");
const ExponentialInterpolant_1 = __webpack_require__(/*! ./ExponentialInterpolant */ "./node_modules/@here/harp-datasource-protocol/lib/ExponentialInterpolant.js");
const InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ "./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js");
const interpolants = [
    three_1.DiscreteInterpolant,
    three_1.LinearInterpolant,
    three_1.CubicInterpolant,
    ExponentialInterpolant_1.ExponentialInterpolant
];
/**
 * Get the value of the specified property at the given zoom level. Handles [[InterpolatedProperty]]
 * instances as well as future interpolated values.
 *
 * @param property Property of a technique.
 * @param level Display level the property should be rendered at.
 */
function getPropertyValue(property, level) {
    if (!isInterpolatedProperty(property)) {
        if (isInterpolatedPropertyDefinition(property)) {
            throw new Error("Invalid property definition");
        }
        return property;
    }
    else {
        const nChannels = property.values.length / property.zoomLevels.length;
        const isMultiChannel = nChannels > 1;
        const interpolant = new interpolants[property.interpolationMode](property.zoomLevels, property.values, nChannels);
        if (property.interpolationMode === InterpolatedPropertyDefs_1.InterpolationMode.Exponential &&
            property.exponent !== undefined) {
            interpolant.exponent = property.exponent;
        }
        interpolant.evaluate(level);
        let result = isMultiChannel ? "#" : 0;
        for (const value of interpolant.resultBuffer) {
            // tslint:disable:no-bitwise
            const val = isMultiChannel
                ? ("0" + ((harp_geoutils_1.MathUtils.clamp(value, 0, 1) * 255) | 0).toString(16)).slice(-2)
                : value;
            result += val;
        }
        return result;
    }
}
exports.getPropertyValue = getPropertyValue;
/**
 * Checks if a property is interpolated.
 * @param p property to be checked
 */
function isInterpolatedPropertyDefinition(p) {
    if (p !== undefined &&
        p.values instanceof Array &&
        p.values.length > 0 &&
        p.values[0] !== undefined &&
        p.zoomLevels instanceof Array &&
        p.zoomLevels.length > 0 &&
        p.zoomLevels[0] !== undefined &&
        p.values.length === p.zoomLevels.length) {
        return true;
    }
    return false;
}
exports.isInterpolatedPropertyDefinition = isInterpolatedPropertyDefinition;
/**
 * Type guard to check if an object is an instance of `InterpolatedProperty`.
 */
function isInterpolatedProperty(p) {
    if (p !== undefined &&
        p.interpolationMode !== undefined &&
        p.zoomLevels !== undefined &&
        p.values !== undefined &&
        p.values.length > 0 &&
        (p.zoomLevels.length === p.values.length / 3 || p.zoomLevels.length === p.values.length)) {
        return true;
    }
    return false;
}
exports.isInterpolatedProperty = isInterpolatedProperty;


/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Interpolation mode used when computing a [[InterpolatedProperty]] value for a given zoom level.
 */
var InterpolationMode;
(function (InterpolationMode) {
    InterpolationMode[InterpolationMode["Discrete"] = 0] = "Discrete";
    InterpolationMode[InterpolationMode["Linear"] = 1] = "Linear";
    InterpolationMode[InterpolationMode["Cubic"] = 2] = "Cubic";
    InterpolationMode[InterpolationMode["Exponential"] = 3] = "Exponential";
})(InterpolationMode = exports.InterpolationMode || (exports.InterpolationMode = {}));


/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var TextureCoordinateType;
(function (TextureCoordinateType) {
    /**
     * Texture coordinates are in tile space.
     * SW of the tile will have (0,0) and NE will have (1,1).
     */
    TextureCoordinateType["TileSpace"] = "tile-space";
    /**
     * Texture coordinates are in equirectangular space.
     * (u, v) = ( (longitude+180) / 360, (latitude+90) / 180).
     */
    TextureCoordinateType["EquirectangularSpace"] = "equirectangular-space";
})(TextureCoordinateType = exports.TextureCoordinateType || (exports.TextureCoordinateType = {}));
/**
 * Define the stacking option. Enum values for theme file are in "kebab-case".
 */
var PoiStackMode;
(function (PoiStackMode) {
    /**
     * Show in a stack.
     */
    PoiStackMode["Show"] = "show-in-stack";
    /**
     * Do not show in a stack.
     */
    PoiStackMode["Hide"] = "hide-in-stack";
    /**
     * Show category parent in the stack.
     */
    PoiStackMode["ShowParent"] = "show-parent";
})(PoiStackMode = exports.PoiStackMode || (exports.PoiStackMode = {}));
/**
 * Type guard to check if an object is an instance of `TextureBuffer`.
 */
function isTextureBuffer(object) {
    return object && object.buffer && typeof object.type === "string";
}
exports.isTextureBuffer = isTextureBuffer;


/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Techniques.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Techniques.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const TechniqueParams_1 = __webpack_require__(/*! ./TechniqueParams */ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js");
/**
 * Names of the supported texure properties.
 */
exports.TEXTURE_PROPERTY_KEYS = [
    "map",
    "normalMap",
    "displacementMap",
    "roughnessMap",
    "emissiveMap",
    "alphaMap",
    "metalnessMap",
    "bumpMap"
];
/**
 * Type guard to check if an object is an instance of [[CirclesTechnique]].
 */
function isCirclesTechnique(technique) {
    return technique.name === "circles";
}
exports.isCirclesTechnique = isCirclesTechnique;
/**
 * Type guard to check if an object is an instance of [[SquaresTechnique]].
 */
function isSquaresTechnique(technique) {
    return technique.name === "squares";
}
exports.isSquaresTechnique = isSquaresTechnique;
/**
 * Type guard to check if an object is an instance of [[PoiTechnique]].
 */
function isPoiTechnique(technique) {
    return technique.name === "labeled-icon";
}
exports.isPoiTechnique = isPoiTechnique;
/**
 * Type guard to check if an object is an instance of [[LineMarkerTechnique]].
 */
function isLineMarkerTechnique(technique) {
    return technique.name === "line-marker";
}
exports.isLineMarkerTechnique = isLineMarkerTechnique;
/**
 * Type guard to check if an object is an instance of [[DashedLineTechnique]].
 */
function isDashedLineTechnique(technique) {
    return technique.name === "dashed-line";
}
exports.isDashedLineTechnique = isDashedLineTechnique;
/**
 * Type guard to check if an object is an instance of [[LineTechnique]].
 */
function isLineTechnique(technique) {
    return technique.name === "line";
}
exports.isLineTechnique = isLineTechnique;
/**
 * Type guard to check if an object is an instance of [[SolidLineTechnique]].
 */
function isSolidLineTechnique(technique) {
    return technique.name === "solid-line";
}
exports.isSolidLineTechnique = isSolidLineTechnique;
/**
 * Type guard to check if an object is an instance of [[SegmentsTechnique]].
 */
function isSegmentsTechnique(technique) {
    return technique.name === "segments";
}
exports.isSegmentsTechnique = isSegmentsTechnique;
/**
 * Type guard to check if an object is an instance of [[BasicExtrudedLineTechnique]]
 * or [[StandardExtrudedLineTechnique]].
 */
function isExtrudedLineTechnique(technique) {
    return technique.name === "extruded-line";
}
exports.isExtrudedLineTechnique = isExtrudedLineTechnique;
/**
 * Type guard to check if an object is an instance of [[BasicExtrudedLineTechnique]].
 */
function isBasicExtrudedLineTechnique(technique) {
    return isExtrudedLineTechnique(technique) && technique.shading === "basic";
}
exports.isBasicExtrudedLineTechnique = isBasicExtrudedLineTechnique;
/**
 * Type guard to check if an object is an instance of [[StandardExtrudedLineTechnique]].
 */
function isStandardExtrudedLineTechnique(technique) {
    return isExtrudedLineTechnique(technique) && technique.shading === "standard";
}
exports.isStandardExtrudedLineTechnique = isStandardExtrudedLineTechnique;
/**
 * Type guard to check if an object is an instance of [[FillTechnique]].
 */
function isFillTechnique(technique) {
    return technique.name === "fill";
}
exports.isFillTechnique = isFillTechnique;
/**
 * Type guard to check if an object is an instance of [[ExtrudedPolygonTechnique]].
 */
function isExtrudedPolygonTechnique(technique) {
    return technique.name === "extruded-polygon";
}
exports.isExtrudedPolygonTechnique = isExtrudedPolygonTechnique;
/**
 * Type guard to check if an object is an instance of [[StandardTechnique]].
 */
function isStandardTechnique(technique) {
    return technique.name === "standard";
}
exports.isStandardTechnique = isStandardTechnique;
/**
 * Type guard to check if an object is an instance of [[TerrainTechnique]].
 */
function isTerrainTechnique(technique) {
    return technique.name === "terrain";
}
exports.isTerrainTechnique = isTerrainTechnique;
/**
 * Type guard to check if an object is an instance of [[TextTechnique]].
 */
function isTextTechnique(technique) {
    return technique.name === "text";
}
exports.isTextTechnique = isTextTechnique;
/**
 * Type guard to check if an object is an instance of [[ShaderTechnique]].
 */
function isShaderTechnique(technique) {
    return technique.name === "shader";
}
exports.isShaderTechnique = isShaderTechnique;
/**
 * Check if vertex normals should be generated for this technique (if no normals are in the data).
 * @param technique Technique to check.
 */
function needsVertexNormals(technique) {
    return (isStandardTechnique(technique) ||
        isTerrainTechnique(technique) ||
        isStandardExtrudedLineTechnique(technique));
}
exports.needsVertexNormals = needsVertexNormals;
/**
 * Get the texture coordinate type if the technique supports it.
 */
function textureCoordinateType(technique) {
    if (isStandardTechnique(technique)) {
        return technique.textureCoordinateType;
    }
    else if (isExtrudedPolygonTechnique(technique)) {
        return technique.textureCoordinateType;
    }
    else if (isTerrainTechnique(technique)) {
        return technique.textureCoordinateType;
    }
    else {
        return undefined;
    }
}
exports.textureCoordinateType = textureCoordinateType;
/**
 * Add all the buffers of the technique to the transfer list.
 */
function addBuffersToTransferList(technique, transferList) {
    if (isStandardTechnique(technique) ||
        isExtrudedPolygonTechnique(technique) ||
        isTerrainTechnique(technique)) {
        for (const texturePropertyKey of exports.TEXTURE_PROPERTY_KEYS) {
            const textureProperty = technique[texturePropertyKey];
            if (TechniqueParams_1.isTextureBuffer(textureProperty)) {
                if (textureProperty.buffer instanceof ArrayBuffer) {
                    transferList.push(textureProperty.buffer);
                }
            }
        }
    }
}
exports.addBuffersToTransferList = addBuffersToTransferList;


/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The ThemeVisitor visits every style in the theme in a depth-first fashion.
 */
class ThemeVisitor {
    constructor(theme) {
        this.theme = theme;
    }
    /**
     * Applies a function to every style in the theme.
     *
     * @param visitFunc Function to be called with `style` as an argument. Function should return
     *                  `true` to cancel visitation.
     * @returns `true` if function has finished prematurely.
     */
    visitStyles(visitFunc) {
        const visit = (style) => {
            if (visitFunc(style)) {
                return true;
            }
            if (style.styles !== undefined) {
                for (const currStyle of style.styles) {
                    if (visit(currStyle)) {
                        return true;
                    }
                }
            }
            return false;
        };
        if (this.theme.styles !== undefined) {
            for (const styleSetName in this.theme.styles) {
                if (this.theme.styles[styleSetName] !== undefined) {
                    for (const style of this.theme.styles[styleSetName]) {
                        if (visit(style)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
}
exports.ThemeVisitor = ThemeVisitor;


/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
/**
 * Minimum estimated size of a JS object.
 */
const MINIMUM_OBJECT_SIZE_ESTIMATION = 100;
/**
 * Structure of arrays containing data for all features of this group. No methods, since the object
 * is being passed as part of ExtendedTileInfo across "process boundaries" to the web worker.
 *
 * Supporting methods in namespace [[ExtendedTileInfo]].
 */
class FeatureGroup {
    /**
     * Construct featureGroup.
     *
     * @param storeExtendedTags Pass `true` to create fields for more OMV tags (`layer`, `class`
     * and `type`).
     */
    constructor(storeExtendedTags, startSize = 5000) {
        /** featureIds */
        this.featureIds = new Array();
        /** number of features */
        this.numFeatures = 0;
        /** number of positions of elements (2 per point) */
        this.numPositions = 0;
        this.featureIds = new Array(startSize);
        this.featureIds.length = startSize;
        this.techniqueIndex = new Array(startSize);
        this.techniqueIndex.length = startSize;
        this.textIndex = new Array(startSize);
        this.textIndex.length = startSize;
        this.positionIndex = new Array(startSize);
        this.positionIndex.length = startSize;
        this.positions = new Array(10 * startSize);
        this.positions.length = 10 * startSize;
        if (storeExtendedTags) {
            this.layerIndex = new Array(startSize);
            this.layerIndex.length = startSize;
            this.classIndex = new Array(startSize);
            this.classIndex.length = startSize;
            this.typeIndex = new Array(startSize);
            this.typeIndex.length = startSize;
        }
    }
    /**
     * Compute size in bytes.
     */
    getNumBytes() {
        return ((this.featureIds.length +
            this.techniqueIndex.length +
            this.textIndex.length +
            this.positionIndex.length +
            this.positions.length +
            (this.layerIndex !== undefined ? this.layerIndex.length : 0) +
            (this.classIndex !== undefined ? this.classIndex.length : 0) +
            (this.typeIndex !== undefined ? this.typeIndex.length : 0)) *
            8);
    }
}
exports.FeatureGroup = FeatureGroup;
/**
 * Structure of arrays containing data for roads. No methods, since the object is being passed as
 * part of [[ExtendedTileInfo]] across "process boundaries" to the web worker.
 */
class LineFeatureGroup extends FeatureGroup {
    constructor() {
        super(...arguments);
        /**
         * An array of object defined by the user. Certain elements may be `undefined` (if this line
         * feature is not a road, or if the object for that feature is undefined).
         */
        this.userData = [];
    }
    getNumBytes() {
        return (super.getNumBytes() +
            ((this.segmentIds !== undefined ? this.segmentIds.length : 0) +
                (this.segmentStartOffsets !== undefined ? this.segmentStartOffsets.length : 0) +
                (this.segmentEndOffsets !== undefined ? this.segmentEndOffsets.length : 0)) *
                8);
    }
}
exports.LineFeatureGroup = LineFeatureGroup;
/**
 * Structure of arrays containing data for polygons. No methods, since the object is being passed as
 * part of ExtendedTileInfo across "process boundaries" to the web worker.
 *
 * Supporting methods in namespace [[ExtendedTileInfo]].
 *
 * Due to the complexity of the access, there are supporting classes to store and access data in
 * the feature groups. See [[ExtendedTileInfoWriter]] and [[ExtendedTileInfoPolygonAccessor]].
 */
class PolygonFeatureGroup extends FeatureGroup {
    constructor(storeExtendedTags, startSize = 5000) {
        super(storeExtendedTags, startSize);
        /**
         * Number of rings stored in all polygons in tis group. Used to keep size of the
         * arrays.
         */
        this.groupNumRings = 0;
        this.outerRingStartIndex = new Array(startSize);
        this.outerRingStartIndex.length = startSize;
        this.innerRingIsOuterContour = new Array(startSize);
        this.innerRingIsOuterContour.length = startSize;
        this.innerRingStartIndex = new Array(startSize);
        this.innerRingStartIndex.length = startSize;
    }
    getNumBytes() {
        return (super.getNumBytes() +
            ((this.outerRingStartIndex !== undefined ? this.outerRingStartIndex.length : 0) +
                (this.innerRingIsOuterContour !== undefined
                    ? this.innerRingIsOuterContour.length
                    : 0) +
                (this.innerRingStartIndex !== undefined ? this.innerRingStartIndex.length : 0)) *
                8);
    }
}
exports.PolygonFeatureGroup = PolygonFeatureGroup;
/**
 * Class to hold infos from [[OmvTile]]s. Optimized for fast serialization when being passed from
 * webworker to main thread. No methods, since the object is being passed across "process
 * boundaries" to the web worker.
 *
 * Supporting methods in namespace [[ExtendedTileInfo]].
 *
 * Due to the complexity of the access, there are supporting classes to store and access data in
 * the feature groups. See [[ExtendedTileInfoWriter]] and [[ExtendedTileInfoPolygonAccessor]].
 */
class ExtendedTileInfo {
    constructor(tileKey, storeExtendedTags) {
        this.tileKey = tileKey;
        /**
         * Catalog of strings. Addressed by every features stringIndex.
         */
        this.textCatalog = new Array();
        /**
         * Catalog of techniques. Addressed by every features featureIndex.
         */
        this.techniqueCatalog = new Array();
        /**
         * Used for performance diagnostics.
         */
        this.setupTime = 0;
        /**
         * Size in bytes.
         */
        this.numBytes = 0;
        this.pointGroup = new FeatureGroup(storeExtendedTags);
        this.lineGroup = new LineFeatureGroup(storeExtendedTags);
        this.polygonGroup = new PolygonFeatureGroup(storeExtendedTags);
        if (storeExtendedTags) {
            this.layerCatalog = new Array();
            this.classCatalog = new Array();
            this.typeCatalog = new Array();
        }
    }
    /**
     * Compute the memory footprint caused by objects owned by the `ExtendedTileInfo`.
     */
    getNumBytes() {
        let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;
        for (const str of this.textCatalog) {
            numBytes += 2 * str.length;
        }
        numBytes += this.techniqueCatalog.length * MINIMUM_OBJECT_SIZE_ESTIMATION;
        numBytes += this.pointGroup.getNumBytes();
        numBytes += this.lineGroup.getNumBytes();
        numBytes += this.polygonGroup.getNumBytes();
        if (this.layerCatalog !== undefined) {
            for (const str of this.layerCatalog) {
                numBytes += 2 * str.length;
            }
            for (const str of this.classCatalog) {
                numBytes += 2 * str.length;
            }
            for (const str of this.typeCatalog) {
                numBytes += 2 * str.length;
            }
        }
        return numBytes;
    }
}
exports.ExtendedTileInfo = ExtendedTileInfo;
(function (ExtendedTileInfo) {
    function finishFeatureGroup(featureGroup) {
        featureGroup.featureIds.length = featureGroup.numFeatures;
        featureGroup.techniqueIndex.length = featureGroup.numFeatures;
        featureGroup.textIndex.length = featureGroup.numFeatures;
        featureGroup.positionIndex.length = featureGroup.numFeatures;
        featureGroup.positions.length = featureGroup.numPositions;
        if (featureGroup.layerIndex !== undefined) {
            featureGroup.layerIndex.length = featureGroup.numFeatures;
        }
        if (featureGroup.classIndex !== undefined) {
            featureGroup.classIndex.length = featureGroup.numFeatures;
        }
        if (featureGroup.typeIndex !== undefined) {
            featureGroup.typeIndex.length = featureGroup.numFeatures;
        }
    }
    function finishPolygonFeatureGroup(polygonGroup) {
        finishFeatureGroup(polygonGroup);
        polygonGroup.outerRingStartIndex.length = polygonGroup.numFeatures;
        polygonGroup.innerRingIsOuterContour.length = polygonGroup.groupNumRings;
        polygonGroup.innerRingStartIndex.length = polygonGroup.groupNumRings;
    }
    function finishLineFeatureGroup(lineGroup) {
        finishFeatureGroup(lineGroup);
        if (lineGroup.segmentIds !== undefined) {
            lineGroup.segmentIds.length = lineGroup.numFeatures;
            lineGroup.segmentStartOffsets.length = lineGroup.numFeatures;
            lineGroup.segmentEndOffsets.length = lineGroup.numFeatures;
        }
    }
    /**
     * Finalize the tile's features groups.
     */
    function finish(tileInfo) {
        finishFeatureGroup(tileInfo.pointGroup);
        finishLineFeatureGroup(tileInfo.lineGroup);
        finishPolygonFeatureGroup(tileInfo.polygonGroup);
        tileInfo.numBytes = tileInfo.getNumBytes();
    }
    ExtendedTileInfo.finish = finish;
    /**
     * Returns the number of features in this feature group.
     */
    function featureGroupSize(featureGroup) {
        return featureGroup.numFeatures;
    }
    ExtendedTileInfo.featureGroupSize = featureGroupSize;
    /**
     * Check if the feature group is finalized.
     */
    function featureGroupFinished(featureGroup) {
        return featureGroup.numPositions === featureGroup.positions.length;
    }
    ExtendedTileInfo.featureGroupFinished = featureGroupFinished;
    /**
     * Check if the tileInfo is finalized.
     */
    function tileInfoFinished(tileInfo) {
        return (featureGroupFinished(tileInfo.pointGroup) &&
            featureGroupFinished(tileInfo.lineGroup) &&
            featureGroupFinished(tileInfo.polygonGroup));
    }
    ExtendedTileInfo.tileInfoFinished = tileInfoFinished;
    /**
     * Determine the text string of the (OMV) feature. It implements the special handling required
     * to determine the text content of a feature from its tags, which are passed in as the `env`.
     *
     * @param env Environment containing the tags from the (OMV) feature.
     * @param useAbbreviation `true` to use the abbreviation if available.
     * @param useIsoCode `true` to use the tag "iso_code".
     * @param languages List of languages to use, for example: Specify "en" to use the tag "name_en"
     *                  as the text of the string. Order reflects priority.
     */
    function getFeatureName(env, useAbbreviation, useIsoCode, languages) {
        let name;
        if (useAbbreviation) {
            const abbreviation = env.lookup(`name:short`);
            if (typeof abbreviation === "string" && abbreviation.length > 0) {
                return abbreviation;
            }
        }
        if (useIsoCode) {
            const isoCode = env.lookup(`iso_code`);
            if (typeof isoCode === "string" && isoCode.length > 0) {
                return isoCode;
            }
        }
        if (languages !== undefined) {
            for (const lang of languages) {
                name = env.lookup(`name:${lang}`) || env.lookup(`name_${lang}`);
                if (typeof name === "string" && name.length > 0) {
                    return name;
                }
            }
        }
        name = env.lookup("name");
        if (typeof name === "string") {
            return name;
        }
        return undefined;
    }
    ExtendedTileInfo.getFeatureName = getFeatureName;
})(ExtendedTileInfo = exports.ExtendedTileInfo || (exports.ExtendedTileInfo = {}));
/**
 * Support class for [[ExtendedTileInfo]]. Assist in filling it with data.
 */
class ExtendedTileInfoWriter {
    /**
     * Create an [[ExtendedTileInfoWriter]] for an [[ExtendedTileInfo]]. Assist in filling the
     * [[ExtendedTileInfo]] with data.
     *
     * @param tileInfo [[ExtendedTileInfo]] to write data to.
     * @param storeExtendedTags Pass `true` if feature data like `layer`, `class`or `type` should
     *          be stored for every feature.
     */
    constructor(tileInfo, storeExtendedTags, languages) {
        this.tileInfo = tileInfo;
        this.storeExtendedTags = storeExtendedTags;
        this.languages = languages;
        /** Map to identify which techniques already have been added to the [[ExtendedTileInfo]]. */
        this.techniqueIndexMap = new Map();
        /** Map to identify which strings already have been added to the [[ExtendedTileInfo]]. */
        this.stringMap = new Map();
        /** Map to identify which `layer` names already have been added to the [[ExtendedTileInfo]]. */
        this.layerMap = new Map();
        /** Map to identify which `class` names already have been added to the [[ExtendedTileInfo]]. */
        this.classMap = new Map();
        /** Map to identify which `type` names already have been added to the [[ExtendedTileInfo]]. */
        this.typeMap = new Map();
    }
    /**
     * Adds a [[Technique]] to the catalog of techniques. Individual techniques have a `_index` file
     * which has been created in the [[StyleSetEvaluator]]. This index is required to identify a
     * technique. The `Map` is used to map techniques to already added techniques, or store the
     * technique as new, and add it to the map.
     *
     * @param technique The [[Technique]] to add.
     */
    addTechnique(technique) {
        let infoTileTechniqueIndex = this.techniqueIndexMap.get(technique._index);
        if (infoTileTechniqueIndex !== undefined) {
            return infoTileTechniqueIndex;
        }
        infoTileTechniqueIndex = this.tileInfo.techniqueCatalog.length;
        // add a new technique. Select the subset of features that should be stored (e.g., _index is
        // not)
        const storedTechnique = {};
        Object.getOwnPropertyNames(technique).forEach(property => {
            if (!property.startsWith("_")) {
                storedTechnique[property] = technique[property];
            }
        });
        // Keep the index to identify the original technique later.
        storedTechnique._index = technique._index;
        storedTechnique._styleSetIndex = technique._styleSetIndex;
        this.techniqueIndexMap.set(technique._index, infoTileTechniqueIndex);
        this.tileInfo.techniqueCatalog.push(storedTechnique);
        return infoTileTechniqueIndex;
    }
    /**
     * Add a feature.
     *
     * @param featureGroup The feature group to add to.
     * @param technique The technique to add.
     * @param env The `env` which is a mix of original OMV feature tags and fields added by the
     *      [[StyleSetEvaluator]]
     * @param featureId The featureId, a number unique for many features (but not all).
     * @param infoTileTechniqueIndex The previously computed index of the technique. Must have been
     *      computed by `addTechnique(technique)`.
     * @param isPolygonGroup `true`for polygons.
     */
    addFeature(featureGroup, technique, env, featureId, infoTileTechniqueIndex, isPolygonGroup) {
        // compute name/label of feature
        const textTechnique = technique;
        const textLabel = textTechnique.label;
        const useAbbreviation = textTechnique.useAbbreviation;
        const useIsoCode = textTechnique.useIsoCode;
        const name = typeof textLabel === "string"
            ? env.lookup(textLabel)
            : ExtendedTileInfo.getFeatureName(env, useAbbreviation, useIsoCode, this.languages);
        let stringIndex = -1;
        if (name && typeof name === "string") {
            stringIndex = this.addText(name);
        }
        // add indices into the arrays.
        featureGroup.featureIds[featureGroup.numFeatures] = featureId;
        featureGroup.techniqueIndex[featureGroup.numFeatures] = infoTileTechniqueIndex;
        featureGroup.textIndex[featureGroup.numFeatures] = stringIndex;
        featureGroup.positionIndex[featureGroup.numFeatures] = featureGroup.numPositions;
        // polygons need the extra fields for polygon rings
        if (isPolygonGroup) {
            const polygonGroup = featureGroup;
            harp_utils_1.assert(polygonGroup.outerRingStartIndex !== undefined);
            harp_utils_1.assert(polygonGroup.innerRingStartIndex !== undefined);
            harp_utils_1.assert(polygonGroup.innerRingIsOuterContour !== undefined);
            polygonGroup.outerRingStartIndex[featureGroup.numFeatures] = polygonGroup.groupNumRings;
        }
        // store the extra feature fields
        if (this.storeExtendedTags) {
            featureGroup.layerIndex[featureGroup.numFeatures] = this.addLayer(env.lookup("$layer"));
            featureGroup.classIndex[featureGroup.numFeatures] = this.addClass(env.lookup("class"));
            featureGroup.typeIndex[featureGroup.numFeatures] = this.addType(env.lookup("type"));
        }
        featureGroup.numFeatures++;
    }
    /**
     * Add the X/Y coordinate of the point. Only for point feature groups.
     *
     * @param featureGroup The feature group to add it to.
     * @param x X Position of point.
     * @param y Y Position of point.
     */
    addFeaturePoint(featureGroup, x, y) {
        featureGroup.positions[featureGroup.numPositions++] = x;
        featureGroup.positions[featureGroup.numPositions++] = y;
    }
    /**
     * Add the line points as X/Y coordinates to the line feature.
     *
     * If a line feature has more than one line (rare for HERE data), it should define multiple
     * line features for it.
     *
     * @param featureGroup The feature group to add to. Must be line feature group.
     * @param points The X/Y coordinates of the points.
     */
    addFeaturePoints(featureGroup, points) {
        const n = featureGroup.numPositions;
        const l = points.length;
        const p = featureGroup.positions;
        for (let i = 0; i < l; i++) {
            p[n + i] = points[i];
        }
        featureGroup.numPositions += points.length;
    }
    /**
     * Add the information about road segments to the line feature. Performs lazy initialization of
     * `segmentIds`, `segmentStartOffsets`, and `segmentEndOffsets` members of a
     * [[LineFeatureGroup]] instance.
     *
     * @param featureGroup The line feature group to add information to.
     * @param segmentId Segment id of a feature.
     * @param startOffset Start offset of a feature.
     * @param endOffset End offset of a feature.
     */
    addRoadSegments(featureGroup, segmentId, startOffset, endOffset) {
        if (featureGroup.segmentIds === undefined) {
            featureGroup.segmentIds = new Array();
            featureGroup.segmentStartOffsets = new Array();
            featureGroup.segmentEndOffsets = new Array();
        }
        featureGroup.segmentIds[featureGroup.numFeatures - 1] = segmentId;
        featureGroup.segmentStartOffsets[featureGroup.numFeatures - 1] = startOffset;
        featureGroup.segmentEndOffsets[featureGroup.numFeatures - 1] = endOffset;
    }
    /**
     * Add a single ring to the polygon. Can be called multiple times to add multiple rings to the
     * polygon.
     *
     * @param featureGroup Polygon feature group to add polygon ring to.
     * @param contour The X/Y coordinates of the ring.
     * @param isOuterRing Pass `true`if it is a outer ring, otherwise `false`.
     */
    addRingPoints(featureGroup, contour, isOuterRing) {
        featureGroup.innerRingStartIndex[featureGroup.groupNumRings] = featureGroup.numPositions;
        featureGroup.innerRingIsOuterContour[featureGroup.groupNumRings] = isOuterRing ? 1 : 0;
        featureGroup.groupNumRings++;
        const n = featureGroup.numPositions;
        const l = contour.length;
        const p = featureGroup.positions;
        for (let i = 0; i < l; i++) {
            p[n + i] = contour[i];
        }
        featureGroup.numPositions += contour.length;
    }
    /**
     * Finalize the tile info's feature group.
     */
    finish() {
        ExtendedTileInfo.finish(this.tileInfo);
    }
    addText(name) {
        return this.addStringValue(name, this.tileInfo.textCatalog, this.stringMap);
    }
    addLayer(name) {
        return this.addStringValue(name, this.tileInfo.layerCatalog, this.layerMap);
    }
    addClass(name) {
        return this.addStringValue(name, this.tileInfo.classCatalog, this.classMap);
    }
    addType(name) {
        return this.addStringValue(name, this.tileInfo.typeCatalog, this.typeMap);
    }
    // Add a string to the strings catalog. Returns index into the catalog.
    addStringValue(str, catalog, map) {
        if (str === undefined) {
            return -1;
        }
        const name = str.toString();
        let i = map.get(name);
        if (i !== undefined) {
            return i;
        }
        i = catalog.length;
        catalog.push(name);
        map.set(name, i);
        return i;
    }
}
exports.ExtendedTileInfoWriter = ExtendedTileInfoWriter;
/**
 * Implementation of [[ExtendedTileInfoPolygonAccessor]].
 */
class ExtendedTileInfoPolygonAccessorImpl {
    constructor() {
        /**
         * Feature's index in the group.
         */
        this.featureIndex = 0;
        /**
         * Indicates where the ring starts.
         */
        this.ringStart = 0;
        /**
         * Number of rings.
         */
        this.numRings = 0;
    }
    /**
     * Setup the accessor for extended [[TileInfo]].
     *
     * @param polygons polygons feature group.
     * @param featureIndex feature's index in the group.
     * @param ringStart where the ring starts.
     * @param numRings number of rings.
     */
    setup(polygons, featureIndex, ringStart, numRings) {
        this.polygons = polygons;
        this.featureIndex = featureIndex;
        this.ringStart = ringStart;
        this.numRings = numRings;
    }
    /**
     * Shut down the accessor and free all references.
     */
    reset() {
        this.polygons = undefined;
        this.featureIndex = 0;
        this.ringStart = 0;
        this.numRings = 0;
    }
    isOuterRing(ringIndex) {
        harp_utils_1.assert(ringIndex >= 0);
        harp_utils_1.assert(ringIndex < this.numRings);
        harp_utils_1.assert(this.polygons !== undefined);
        if (ringIndex < 0 || ringIndex >= this.numRings || this.polygons === undefined) {
            throw new Error("ExtendedTileInfoPolygonAccessor: Invalid ring index");
        }
        return this.polygons.innerRingIsOuterContour[this.ringStart + ringIndex] !== 0;
    }
    getPoints(ringIndex) {
        harp_utils_1.assert(ringIndex >= 0);
        harp_utils_1.assert(ringIndex < this.numRings);
        harp_utils_1.assert(this.polygons !== undefined);
        if (ringIndex < 0 || ringIndex >= this.numRings || this.polygons === undefined) {
            throw new Error("ExtendedTileInfoPolygonAccessor: Invalid ring index");
        }
        // compute the start/size of the points in this ring. All `points` are actually just the
        // indices of a single X/Y coordinate.
        const pointsStart = this.polygons.innerRingStartIndex[this.ringStart + ringIndex];
        let numPointValues;
        if (ringIndex < this.numRings - 1) {
            numPointValues =
                this.polygons.innerRingStartIndex[this.ringStart + ringIndex + 1] - pointsStart;
        }
        else {
            if (this.ringStart + ringIndex < this.polygons.innerRingStartIndex.length - 1) {
                numPointValues =
                    this.polygons.innerRingStartIndex[this.ringStart + ringIndex + 1] - pointsStart;
            }
            else {
                numPointValues = this.polygons.positions.length - pointsStart;
            }
        }
        return {
            points: this.polygons.positions,
            pointsStart,
            numPointValues
        };
    }
}
/**
 * Supporting class for [[ExtendedTileInfo]]. Takes an [[ExtendedTileInfoHandler]] and calls an
 * `accept` for every feature of the [[ExtendedTileInfo]], or just all features of a specified
 * `featureId`.
 */
class ExtendedTileInfoVisitor {
    constructor(tileInfo) {
        this.tileInfo = tileInfo;
    }
    /**
     * Visit all feature in the [[ExtendedTileInfo]]
     *
     * @param handler Let the `handler` visit all features.
     */
    visitAll(handler) {
        this.visitAllPointFeatures(handler);
        this.visitAllLineFeatures(handler);
        this.visitAllPolygonFeatures(handler);
    }
    /**
     * Visit all features of a specified featureId.
     *
     * @param featureId The featureId to visit.
     * @param handler The `handler` to use.
     */
    visitFeature(featureId, handler) {
        let numFeaturesFound = 0;
        const numPointFeatures = this.tileInfo.pointGroup.numFeatures;
        const pointFeatures = this.tileInfo.pointGroup.featureIds;
        for (let i = 0; i < numPointFeatures; i++) {
            if (pointFeatures[i] === featureId) {
                numFeaturesFound++;
                this.visitPointFeature(i, handler);
            }
        }
        const numLineFeatures = this.tileInfo.lineGroup.numFeatures;
        const lineFeatures = this.tileInfo.lineGroup.featureIds;
        for (let i = 0; i < numLineFeatures; i++) {
            if (lineFeatures[i] === featureId) {
                numFeaturesFound++;
                this.visitLineFeature(i, handler);
            }
        }
        const numPolygonFeatures = this.tileInfo.polygonGroup.numFeatures;
        const polygonsFeatures = this.tileInfo.polygonGroup.featureIds;
        for (let i = 0; i < numPolygonFeatures; i++) {
            if (polygonsFeatures[i] === featureId) {
                numFeaturesFound++;
                this.visitPolygonFeature(i, handler);
            }
        }
        return numFeaturesFound;
    }
    /**
     * Visit all `POINT` features.
     *
     * @param handler The `handler` to use.
     */
    visitAllPointFeatures(handler) {
        const numFeatures = this.tileInfo.pointGroup.numFeatures;
        for (let i = 0; i < numFeatures; i++) {
            this.visitPointFeature(i, handler);
        }
    }
    /**
     * Visit all `LINESTRING` features.
     *
     * @param handler The handler to use.
     */
    visitAllLineFeatures(handler) {
        const numFeatures = this.tileInfo.lineGroup.numFeatures;
        for (let i = 0; i < numFeatures; i++) {
            this.visitLineFeature(i, handler);
        }
    }
    /**
     * Visit all `POLYGON` features.
     *
     * @param handler The `handler` to use.
     */
    visitAllPolygonFeatures(handler) {
        const numFeatures = this.tileInfo.polygonGroup.numFeatures;
        for (let i = 0; i < numFeatures; i++) {
            this.visitPolygonFeature(i, handler);
        }
    }
    getTag(featureIndex, index) {
        return index !== undefined && index[featureIndex] >= 0 ? index[featureIndex] : -1;
    }
    /**
     * Call the `handler` on a point feature.
     *
     * @param featureIndex The index of the feature into the feature table.
     * @param handler The `handler` to use.
     */
    visitPointFeature(featureIndex, handler) {
        const tileInfo = this.tileInfo;
        const points = tileInfo.pointGroup;
        const start = points.positionIndex[featureIndex];
        const x = points.positions[start];
        const y = points.positions[start + 1];
        if (!!handler.acceptPoint) {
            handler.acceptPoint(points.featureIds[featureIndex], points.techniqueIndex[featureIndex], x, y, points.textIndex[featureIndex], this.getTag(featureIndex, points.layerIndex), this.getTag(featureIndex, points.classIndex), this.getTag(featureIndex, points.typeIndex));
        }
    }
    /**
     * Call the `handler` on a line feature.
     *
     * @param featureIndex The index of the feature into the feature table.
     * @param handler The `handler` to use.
     */
    visitLineFeature(featureIndex, handler) {
        const tileInfo = this.tileInfo;
        const lines = tileInfo.lineGroup;
        const numFeatures = lines.numFeatures;
        const positionsStart = lines.positionIndex[featureIndex];
        const numPointValues = featureIndex === numFeatures - 1
            ? lines.positions.length - positionsStart
            : lines.positionIndex[featureIndex + 1] - positionsStart;
        let segmentId;
        let startOffset;
        let endOffset;
        if (lines.segmentIds !== undefined) {
            segmentId = lines.segmentIds[featureIndex];
            startOffset = lines.segmentStartOffsets[featureIndex];
            endOffset = lines.segmentEndOffsets[featureIndex];
        }
        if (!!handler.acceptLine) {
            handler.acceptLine(lines.featureIds[featureIndex], lines.techniqueIndex[featureIndex], lines.textIndex[featureIndex], this.getTag(featureIndex, lines.layerIndex), this.getTag(featureIndex, lines.classIndex), this.getTag(featureIndex, lines.typeIndex), tileInfo.lineGroup.positions, positionsStart, numPointValues, segmentId, startOffset, endOffset);
        }
    }
    /**
     * Call the `handler` on a polygon feature.
     *
     * @param featureIndex The index of the feature into the feature table.
     * @param handler The `handler` to use.
     */
    visitPolygonFeature(featureIndex, handler) {
        if (handler.acceptPolygon === undefined) {
            return;
        }
        const tileInfo = this.tileInfo;
        const polygons = tileInfo.polygonGroup;
        const numFeatures = polygons.numFeatures;
        const ringStart = polygons.outerRingStartIndex[featureIndex];
        const numRings = featureIndex === numFeatures - 1
            ? polygons.innerRingStartIndex.length - ringStart
            : polygons.outerRingStartIndex[featureIndex + 1] - ringStart;
        // Use a static instance, so we do not allocate anything here
        ExtendedTileInfoVisitor.polygonAccessor.setup(polygons, featureIndex, ringStart, numRings);
        handler.acceptPolygon(polygons.featureIds[featureIndex], polygons.techniqueIndex[featureIndex], polygons.textIndex[featureIndex], this.getTag(featureIndex, polygons.layerIndex), this.getTag(featureIndex, polygons.classIndex), this.getTag(featureIndex, polygons.typeIndex), ExtendedTileInfoVisitor.polygonAccessor);
        // Free all data references.
        ExtendedTileInfoVisitor.polygonAccessor.reset();
    }
}
// static instance to work without allocations.
ExtendedTileInfoVisitor.polygonAccessor = new ExtendedTileInfoPolygonAccessorImpl();
exports.ExtendedTileInfoVisitor = ExtendedTileInfoVisitor;


/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Allows to cancel and prioritize requests inside the requestQueue. Useful to optimize the order of
 * decoding tiles during animations and camera movements.
 *
 * `RequestController` is not extending [[AbortController]], because this is not supported in ES5.
 */
class RequestController {
    /**
     * Creates an instance of `RequestController`.
     *
     * @param {number} priority
     * @param {AbortController} abortController Optional [[AbortController]] used internally, since
     *      [[AbortController]]s should not be subclassed.
     */
    constructor(priority = 0, abortController = new AbortController()) {
        this.priority = priority;
        this.abortController = abortController;
    }
    get signal() {
        return this.abortController.signal;
    }
    /**
     * Invoking this method will set this object's AbortSignal's aborted flag and
     * signal to any observers that the associated activity is to be aborted.
     */
    abort() {
        this.abortController.abort();
    }
}
exports.RequestController = RequestController;
/**
 * Communication protocol with [[ITileDecoder]].
 */
var WorkerDecoderProtocol;
(function (WorkerDecoderProtocol) {
    /**
     * Define possible names of messages exchanged with decoder services within `WebWorker`.
     */
    let DecoderMessageName;
    (function (DecoderMessageName) {
        DecoderMessageName["Configuration"] = "configuration";
    })(DecoderMessageName = WorkerDecoderProtocol.DecoderMessageName || (WorkerDecoderProtocol.DecoderMessageName = {}));
    /**
     * Type guard to check if an object is an instance of `ConfigurationMessage`.
     */
    function isConfigurationMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === DecoderMessageName.Configuration);
    }
    WorkerDecoderProtocol.isConfigurationMessage = isConfigurationMessage;
    /**
     * Define possible names of requests called on decoder services within `WebWorker`.
     */
    let Requests;
    (function (Requests) {
        Requests["DecodeTileRequest"] = "decode-tile-request";
        Requests["TileInfoRequest"] = "tile-info-request";
    })(Requests = WorkerDecoderProtocol.Requests || (WorkerDecoderProtocol.Requests = {}));
    /**
     * Type guard to check if an object is a decoded tile object sent to a worker.
     */
    function isDecodeTileRequest(message) {
        return (message &&
            typeof message.type === "string" &&
            message.type === Requests.DecodeTileRequest);
    }
    WorkerDecoderProtocol.isDecodeTileRequest = isDecodeTileRequest;
    /**
     * Type guard to check if an object is an info tile object sent to a worker.
     */
    function isTileInfoRequest(message) {
        return (message && typeof message.type === "string" && message.type === Requests.TileInfoRequest);
    }
    WorkerDecoderProtocol.isTileInfoRequest = isTileInfoRequest;
})(WorkerDecoderProtocol = exports.WorkerDecoderProtocol || (exports.WorkerDecoderProtocol = {}));


/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Common communication protocol for [[WorkerService]].
 */
var WorkerServiceProtocol;
(function (WorkerServiceProtocol) {
    /**
     * Service id of worker manager ([[WorkerServiceManager]]) used to create/destroy service
     * instances in workers.
     */
    WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID = "worker-service-manager";
    /**
     * Define possible names of messages exchanged with services within `WebWorker`.
     */
    let ServiceMessageName;
    (function (ServiceMessageName) {
        ServiceMessageName["Initialized"] = "initialized";
        ServiceMessageName["Request"] = "request";
        ServiceMessageName["Response"] = "response";
    })(ServiceMessageName = WorkerServiceProtocol.ServiceMessageName || (WorkerServiceProtocol.ServiceMessageName = {}));
    /**
     * Type guard to check if an object is a signal message from worker.
     */
    function isInitializedMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === ServiceMessageName.Initialized);
    }
    WorkerServiceProtocol.isInitializedMessage = isInitializedMessage;
    /**
     * Define possible names of requests called on services within `WebWorker`.
     */
    let Requests;
    (function (Requests) {
        Requests["CreateService"] = "create-service";
        Requests["DestroyService"] = "destroy-service";
    })(Requests = WorkerServiceProtocol.Requests || (WorkerServiceProtocol.Requests = {}));
    /**
     * Type guard to check if an object is a request message sent to a worker.
     */
    function isRequestMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === ServiceMessageName.Request);
    }
    WorkerServiceProtocol.isRequestMessage = isRequestMessage;
    /**
     * Type guard to check if an object is a request message sent to a worker.
     */
    function isResponseMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === ServiceMessageName.Response);
    }
    WorkerServiceProtocol.isResponseMessage = isResponseMessage;
})(WorkerServiceProtocol = exports.WorkerServiceProtocol || (exports.WorkerServiceProtocol = {}));


/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Communication protocol with [[ITiler]].
 */
var WorkerTilerProtocol;
(function (WorkerTilerProtocol) {
    /**
     * Define possible names of requests called on tiler services within `WebWorker`.
     */
    let Requests;
    (function (Requests) {
        Requests["RegisterIndex"] = "register-index";
        Requests["UpdateIndex"] = "update-index";
        Requests["TileRequest"] = "tile-request";
    })(Requests = WorkerTilerProtocol.Requests || (WorkerTilerProtocol.Requests = {}));
    /**
     * Type guard to check if an object is an index registration request sent to a worker.
     */
    function isRegisterIndexRequest(message) {
        return (message && typeof message.type === "string" && message.type === Requests.RegisterIndex);
    }
    WorkerTilerProtocol.isRegisterIndexRequest = isRegisterIndexRequest;
    /**
     * Type guard to check if an object is an update request for the index registration.
     */
    function isUpdateIndexRequest(message) {
        return message && typeof message.type === "string" && message.type === Requests.UpdateIndex;
    }
    WorkerTilerProtocol.isUpdateIndexRequest = isUpdateIndexRequest;
    /**
     * Type guard to check if an object is a tile request sent to a worker.
     */
    function isTileRequest(message) {
        return message && typeof message.type === "string" && message.type === Requests.TileRequest;
    }
    WorkerTilerProtocol.isTileRequest = isTileRequest;
})(WorkerTilerProtocol = exports.WorkerTilerProtocol || (exports.WorkerTilerProtocol = {}));


/***/ }),

/***/ "./node_modules/@here/harp-fetch/index.web.js":
/*!****************************************************!*\
  !*** ./node_modules/@here/harp-fetch/index.web.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),

/***/ "./node_modules/@here/harp-geometry/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@here/harp-geometry/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/OrientedBox3 */ "./node_modules/@here/harp-geometry/lib/OrientedBox3.js"));


/***/ }),

/***/ "./node_modules/@here/harp-geometry/lib/OrientedBox3.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-geometry/lib/OrientedBox3.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const three_1 = __webpack_require__(/*! three */ "three");
class OrientedBox3 {
    /**
     * Creates a new `OrientedBox3`.
     *
     * @hideconstructor
     */
    constructor(position, rotationMatrix, extents) {
        /**
         * The position of the center of this `OrientedBox3`.
         */
        this.position = new three_1.Vector3();
        /**
         * The x-axis of this `OrientedBox3`.
         */
        this.xAxis = new three_1.Vector3(1, 0, 0);
        /**
         * The y-axis of this `OrientedBox3`.
         */
        this.yAxis = new three_1.Vector3(0, 1, 0);
        /**
         * The z-axis of this `OrientedBox3`.
         */
        this.zAxis = new three_1.Vector3(0, 0, 1);
        /**
         * The extents of this `OrientedBox3`.
         */
        this.extents = new three_1.Vector3();
        if (position !== undefined) {
            this.position.copy(position);
        }
        if (rotationMatrix !== undefined) {
            rotationMatrix.extractBasis(this.xAxis, this.yAxis, this.zAxis);
        }
        if (extents !== undefined) {
            this.extents.copy(extents);
        }
    }
    /**
     * Gets the orientation matrix of this `OrientedBox3`.
     * @param matrix The output orientation matrix.
     */
    getRotationMatrix(matrix = new three_1.Matrix4()) {
        return matrix.makeBasis(this.xAxis, this.yAxis, this.zAxis);
    }
    /**
     * Checks intersection with the given `THREE.Frustum` or array of `THREE.Plane`s.
     *
     * @param frustumOrPlanes Frustum or array of planes.
     */
    intersects(frustumOrPlanes) {
        const planes = Array.isArray(frustumOrPlanes)
            ? frustumOrPlanes
            : frustumOrPlanes.planes;
        for (const plane of planes) {
            const r = Math.abs(plane.normal.dot(this.xAxis) * this.extents.x) +
                Math.abs(plane.normal.dot(this.yAxis) * this.extents.y) +
                Math.abs(plane.normal.dot(this.zAxis) * this.extents.z);
            const d = plane.distanceToPoint(this.position);
            if (d + r < 0) {
                return false;
            }
        }
        return true;
    }
}
exports.OrientedBox3 = OrientedBox3;


/***/ }),

/***/ "./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const three_1 = __webpack_require__(/*! three */ "three");
const SubdivisionModifier_1 = __webpack_require__(/*! ./SubdivisionModifier */ "./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js");
const VERTEX_POSITION_CACHE = [new three_1.Vector3(), new three_1.Vector3(), new three_1.Vector3()];
/**
 * The [[SphericalGeometrySubdivisionModifier]] subdivides triangle mesh geometries positioned
 * on the surface of a sphere centered at `(0, 0, 0)`.
 */
class SphericalGeometrySubdivisionModifier extends SubdivisionModifier_1.SubdivisionModifier {
    /**
     * Constructs a new [[SphericalGeometrySubdivisionModifier]].
     *
     * @param angle The maximum angle in radians between two vertices and the origin.
     * @param projection The projection that defines the world space of this geometry.
     */
    constructor(angle, projection = harp_geoutils_1.sphereProjection) {
        super();
        this.angle = angle;
        this.projection = projection;
    }
    shouldSplitTriangle(a, b, c) {
        const aa = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, a, VERTEX_POSITION_CACHE[0]);
        const bb = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, b, VERTEX_POSITION_CACHE[1]);
        const cc = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, c, VERTEX_POSITION_CACHE[2]);
        const alpha = aa.angleTo(bb);
        const beta = bb.angleTo(cc);
        const gamma = cc.angleTo(aa);
        // find the maximum angle
        const m = Math.max(alpha, Math.max(beta, gamma));
        // split the triangle if needed.
        if (m < this.angle) {
            return undefined;
        }
        if (m === alpha) {
            return 0;
        }
        else if (m === beta) {
            return 1;
        }
        else if (m === gamma) {
            return 2;
        }
        throw new Error("failed to split triangle");
    }
}
exports.SphericalGeometrySubdivisionModifier = SphericalGeometrySubdivisionModifier;


/***/ }),

/***/ "./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const three_1 = __webpack_require__(/*! three */ "three");
/**
 * The [[SubdivisionModifier]] subdivides triangle mesh geometries.
 */
class SubdivisionModifier {
    /**
     * Constructs a new [[SubdivisionModifier]].
     */
    constructor() {
        // nothing to do
    }
    /**
     * Subdivides the faces of the given [[THREE.Geometry]].
     *
     * This method modifies (in-place) the vertices and the faces of the geometry.
     * Please note that only the vertex position and their UV coordinates are subdivided.
     * Normals, vertex colors and other attributes are left unmodified.
     *
     * @param geometry The [[THREE.Geometry]] to subdivide.
     */
    modify(geometry) {
        const { vertices, faces: faceWorkList, faceVertexUvs: oldUvs } = geometry;
        // A cache containing the indices of the vertices added
        // when subdiving the faces of the geometry.
        const cache = new Map();
        /**
         * Returns the index of the vertex positioned in the middle
         * of the given vertices.
         */
        function middleVertex(i, j) {
            // build a unique `key` for the pair of indices `(i, j)`.
            const key = `${Math.min(i, j)}_${Math.max(i, j)}`;
            const h = cache.get(key);
            if (h !== undefined) {
                // nothing to do, a vertex in the middle of (i, j) was already created.
                return h;
            }
            // the position of the new vertex.
            const p = new three_1.Vector3();
            p.lerpVectors(vertices[i], vertices[j], 0.5);
            // the index of the new vertex.
            const index = vertices.length;
            vertices.push(p);
            // cache the position of the new vertex.
            cache.set(key, index);
            return index;
        }
        // The resulting triangles.
        const newFaces = [];
        const newFaceVertexUvs = [];
        const uvWorkList = oldUvs[0];
        const hasUvs = oldUvs !== undefined && oldUvs.length > 0 && uvWorkList.length > 0;
        while (true) {
            const face = faceWorkList.shift();
            if (face === undefined) {
                break;
            }
            let uvs;
            if (hasUvs) {
                uvs = uvWorkList.shift();
            }
            const edgeToSplit = this.shouldSplitTriangle(vertices[face.a], vertices[face.b], vertices[face.c]);
            switch (edgeToSplit) {
                case 0: {
                    const d = middleVertex(face.a, face.b);
                    faceWorkList.push(new three_1.Face3(face.a, d, face.c));
                    faceWorkList.push(new three_1.Face3(d, face.b, face.c));
                    if (hasUvs) {
                        const t = new three_1.Vector2().lerpVectors(uvs[0], uvs[1], 0.5);
                        uvWorkList.push([uvs[0], t, uvs[2]], [t, uvs[1], uvs[2]]);
                    }
                    break;
                }
                case 1: {
                    const d = middleVertex(face.b, face.c);
                    faceWorkList.push(new three_1.Face3(face.a, face.b, d));
                    faceWorkList.push(new three_1.Face3(face.a, d, face.c));
                    if (hasUvs) {
                        const t = new three_1.Vector2().lerpVectors(uvs[1], uvs[2], 0.5);
                        uvWorkList.push([uvs[0], uvs[1], t], [uvs[0], t, uvs[2]]);
                    }
                    break;
                }
                case 2: {
                    const d = middleVertex(face.c, face.a);
                    faceWorkList.push(new three_1.Face3(face.a, face.b, d));
                    faceWorkList.push(new three_1.Face3(d, face.b, face.c));
                    if (hasUvs) {
                        const t = new three_1.Vector2().lerpVectors(uvs[2], uvs[0], 0.5);
                        uvWorkList.push([uvs[0], uvs[1], t], [t, uvs[1], uvs[2]]);
                    }
                    break;
                }
                case undefined: {
                    newFaces.push(face);
                    if (hasUvs) {
                        newFaceVertexUvs.push(uvs);
                    }
                    break;
                }
                default:
                    throw new Error("failed to subdivide the given geometry");
            } // switch
        }
        geometry.faces = newFaces;
        geometry.verticesNeedUpdate = true;
        geometry.elementsNeedUpdate = true;
        if (hasUvs) {
            geometry.faceVertexUvs[0] = newFaceVertexUvs;
            geometry.uvsNeedUpdate = true;
        }
        return geometry;
    }
}
exports.SubdivisionModifier = SubdivisionModifier;


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/coordinates/GeoBox */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js"));
__export(__webpack_require__(/*! ./lib/coordinates/GeoCoordinatesLike */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js"));
__export(__webpack_require__(/*! ./lib/coordinates/GeoCoordinates */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js"));
__export(__webpack_require__(/*! ./lib/projection/EarthConstants */ "./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js"));
__export(__webpack_require__(/*! ./lib/projection/EquirectangularProjection */ "./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js"));
__export(__webpack_require__(/*! ./lib/projection/IdentityProjection */ "./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js"));
__export(__webpack_require__(/*! ./lib/projection/Projection */ "./node_modules/@here/harp-geoutils/lib/projection/Projection.js"));
__export(__webpack_require__(/*! ./lib/projection/MercatorProjection */ "./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js"));
__export(__webpack_require__(/*! ./lib/projection/SphereProjection */ "./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js"));
__export(__webpack_require__(/*! ./lib/tiling/FlatTileBoundingBoxGenerator */ "./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js"));
__export(__webpack_require__(/*! ./lib/tiling/HalfQuadTreeSubdivisionScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js"));
__export(__webpack_require__(/*! ./lib/tiling/QuadTreeSubdivisionScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js"));
__export(__webpack_require__(/*! ./lib/tiling/QuadTree */ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js"));
__export(__webpack_require__(/*! ./lib/tiling/SubTiles */ "./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js"));
__export(__webpack_require__(/*! ./lib/tiling/TileKey */ "./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js"));
__export(__webpack_require__(/*! ./lib/tiling/TileKeyUtils */ "./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js"));
__export(__webpack_require__(/*! ./lib/tiling/TileTreeTraverse */ "./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js"));
__export(__webpack_require__(/*! ./lib/tiling/TilingScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js"));
__export(__webpack_require__(/*! ./lib/tiling/HereTilingScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js"));
__export(__webpack_require__(/*! ./lib/tiling/WebMercatorTilingScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js"));
__export(__webpack_require__(/*! ./lib/tiling/MercatorTilingScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js"));
__export(__webpack_require__(/*! ./lib/math/Vector3Like */ "./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js"));
__export(__webpack_require__(/*! ./lib/math/Box3Like */ "./node_modules/@here/harp-geoutils/lib/math/Box3Like.js"));
__export(__webpack_require__(/*! ./lib/math/OrientedBox3Like */ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js"));
__export(__webpack_require__(/*! ./lib/math/MathUtils */ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js"));


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoCoordinates_1 = __webpack_require__(/*! ./GeoCoordinates */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js");
const DEG2RAD = Math.PI / 180;
/**
 * `GeoBox` is used to represent a bounding box in geo coordinates.
 */
class GeoBox {
    /**
     * Constructs a new `GeoBox` with the given geo coordinates.
     *
     * @param southWest The south west position in geo coordinates.
     * @param northEast The north east position in geo coordinates.
     */
    constructor(southWest, northEast) {
        this.southWest = southWest;
        this.northEast = northEast;
    }
    /**
     * Returns a `GeoBox` with the given geo coordinates.
     *
     * @param southWest The south west position in geo coordinates.
     * @param northEast The north east position in geo coordinates.
     */
    static fromCoordinates(southWest, northEast) {
        return new GeoBox(southWest, northEast);
    }
    /**
     * Returns the minimum altitude or `undefined`.
     */
    get minAltitude() {
        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {
            return undefined;
        }
        return Math.min(this.southWest.altitude, this.northEast.altitude);
    }
    /**
     * Returns the maximum altitude or `undefined`.
     */
    get maxAltitude() {
        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {
            return undefined;
        }
        return Math.max(this.southWest.altitude, this.northEast.altitude);
    }
    /**
     * Returns the south latitude in degrees of this `GeoBox`.
     */
    get south() {
        return this.southWest.latitude;
    }
    /**
     * Returns the north altitude in degrees of this `GeoBox`.
     */
    get north() {
        return this.northEast.latitude;
    }
    /**
     * Returns the west longitude in degrees of this `GeoBox`.
     */
    get west() {
        return this.southWest.longitude;
    }
    /**
     * Returns the east longitude in degrees of this `GeoBox`.
     */
    get east() {
        return this.northEast.longitude;
    }
    /**
     * Returns the center of this `GeoBox`.
     */
    get center() {
        const latitude = (this.south + this.north) * 0.5;
        const { west, east } = this;
        const { minAltitude, altitudeSpan } = this;
        let altitude;
        if (minAltitude !== undefined && altitudeSpan !== undefined) {
            altitude = minAltitude + altitudeSpan * 0.5;
        }
        if (west < east) {
            return new GeoCoordinates_1.GeoCoordinates(latitude, (west + east) * 0.5, altitude);
        }
        let longitude = (360 + east + west) * 0.5;
        if (longitude > 360) {
            longitude -= 360;
        }
        return new GeoCoordinates_1.GeoCoordinates(latitude, longitude, altitude);
    }
    /**
     * Returns the latitude span in radians.
     */
    get latitudeSpanInRadians() {
        return this.latitudeSpan * DEG2RAD;
    }
    /**
     * Returns the longitude span in radians.
     */
    get longitudeSpanInRadians() {
        return this.longitudeSpan * DEG2RAD;
    }
    /**
     * Returns the latitude span in degrees.
     */
    get latitudeSpan() {
        return this.north - this.south;
    }
    get altitudeSpan() {
        if (this.maxAltitude === undefined || this.minAltitude === undefined) {
            return undefined;
        }
        return this.maxAltitude - this.minAltitude;
    }
    /**
     * Returns the longitude span in degrees.
     */
    get longitudeSpan() {
        let width = this.northEast.longitude - this.southWest.longitude;
        if (width < 0) {
            width += 360;
        }
        return width;
    }
    /**
     * Returns the latitude span in degrees.
     * @deprecated Use [[latitudeSpan]] instead.
     */
    get latitudeSpanInDegrees() {
        return this.latitudeSpan;
    }
    /**
     * Returns the longitude span in degrees.
     * @deprecated Use [[longitudeSpan]] instead.
     */
    get longitudeSpanInDegrees() {
        return this.longitudeSpan;
    }
    /**
     * Returns `true` if the given geo coordinates are contained in this `GeoBox`.
     *
     * @param point The geo coordinates.
     */
    contains(point) {
        if (point.altitude === undefined ||
            this.minAltitude === undefined ||
            this.maxAltitude === undefined) {
            return this.containsHelper(point);
        }
        const isFlat = this.minAltitude === this.maxAltitude;
        const isSameAltitude = this.minAltitude === point.altitude;
        const isWithinAltitudeRange = this.minAltitude <= point.altitude && this.maxAltitude > point.altitude;
        // If box is flat, we should check the altitude and containment,
        // otherwise we should check also altitude difference where we consider
        // point to be inside if alt is from [m_minAltitude, m_maxAltitude) range!
        if (isFlat ? isSameAltitude : isWithinAltitudeRange) {
            return this.containsHelper(point);
        }
        return false;
    }
    /**
     * Clones this `GeoBox` instance.
     */
    clone() {
        return new GeoBox(this.southWest, this.northEast);
    }
    /**
     * Update the bounding box by considering a given point.
     *
     * @param point The point that may expand the bounding box.
     */
    growToContain(point) {
        this.southWest.latitude = Math.min(this.southWest.latitude, point.latitude);
        this.southWest.longitude = Math.min(this.southWest.longitude, point.longitude);
        this.southWest.altitude =
            this.southWest.altitude !== undefined && point.altitude !== undefined
                ? Math.min(this.southWest.altitude, point.altitude)
                : this.southWest.altitude !== undefined
                    ? this.southWest.altitude
                    : point.altitude !== undefined
                        ? point.altitude
                        : undefined;
        this.northEast.latitude = Math.max(this.northEast.latitude, point.latitude);
        this.northEast.longitude = Math.max(this.northEast.longitude, point.longitude);
        this.northEast.altitude =
            this.northEast.altitude !== undefined && point.altitude !== undefined
                ? Math.max(this.northEast.altitude, point.altitude)
                : this.northEast.altitude !== undefined
                    ? this.northEast.altitude
                    : point.altitude !== undefined
                        ? point.altitude
                        : undefined;
    }
    containsHelper(point) {
        if (point.latitude < this.southWest.latitude || point.latitude >= this.northEast.latitude) {
            return false;
        }
        const { west, east } = this;
        if (east > west) {
            return point.longitude >= west && point.longitude < east;
        }
        return point.longitude > east || point.longitude <= west;
    }
}
exports.GeoBox = GeoBox;


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const RAD2DEG = 180.0 / Math.PI;
const DEG2RAD = Math.PI / 180.0;
/**
 * `GeoCoordinates` is used to represent geo positions.
 */
class GeoCoordinates {
    /**
     * Creates a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude Latitude in degrees.
     * @param longitude Longitude in degrees.
     * @param altitude Altitude in meters.
     */
    constructor(latitude, longitude, altitude) {
        this.latitude = latitude;
        this.longitude = longitude;
        this.altitude = altitude;
    }
    /**
     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude Latitude in degrees.
     * @param longitude Longitude in degrees.
     * @param altitude Altitude in meters.
     */
    static fromDegrees(latitude, longitude, altitude) {
        return new GeoCoordinates(latitude, longitude, altitude);
    }
    /**
     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude Latitude in radians.
     * @param longitude Longitude in radians.
     * @param altitude Altitude in meters.
     */
    static fromRadians(latitude, longitude, altitude) {
        return new GeoCoordinates(latitude * RAD2DEG, longitude * RAD2DEG, altitude);
    }
    /**
     * Returns the latitude in radians.
     */
    get latitudeInRadians() {
        return this.latitude * DEG2RAD;
    }
    /**
     * Returns the longitude in radians.
     */
    get longitudeInRadians() {
        return this.longitude * DEG2RAD;
    }
    /**
     * Returns the latitude in degrees.
     * @deprecated Use the [[latitude]] property instead.
     */
    get latitudeInDegrees() {
        return this.latitude;
    } // compat api
    /**
     * Returns the longitude in degrees.
     * @deprecated Use the [[longitude]] property instead.
     */
    get longitudeInDegrees() {
        return this.longitude;
    } // compat api
    /**
     * Returns `true` if this `GeoCoordinates` is valid; returns `false` otherwise.
     */
    isValid() {
        return !isNaN(this.latitude) && !isNaN(this.longitude);
    }
    /**
     * Returns the normalized `GeoCoordinates`.
     */
    normalized() {
        let { latitude, longitude } = this;
        if (isNaN(latitude) || isNaN(longitude)) {
            return this;
        }
        if (latitude > 90) {
            let wrapped = (latitude + 90) % 360;
            if (wrapped >= 180) {
                longitude += 180;
                wrapped = 360 - wrapped;
            }
            latitude = wrapped - 90;
        }
        if (latitude < -90) {
            let wrapped = (latitude - 90) % 360;
            if (wrapped <= -180) {
                longitude += 180;
                wrapped = -360 - wrapped;
            }
            latitude = wrapped + 90;
        }
        if (longitude < -180 || longitude > 180) {
            const sign = Math.sign(longitude);
            longitude = (((longitude % 360) + 180 * sign) % 360) - 180 * sign;
        }
        if (latitude === this.latitude && longitude === this.longitude) {
            return this;
        }
        return new GeoCoordinates(latitude, longitude, this.altitude);
    }
    /**
     * Returns `true` if this `GeoCoordinates` is equal to the other.
     *
     * @param other GeoCoordinatesLike to compare to.
     */
    equals(other) {
        return (this.latitude === other.latitude &&
            this.longitude === other.longitude &&
            this.altitude === other.altitude);
    }
    /**
     * Copy values from the other.
     *
     * @param other GeoCoordinatesLike to copy all values from.
     */
    copy(other) {
        this.latitude = other.latitude;
        this.longitude = other.longitude;
        this.altitude = other.altitude;
        return this;
    }
    /**
     * Clones this `GeoCoordinates`.
     * @deprecated
     */
    clone() {
        return new GeoCoordinates(this.latitude, this.longitude, this.altitude);
    }
}
exports.GeoCoordinates = GeoCoordinates;


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Type guard to assert that `object` conforms to [[GeoCoordinatesLike]] data interface.
 */
function isGeoCoordinatesLike(object) {
    return (object &&
        typeof object.latitude === "number" &&
        typeof object.longitude === "number" &&
        (typeof object.altitude === "number" || typeof object.altitude === "undefined"));
}
exports.isGeoCoordinatesLike = isGeoCoordinatesLike;


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/Box3Like.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/Box3Like.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns true if the given object implements the [[Box3Like]] interface.
 *
 * @param object A valid object.
 */
function isBox3Like(object) {
    const box3 = object;
    return box3.min !== undefined && box3.max !== undefined;
}
exports.isBox3Like = isBox3Like;


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/MathUtils.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
var MathUtils;
(function (MathUtils) {
    /**
     * Creates a new empty bounding box.
     */
    function newEmptyBox3() {
        return {
            min: { x: Infinity, y: Infinity, z: Infinity },
            max: { x: -Infinity, y: -Infinity, z: -Infinity }
        };
    }
    MathUtils.newEmptyBox3 = newEmptyBox3;
    /**
     * Set the components of the given [Vector3Like] instance.
     *
     * @param x The x component.
     * @param y The y component.
     * @param z The z component.
     * @param v The [Vector3Like]
     */
    function newVector3(x, y, z, v) {
        if (v === undefined) {
            return { x, y, z };
        }
        v.x = x;
        v.y = y;
        v.z = z;
        return v;
    }
    MathUtils.newVector3 = newVector3;
    /**
     * Converts an angle measured in degrees to an equivalent value in radians.
     *
     * @param degrees Value in degrees.
     * @returns Value in radians.
     */
    function degToRad(degrees) {
        return degrees * DEG2RAD;
    }
    MathUtils.degToRad = degToRad;
    /**
     * Converts an angle measured in radians to an equivalent value in degrees.
     *
     * @param degrees Value in radians.
     * @returns Value in degrees.
     */
    function radToDeg(radians) {
        return radians * RAD2DEG;
    }
    MathUtils.radToDeg = radToDeg;
    /**
     * Ensures that input value fits in a given range.
     *
     * @param value The value to be clamped.
     * @param min Minimum value.
     * @param max Maximum value.
     * @returns Clamped value.
     */
    function clamp(value, min, max) {
        return value < min ? min : value > max ? max : value;
    }
    MathUtils.clamp = clamp;
    /**
     * Normalize angle in degrees to range `[0, 360)`.
     *
     * @param a Angle in degrees.
     * @returns Angle in degrees in range `[0, 360)`.
     */
    function normalizeAngleDeg(a) {
        a = a % 360;
        if (a < 0) {
            a = a + 360;
        }
        return a;
    }
    MathUtils.normalizeAngleDeg = normalizeAngleDeg;
    /**
     * Return the minimal delta between angles `a` and `b` given in degrees.
     *
     * Equivalent to `a - b` in coordinate space with exception vector direction can be reversed
     * that if `abs(a-b) > 180` because trip is shorter in 'other' direction.
     *
     * Useful when interpolating between `b` and `a` in angle space.
     *
     * @param a Start angle in degrees.
     * @param b End angle in degrees.
     * @returns Angle that that satisfies condition `a - b - d = 0` in angle space.
     */
    function angleDistanceDeg(a, b) {
        a = normalizeAngleDeg(a);
        b = normalizeAngleDeg(b);
        const d = a - b;
        if (d > 180) {
            return d - 360;
        }
        else if (d <= -180) {
            return d + 360;
        }
        else {
            return d;
        }
    }
    MathUtils.angleDistanceDeg = angleDistanceDeg;
    /**
     * Interpolate linearly between two angles given in degrees.
     *
     * @param p0 Angle from in degrees
     * @param p1 Angle to in degrees
     * @param t Interpolation factor (alpha), in range `0-1`.
     */
    function interpolateAnglesDeg(p0, p1, t) {
        // hand crafted version,
        // see stack for maybe better versions:
        //    https://stackoverflow.com/questions/2708476/rotation-interpolation
        const d = angleDistanceDeg(p1, p0);
        const r = (p0 + d * t) % 360;
        return r;
    }
    MathUtils.interpolateAnglesDeg = interpolateAnglesDeg;
})(MathUtils = exports.MathUtils || (exports.MathUtils = {}));


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns true if the given object implements the interface [[OrientedBox3Like]].
 *
 * @param object The object.
 */
function isOrientedBox3Like(object) {
    const obb = object;
    return (obb.position !== undefined &&
        obb.xAxis !== undefined &&
        obb.yAxis !== undefined &&
        obb.zAxis !== undefined &&
        obb.extents !== undefined);
}
exports.isOrientedBox3Like = isOrientedBox3Like;


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
function isVector3Like(v) {
    return v && typeof v.x === "number" && typeof v.y === "number" && typeof v.z === "number";
}
exports.isVector3Like = isVector3Like;


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
class EarthConstants {
}
/** The equatorial circumference in meters. */
EarthConstants.EQUATORIAL_CIRCUMFERENCE = 40075016.6855784861531768177614;
/** The equatorial radius in meters. */
EarthConstants.EQUATORIAL_RADIUS = 6378137.0;
/** The lowest point on earth (Dead Sea) in meters. */
EarthConstants.MIN_ELEVATION = -433.0;
/** The highest point on earth (Mt. Everest) in meters. */
EarthConstants.MAX_ELEVATION = 8848.0;
exports.EarthConstants = EarthConstants;


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "./node_modules/@here/harp-geoutils/lib/math/Box3Like.js");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js");
const Projection_1 = __webpack_require__(/*! ./Projection */ "./node_modules/@here/harp-geoutils/lib/projection/Projection.js");
const DEG2RAD = Math.PI / 180;
class EquirectangularProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        this.type = Projection_1.ProjectionType.Planar;
    }
    getScaleFactor(_worldPoint) {
        return 1;
    }
    worldExtent(minAltitude, maxAltitude, result) {
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        result.min.x = 0.0;
        result.min.y = 0.0;
        result.min.z = minAltitude;
        result.max.x = this.unitScale;
        result.max.y = this.unitScale / 2;
        result.max.z = maxAltitude;
        return result;
    }
    projectPoint(geoPoint, result) {
        if (result === undefined) {
            /*
             * The following tslint:disable is due to the fact that the [[WorldCoordinates]]
             * might be a concrete class which is not available at runtime.
             * Consider the following example:
             *
             *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);
             *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);
             *
             * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!
             */
            // tslint:disable-next-line:no-object-literal-type-assertion
            result = { x: 0, y: 0, z: 0 };
        }
        result.x =
            (geoPoint.longitude * DEG2RAD + Math.PI) *
                EquirectangularProjection.geoToWorldScale *
                this.unitScale;
        result.y =
            (geoPoint.latitude * DEG2RAD + Math.PI * 0.5) *
                EquirectangularProjection.geoToWorldScale *
                this.unitScale;
        result.z = geoPoint.altitude || 0;
        return result;
    }
    unprojectPoint(worldPoint) {
        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians((worldPoint.y * EquirectangularProjection.worldToGeoScale) / this.unitScale -
            Math.PI * 0.5, (worldPoint.x * EquirectangularProjection.worldToGeoScale) / this.unitScale - Math.PI, worldPoint.z);
        return geoPoint;
    }
    unprojectAltitude(worldPoint) {
        return worldPoint.z;
    }
    projectBox(geoBox, result) {
        const worldCenter = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.center.latitude, geoBox.center.longitude, 0));
        const { latitudeSpanInRadians, longitudeSpanInRadians, altitudeSpan } = geoBox;
        const sizeX = longitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;
        const sizeY = latitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        if (Box3Like_1.isBox3Like(result)) {
            result.min.x = worldCenter.x - sizeX * 0.5 * this.unitScale;
            result.min.y = worldCenter.y - sizeY * 0.5 * this.unitScale;
            result.max.x = worldCenter.x + sizeX * 0.5 * this.unitScale;
            result.max.y = worldCenter.y + sizeY * 0.5 * this.unitScale;
            if (altitudeSpan !== undefined) {
                result.min.z = worldCenter.z - altitudeSpan * 0.5;
                result.max.z = worldCenter.z + altitudeSpan * 0.5;
            }
            else {
                result.min.z = 0;
                result.max.z = 0;
            }
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
            result.position.x = worldCenter.x;
            result.position.y = worldCenter.y;
            result.position.z = worldCenter.z;
            result.extents.x = sizeX * 0.5 * this.unitScale;
            result.extents.y = sizeY * 0.5 * this.unitScale;
            result.extents.z = Math.max(Number.EPSILON, (altitudeSpan || 0) * 0.5);
        }
        return result;
    }
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        return GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
    }
    groundDistance(worldPoint) {
        return worldPoint.z;
    }
    scalePointToSurface(worldPoint) {
        worldPoint.z = 0;
        return worldPoint;
    }
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = 1;
        }
        return normal;
    }
}
EquirectangularProjection.geoToWorldScale = 1.0 / (2.0 * Math.PI);
EquirectangularProjection.worldToGeoScale = (2.0 * Math.PI) / 1.0;
/**
 * Equirectangular [[Projection]] used to convert geo coordinates to unit coordinates and vice
 * versa.
 */
exports.normalizedEquirectangularProjection = new EquirectangularProjection(1);
/**
 * Equirectangular [[Projection]] used to convert geo coordinates to world coordinates and vice
 * versa.
 */
exports.equirectangularProjection = new EquirectangularProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "./node_modules/@here/harp-geoutils/lib/math/Box3Like.js");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js");
const Projection_1 = __webpack_require__(/*! ./Projection */ "./node_modules/@here/harp-geoutils/lib/projection/Projection.js");
const DEG2RAD = Math.PI / 180;
class IdentityProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        this.type = Projection_1.ProjectionType.Planar;
    }
    getScaleFactor(_worldPoint) {
        return 1;
    }
    worldExtent(minAltitude, maxAltitude, result) {
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        result.min.x = -Math.PI;
        result.min.y = -Math.PI * 0.5;
        result.min.z = minAltitude;
        result.max.x = Math.PI;
        result.max.y = Math.PI * 0.5;
        result.max.z = maxAltitude;
        return result;
    }
    projectPoint(geoPoint, result) {
        if (!result) {
            // tslint:disable-next-line:no-object-literal-type-assertion
            result = { x: 0, y: 0, z: 0 };
        }
        result.x = geoPoint.longitude * DEG2RAD;
        result.y = geoPoint.latitude * DEG2RAD;
        result.z = geoPoint.altitude || 0;
        return result;
    }
    unprojectPoint(worldPoint) {
        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(worldPoint.y, worldPoint.x, worldPoint.z);
        return geoPoint;
    }
    unprojectAltitude(worldPoint) {
        return worldPoint.z;
    }
    projectBox(geoBox, result) {
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        const min = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.south, geoBox.west, geoBox.minAltitude));
        const max = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.north, geoBox.east, geoBox.maxAltitude));
        if (Box3Like_1.isBox3Like(result)) {
            result.min.x = min.x;
            result.min.y = min.y;
            result.min.z = min.z;
            result.max.x = max.x;
            result.max.y = max.y;
            result.max.z = max.z;
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
            result.position.x = (min.x + max.x) * 0.5;
            result.position.y = (min.y + max.y) * 0.5;
            result.position.z = (min.z + max.z) * 0.5;
            result.extents.x = (max.x - min.x) * 0.5;
            result.extents.y = (max.y - min.y) * 0.5;
            result.extents.z = Math.max(Number.EPSILON, (max.z - min.z) * 0.5);
        }
        return result;
    }
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        return GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
    }
    groundDistance(worldPoint) {
        return worldPoint.z;
    }
    scalePointToSurface(worldPoint) {
        worldPoint.z = 0;
        return worldPoint;
    }
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = 1;
        }
        return normal;
    }
}
/**
 * Identity [[Projection]] used to convert geo coordinates to unit coordinates and vice versa.
 */
exports.identityProjection = new IdentityProjection(1);


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "./node_modules/@here/harp-geoutils/lib/math/Box3Like.js");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js");
const Projection_1 = __webpack_require__(/*! ./Projection */ "./node_modules/@here/harp-geoutils/lib/projection/Projection.js");
class MercatorProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        this.type = Projection_1.ProjectionType.Planar;
    }
    static clamp(val, min, max) {
        return Math.min(Math.max(min, val), max);
    }
    static latitudeClamp(latitude) {
        return MercatorProjection.clamp(latitude, -MercatorProjection.MAXIMUM_LATITUDE, MercatorProjection.MAXIMUM_LATITUDE);
    }
    static latitudeProject(latitude) {
        return Math.log(Math.tan(Math.PI * 0.25 + latitude * 0.5)) / Math.PI;
    }
    static latitudeClampProject(latitude) {
        return MercatorProjection.latitudeProject(MercatorProjection.latitudeClamp(latitude));
    }
    static unprojectLatitude(y) {
        return 2.0 * Math.atan(Math.exp(Math.PI * y)) - Math.PI * 0.5;
    }
    getScaleFactor(worldPoint) {
        return Math.cosh(2 * Math.PI * (worldPoint.y / this.unitScale - 0.5));
    }
    worldExtent(minAltitude, maxAltitude, result) {
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        result.min.x = 0;
        result.min.y = 0;
        result.min.z = minAltitude;
        result.max.x = this.unitScale;
        result.max.y = this.unitScale;
        result.max.z = maxAltitude;
        return result;
    }
    projectPoint(geoPointLike, result) {
        let geoPoint;
        if (geoPointLike instanceof GeoCoordinates_1.GeoCoordinates) {
            geoPoint = geoPointLike;
        }
        else {
            geoPoint = new GeoCoordinates_1.GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);
        }
        if (!result) {
            // tslint:disable-next-line:no-object-literal-type-assertion
            result = { x: 0, y: 0, z: 0 };
        }
        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;
        result.y =
            (MercatorProjection.latitudeClampProject(geoPoint.latitudeInRadians) * 0.5 + 0.5) *
                this.unitScale;
        result.z = geoPoint.altitude || 0;
        return result;
    }
    unprojectPoint(worldPoint) {
        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(MercatorProjection.unprojectLatitude((worldPoint.y / this.unitScale - 0.5) * 2.0), (worldPoint.x / this.unitScale) * 2 * Math.PI - Math.PI, worldPoint.z);
        return geoPoint;
    }
    unprojectAltitude(worldPoint) {
        return worldPoint.z;
    }
    projectBox(geoBox, result) {
        const worldCenter = this.projectPoint(geoBox.center);
        const worldNorth = (MercatorProjection.latitudeClampProject(geoBox.northEast.latitudeInRadians) * 0.5 +
            0.5) *
            this.unitScale;
        const worldSouth = (MercatorProjection.latitudeClampProject(geoBox.southWest.latitudeInRadians) * 0.5 +
            0.5) *
            this.unitScale;
        const worldYCenter = (worldNorth + worldSouth) * 0.5;
        worldCenter.y = worldYCenter;
        const latitudeSpan = worldNorth - worldSouth;
        const longitudeSpan = (geoBox.longitudeSpan / 360) * this.unitScale;
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        if (Box3Like_1.isBox3Like(result)) {
            result.min.x = worldCenter.x - longitudeSpan * 0.5;
            result.min.y = worldCenter.y - latitudeSpan * 0.5;
            result.max.x = worldCenter.x + longitudeSpan * 0.5;
            result.max.y = worldCenter.y + latitudeSpan * 0.5;
            const altitudeSpan = geoBox.altitudeSpan;
            if (altitudeSpan !== undefined) {
                result.min.z = worldCenter.z - altitudeSpan * 0.5;
                result.max.z = worldCenter.z + altitudeSpan * 0.5;
            }
            else {
                result.min.z = 0;
                result.max.z = 0;
            }
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
            result.position.x = worldCenter.x;
            result.position.y = worldCenter.y;
            result.position.z = worldCenter.z;
            result.extents.x = longitudeSpan * 0.5;
            result.extents.y = latitudeSpan * 0.5;
            result.extents.z = Math.max(Number.EPSILON, (geoBox.altitudeSpan || 0) * 0.5);
        }
        else {
            throw new Error("invalid bounding box");
        }
        return result;
    }
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        const geoBox = GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
        return geoBox;
    }
    groundDistance(worldPoint) {
        return worldPoint.z;
    }
    scalePointToSurface(worldPoint) {
        worldPoint.z = 0;
        return worldPoint;
    }
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = 1;
        }
        return normal;
    }
    reprojectPoint(sourceProjection, worldPos, result) {
        // this implementation of [[reprojectPoint]] supports both
        // [[WebMercatorProjection]] and [[MercatorProjection]]. The only
        // difference betweeen these two variants of WEB Mercator
        // is in the orientation of the Y axis, so we just flip Y coordinates
        // when reprojecting between them.
        if (sourceProjection !== this &&
            (sourceProjection === exports.webMercatorProjection || sourceProjection === exports.mercatorProjection)) {
            if (result === undefined) {
                // tslint:disable-next-line: no-object-literal-type-assertion
                result = {};
            }
            result.x = worldPos.x;
            result.y = this.unitScale - worldPos.y;
            result.z = worldPos.z;
            return result;
        }
        return super.reprojectPoint(sourceProjection, worldPos, result);
    }
}
MercatorProjection.MAXIMUM_LATITUDE = 1.4844222297453323;
class WebMercatorProjection extends MercatorProjection {
    projectPoint(geoPointLike, result) {
        let geoPoint;
        if (geoPointLike instanceof GeoCoordinates_1.GeoCoordinates) {
            geoPoint = geoPointLike;
        }
        else {
            geoPoint = new GeoCoordinates_1.GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);
        }
        /*
         * The following tslint:disable is due to the fact that the [[WorldCoordinates]]
         * might be a concrete class which is not available at runtime.
         * Consider the following example:
         *
         *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);
         *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);
         *
         * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!
         */
        if (!result) {
            // tslint:disable-next-line:no-object-literal-type-assertion
            result = { x: 0, y: 0, z: 0 };
        }
        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;
        const sy = Math.sin(MercatorProjection.latitudeClamp(geoPoint.latitudeInRadians));
        result.y = (0.5 - Math.log((1 + sy) / (1 - sy)) / (4 * Math.PI)) * this.unitScale;
        result.z = geoPoint.altitude || 0;
        return result;
    }
    unprojectPoint(worldPoint) {
        const x = worldPoint.x / this.unitScale - 0.5;
        const y = 0.5 - worldPoint.y / this.unitScale;
        const longitude = 360 * x;
        const latitude = 90 - (360 * Math.atan(Math.exp(-y * 2 * Math.PI))) / Math.PI;
        return new GeoCoordinates_1.GeoCoordinates(latitude, longitude, worldPoint.z);
    }
    projectBox(geoBox, result) {
        const r = super.projectBox(geoBox, result);
        if (OrientedBox3Like_1.isOrientedBox3Like(r)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, r.xAxis);
            MathUtils_1.MathUtils.newVector3(0, -1, 0, r.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, -1, r.zAxis);
        }
        return r;
    }
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        const geoBox = new GeoBox_1.GeoBox(new GeoCoordinates_1.GeoCoordinates(maxGeo.latitude, minGeo.longitude, minGeo.altitude), new GeoCoordinates_1.GeoCoordinates(minGeo.latitude, maxGeo.longitude, maxGeo.altitude));
        return geoBox;
    }
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: -1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = -1;
        }
        return normal;
    }
}
WebMercatorProjection.MAXIMUM_LATITUDE = 1.4844222297453323;
/**
 * Mercator [[Projection]] used to convert geo coordinates to world coordinates and vice versa.
 */
exports.mercatorProjection = new MercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);
/**
 * Web Mercator [[Projection]] used to convert geo coordinates to world coordinates and vice versa.
 */
exports.webMercatorProjection = new WebMercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/Projection.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/Projection.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The type of projection.
 */
var ProjectionType;
(function (ProjectionType) {
    /**
     * A type of [Projection] with zero curvature.
     */
    ProjectionType[ProjectionType["Planar"] = 0] = "Planar";
    /**
     * A spherical [Projection].
     */
    ProjectionType[ProjectionType["Spherical"] = 1] = "Spherical";
})(ProjectionType = exports.ProjectionType || (exports.ProjectionType = {}));
/**
 * `Projection` is used to convert positions from geo coordinates to world coordinates and vice
 * versa.
 */
class Projection {
    /**
     * Constructs the Projection
     *
     * @param unitScale How to transform the projected coordinates to world units.
     */
    constructor(unitScale) {
        this.unitScale = unitScale;
        //Prevent empty constructor error.
    }
    /**
     * Reproject a world position from the given source [[Projection]].
     *
     * @param sourceProjection The source projection.
     * @param worldPos A valid position in the world space defined by the source projection.
     * @param result The resulting position reprojected using this [[Projection]].
     * @hidden
     */
    reprojectPoint(sourceProjection, worldPos, result) {
        if (sourceProjection === this) {
            if (result === undefined) {
                return { x: worldPos.x, y: worldPos.y, z: worldPos.z };
            }
            result.x = worldPos.x;
            result.y = worldPos.y;
            result.z = worldPos.z;
            return result;
        }
        return this.projectPoint(sourceProjection.unprojectPoint(worldPos), result);
    }
}
exports.Projection = Projection;


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "./node_modules/@here/harp-geoutils/lib/math/Box3Like.js");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js");
const MercatorProjection_1 = __webpack_require__(/*! ./MercatorProjection */ "./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js");
const Projection_1 = __webpack_require__(/*! ./Projection */ "./node_modules/@here/harp-geoutils/lib/projection/Projection.js");
/**
 * Transforms the given vector using the provided basis.
 */
function apply(xAxis, yAxis, zAxis, v) {
    const x = xAxis.x * v.x + yAxis.x * v.y + zAxis.x * v.z;
    const y = xAxis.y * v.x + yAxis.y * v.y + zAxis.y * v.z;
    const z = xAxis.z * v.x + yAxis.z * v.y + zAxis.z * v.z;
    v.x = x;
    v.y = y;
    v.z = z;
    return v;
}
/**
 * Returns the quadrants for the given longitude. The quadrant is defined as:
 *  - quadrant(+Math.PI * -1.0) = 0
 *  - quadrant(+Math.PI * -0.5) = 1
 *  - quadrant(+Math.PI *  0.0) = 2
 *  - quadrant(+Math.PI *  0.5) = 3
 *  - quadrant(+Math.PI *  1.0) = 4
 *
 * @param longitude The longitude in radians.
 */
function getLongitudeQuadrant(longitude) {
    const oneOverPI = 1 / Math.PI;
    const quadrantIndex = Math.floor(2 * (longitude * oneOverPI + 1));
    return MathUtils_1.MathUtils.clamp(quadrantIndex, 0, 4);
}
function lengthOfVector3(worldPoint) {
    const d = Math.sqrt(worldPoint.x * worldPoint.x + worldPoint.y * worldPoint.y + worldPoint.z * worldPoint.z);
    return d;
}
/**
 * Creates a Box3 enclosing the geobox.
 *
 * @param geoBox Ghe given geobox
 * @param worldBox The resulting axis aligned bounding box.
 */
function makeBox3(geoBox, worldBox, unitScale) {
    const halfEquatorialRadius = (unitScale + (geoBox.maxAltitude || 0)) * 0.5;
    const minLongitude = MathUtils_1.MathUtils.degToRad(geoBox.west);
    const maxLongitude = MathUtils_1.MathUtils.degToRad(geoBox.east);
    const minLongitudeQuadrant = getLongitudeQuadrant(minLongitude);
    const maxLongitudeQuadrant = getLongitudeQuadrant(maxLongitude);
    let xMin = Math.cos(minLongitude);
    let xMax = xMin;
    let yMin = Math.sin(minLongitude);
    let yMax = yMin;
    for (let quadrantIndex = minLongitudeQuadrant + 1; quadrantIndex <= maxLongitudeQuadrant; quadrantIndex++) {
        // tslint:disable-next-line: no-bitwise
        const x = ((quadrantIndex + 1) & 1) * ((quadrantIndex & 2) - 1);
        xMin = Math.min(x, xMin);
        xMax = Math.max(x, xMax);
        // tslint:disable-next-line: no-bitwise
        const y = (quadrantIndex & 1) * ((quadrantIndex & 2) - 1);
        yMin = Math.min(y, yMin);
        yMax = Math.max(y, yMax);
    }
    const cosMaxLongitude = Math.cos(maxLongitude);
    xMin = Math.min(cosMaxLongitude, xMin);
    xMax = Math.max(cosMaxLongitude, xMax);
    const sinMaxLongitude = Math.sin(maxLongitude);
    yMin = Math.min(sinMaxLongitude, yMin);
    yMax = Math.max(sinMaxLongitude, yMax);
    const xCenter = (xMax + xMin) * halfEquatorialRadius;
    const xExtent = (xMax - xMin) * halfEquatorialRadius;
    const yCenter = (yMax + yMin) * halfEquatorialRadius;
    const yExtent = (yMax - yMin) * halfEquatorialRadius;
    // Calculate Z boundaries.
    const minLatitude = MathUtils_1.MathUtils.degToRad(geoBox.south);
    const maxLatutide = MathUtils_1.MathUtils.degToRad(geoBox.north);
    const zMax = Math.sin(maxLatutide);
    const zMin = Math.sin(minLatitude);
    const zCenter = (zMax + zMin) * halfEquatorialRadius;
    const zExtent = (zMax - zMin) * halfEquatorialRadius;
    worldBox.min.x = xCenter - xExtent;
    worldBox.min.y = yCenter - yExtent;
    worldBox.min.z = zCenter - zExtent;
    worldBox.max.x = xCenter + xExtent;
    worldBox.max.y = yCenter + yExtent;
    worldBox.max.z = zCenter + zExtent;
    return worldBox;
}
/**
 * Computes the spherical projection of the given geo coordinates.
 *
 * @param geoPoint The geo coordinates.
 * @param worldpoint The resulting world coordinates.
 */
function project(geoPoint, worldpoint, unitScale) {
    const radius = unitScale + (geoPoint.altitude || 0);
    const latitude = MathUtils_1.MathUtils.degToRad(geoPoint.latitude);
    const longitude = MathUtils_1.MathUtils.degToRad(geoPoint.longitude);
    const cosLatitude = Math.cos(latitude);
    worldpoint.x = radius * cosLatitude * Math.cos(longitude);
    worldpoint.y = radius * cosLatitude * Math.sin(longitude);
    worldpoint.z = radius * Math.sin(latitude);
    return worldpoint;
}
class SphereProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        this.type = Projection_1.ProjectionType.Spherical;
    }
    worldExtent(_minElevation, maxElevation, result = MathUtils_1.MathUtils.newEmptyBox3()) {
        const radius = this.unitScale + maxElevation;
        result.min.x = -radius;
        result.min.y = -radius;
        result.min.z = -radius;
        result.max.x = radius;
        result.max.y = radius;
        result.max.z = radius;
        return result;
    }
    projectPoint(geoPoint, result = MathUtils_1.MathUtils.newVector3(0, 0, 0)) {
        return project(geoPoint, result, this.unitScale);
    }
    unprojectPoint(point) {
        const parallelRadiusSq = point.x * point.x + point.y * point.y;
        const parallelRadius = Math.sqrt(parallelRadiusSq);
        const v = point.z / parallelRadius;
        if (isNaN(v)) {
            return GeoCoordinates_1.GeoCoordinates.fromRadians(0, 0, -this.unitScale);
        }
        const radius = Math.sqrt(parallelRadiusSq + point.z * point.z);
        return GeoCoordinates_1.GeoCoordinates.fromRadians(Math.atan(v), Math.atan2(point.y, point.x), radius - this.unitScale);
    }
    unprojectAltitude(point) {
        const parallelRadiusSq = point.x * point.x + point.y * point.y + point.z * point.z;
        return Math.sqrt(parallelRadiusSq) - EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS;
    }
    projectBox(geoBox, result = MathUtils_1.MathUtils.newEmptyBox3()) {
        if (Box3Like_1.isBox3Like(result)) {
            return makeBox3(geoBox, result, this.unitScale);
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            if (geoBox.longitudeSpan >= 90) {
                const bounds = makeBox3(geoBox, MathUtils_1.MathUtils.newEmptyBox3(), this.unitScale);
                MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
                MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
                MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
                result.position.x = (bounds.max.x + bounds.min.x) * 0.5;
                result.position.y = (bounds.max.y + bounds.min.y) * 0.5;
                result.position.z = (bounds.max.z + bounds.min.z) * 0.5;
                result.extents.x = (bounds.max.x - bounds.min.x) * 0.5;
                result.extents.y = (bounds.max.y - bounds.min.y) * 0.5;
                result.extents.z = (bounds.max.z - bounds.min.z) * 0.5;
                return result;
            }
            const { south, west, north, east, center: mid } = geoBox;
            const midX = mid.longitude;
            const midY = mid.latitude;
            const cosSouth = Math.cos(MathUtils_1.MathUtils.degToRad(south));
            const sinSouth = Math.sin(MathUtils_1.MathUtils.degToRad(south));
            const cosWest = Math.cos(MathUtils_1.MathUtils.degToRad(west));
            const sinWest = Math.sin(MathUtils_1.MathUtils.degToRad(west));
            const cosNorth = Math.cos(MathUtils_1.MathUtils.degToRad(north));
            const sinNorth = Math.sin(MathUtils_1.MathUtils.degToRad(north));
            const cosEast = Math.cos(MathUtils_1.MathUtils.degToRad(east));
            const sinEast = Math.sin(MathUtils_1.MathUtils.degToRad(east));
            const cosMidX = Math.cos(MathUtils_1.MathUtils.degToRad(midX));
            const sinMidX = Math.sin(MathUtils_1.MathUtils.degToRad(midX));
            const cosMidY = Math.cos(MathUtils_1.MathUtils.degToRad(midY));
            const sinMidY = Math.sin(MathUtils_1.MathUtils.degToRad(midY));
            // Build the orientation of the OBB using the normal vector and its partial derivates.
            // the sperical coordinates of the mid point of the geobox.
            MathUtils_1.MathUtils.newVector3(cosMidX * cosMidY, sinMidX * cosMidY, sinMidY, result.zAxis);
            // the partial derivates of the normal vector.
            MathUtils_1.MathUtils.newVector3(-sinMidX, cosMidX, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(-cosMidX * sinMidY, -sinMidX * sinMidY, cosMidY, result.yAxis);
            let width;
            let minY;
            let maxY;
            if (south >= 0) {
                // abs(dot(southWest - southEast, xAxis))
                width = Math.abs(cosSouth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));
                // dot(south, yAxis)
                minY = cosMidY * sinSouth - sinMidY * cosSouth;
                // dot(northEast, zAxis)
                maxY =
                    cosMidY * sinNorth -
                        sinMidY * cosNorth * (cosMidX * cosEast + sinMidX * sinEast);
            }
            else {
                if (north <= 0) {
                    // abs(dot(northWest - northEast, xAxis))
                    width = Math.abs(cosNorth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));
                    // dot(north, yAxis)
                    maxY = cosMidY * sinNorth - sinMidY * cosNorth;
                }
                else {
                    // abs(dot(west - east, xAxis))
                    width = Math.abs(cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest));
                    // dot(northEast, yAxis)
                    maxY =
                        cosMidY * sinNorth -
                            sinMidY * cosNorth * (sinMidX * sinEast + cosMidX * cosEast);
                }
                // dot(southEast, yAxis)
                minY =
                    cosMidY * sinSouth -
                        sinMidY * cosSouth * (cosMidX * cosEast + sinMidX * sinEast);
            }
            const rMax = (this.unitScale + (geoBox.maxAltitude || 0)) * 0.5;
            const rMin = (this.unitScale + (geoBox.minAltitude || 0)) * 0.5;
            // min(dot(southEast, zAxis), dot(northEast, zAxis))
            const d = cosMidY * (cosMidX * cosEast + sinMidX * sinEast);
            const minZ = Math.min(cosNorth * d + sinNorth * sinMidY, cosSouth * d + sinSouth * sinMidY);
            MathUtils_1.MathUtils.newVector3(width * rMax, (maxY - minY) * rMax, rMax - minZ * rMin, result.extents);
            MathUtils_1.MathUtils.newVector3(0, (minY + maxY) * rMax, rMax + rMax, result.position);
            apply(result.xAxis, result.yAxis, result.zAxis, result.position);
            result.position.x = result.position.x - result.zAxis.x * result.extents.z;
            result.position.y = result.position.y - result.zAxis.y * result.extents.z;
            result.position.z = result.position.z - result.zAxis.z * result.extents.z;
            return result;
        }
        throw new Error("Invalid bounding box");
    }
    unprojectBox(_worldBox) {
        throw new Error("Method not implemented.");
    }
    getScaleFactor(_worldPoint) {
        return 1;
    }
    groundDistance(worldPoint) {
        return lengthOfVector3(worldPoint) - this.unitScale;
    }
    scalePointToSurface(worldPoint) {
        const scale = this.unitScale / (lengthOfVector3(worldPoint) || 1);
        worldPoint.x *= scale;
        worldPoint.y *= scale;
        worldPoint.z *= scale;
        return worldPoint;
    }
    surfaceNormal(worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 0 };
        }
        const scale = 1 / (lengthOfVector3(worldPoint) || 1);
        normal.x = worldPoint.x * scale;
        normal.y = worldPoint.y * scale;
        normal.z = worldPoint.z * scale;
        return normal;
    }
    reprojectPoint(sourceProjection, worldPos, result) {
        if (sourceProjection === MercatorProjection_1.mercatorProjection || sourceProjection === MercatorProjection_1.webMercatorProjection) {
            const { x, y, z } = worldPos;
            const r = this.unitScale;
            const mx = x / r - Math.PI;
            const my = y / r - Math.PI;
            const w = Math.exp(my);
            const d = w * w;
            const gx = (2 * w) / (d + 1);
            const gy = (d - 1) / (d + 1);
            const scale = r + z;
            if (result === undefined) {
                // tslint:disable-next-line: no-object-literal-type-assertion
                result = {};
            }
            result.x = Math.cos(mx) * gx * scale;
            result.y = Math.sin(mx) * gx * scale;
            result.z = gy * scale;
            if (sourceProjection === MercatorProjection_1.webMercatorProjection) {
                result.z = -result.z;
            }
            return result;
        }
        return super.reprojectPoint(sourceProjection, worldPos, result);
    }
}
exports.sphereProjection = new SphereProjection(EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS);


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js");
/**
 * `FlatTileBoundingBoxGenerator` generates bounding boxes in world and geo coordinates for a given
 * TilingScheme.
 */
class FlatTileBoundingBoxGenerator {
    /**
     * Creates a new `FlatTileBoundingBoxGenerator` that can generate bounding boxes for the given
     * TilingScheme.
     *
     * @param tilingScheme The [[TilingScheme]] used to compute bounding boxes.
     * @param minElevation The minimum elevation in meters.
     * @param maxElevation The maximum elevation in meters.
     */
    constructor(tilingScheme, minElevation = 0, maxElevation = 0) {
        this.tilingScheme = tilingScheme;
        this.minElevation = minElevation;
        this.maxElevation = maxElevation;
        this.m_tilingScheme = tilingScheme;
        this.m_worldBox = tilingScheme.projection.worldExtent(minElevation, maxElevation);
        const { min, max } = this.m_worldBox;
        this.m_worldDimensions = { x: max.x - min.x, y: max.y - min.y, z: max.z - min.z };
    }
    /**
     * Returns the [[Projection]] of the [[TilingScheme]].
     */
    get projection() {
        return this.m_tilingScheme.projection;
    }
    /**
     * Returns the [[SubdivisionScheme]] of the [[TilingScheme]].
     */
    get subdivisionScheme() {
        return this.m_tilingScheme.subdivisionScheme;
    }
    /**
     * Returns the bounding box in world coordinates of the given [[TileKey]].
     *
     * Example:
     * ```typescript
     * const worldBounds = new THREE.Box3();
     * generator.getWorldBox(geoBox, worldBounds);
     * console.log(worldBounds.getCenter());
     * ```
     *
     * @param tileKey The TileKey.
     * @param result The optional object used to store the resulting bounding box in world
     * coordinates.
     */
    getWorldBox(tileKey, result) {
        const level = tileKey.level;
        const levelDimensionX = this.subdivisionScheme.getLevelDimensionX(level);
        const levelDimensionY = this.subdivisionScheme.getLevelDimensionY(level);
        const sizeX = this.m_worldDimensions.x / levelDimensionX;
        const sizeY = this.m_worldDimensions.y / levelDimensionY;
        const originX = this.m_worldBox.min.x + sizeX * tileKey.column;
        const originY = this.m_worldBox.min.y + sizeY * tileKey.row;
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        result.min.x = originX;
        result.min.y = originY;
        result.min.z = this.m_worldBox.min.z;
        result.max.x = originX + sizeX;
        result.max.y = originY + sizeY;
        result.max.z = this.m_worldBox.max.z;
        return result;
    }
    /**
     * Returns the bounding box in geo coordinates for the given [[TileKey]].
     *
     * Example:
     * ```typescript
     * const geoBox = generator.getGeoBox(worldBounds);
     * console.log(geoBox.center);
     * ```
     *
     * @param tileKey The [[TileKey]].
     */
    getGeoBox(tileKey) {
        const worldBox = this.getWorldBox(tileKey);
        return this.projection.unprojectBox(worldBox);
    }
}
exports.FlatTileBoundingBoxGenerator = FlatTileBoundingBoxGenerator;


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
class HalfQuadTreeSubdivisionScheme {
    getSubdivisionX() {
        return 2;
    }
    getSubdivisionY(level) {
        return level === 0 ? 1 : 2;
    }
    getLevelDimensionX(level) {
        // tslint:disable-next-line:no-bitwise
        return 1 << level;
    }
    getLevelDimensionY(level) {
        // tslint:disable-next-line:no-bitwise
        return level !== 0 ? 1 << (level - 1) : 1;
    }
}
/**
 * A [[SubdivisionScheme]] used to represent half quadtrees. This particular subdivision scheme is
 * used by the HERE tiling scheme.
 */
exports.halfQuadTreeSubdivisionScheme = new HalfQuadTreeSubdivisionScheme();


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const EquirectangularProjection_1 = __webpack_require__(/*! ../projection/EquirectangularProjection */ "./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js");
const HalfQuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./HalfQuadTreeSubdivisionScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js");
/**
 * [[TilingScheme]] used by most of the data published by HERE.
 *
 * The `hereTilingScheme` features a half quadtree subdivision scheme and an equirectangular
 * projection.
 */
exports.hereTilingScheme = new TilingScheme_1.TilingScheme(HalfQuadTreeSubdivisionScheme_1.halfQuadTreeSubdivisionScheme, EquirectangularProjection_1.normalizedEquirectangularProjection);


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const MercatorProjection_1 = __webpack_require__(/*! ../projection/MercatorProjection */ "./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js");
const QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js");
/**
 * The [[TilingScheme]] used by the HERE web tiles.
 *
 * The `mercatorTilingScheme` features a quadtree subdivision scheme and a Mercator projection.
 */
exports.mercatorTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, MercatorProjection_1.mercatorProjection);


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const TileKey_1 = __webpack_require__(/*! ./TileKey */ "./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js");
/**
 * A class used to represent a quadtree.
 */
class QuadTree {
    /**
     * Constructs a new `QuadTree` for the given [[TilingScheme]].
     *
     * Example:
     * ```typescript
     * const quadTree = new QuadTree(hereTilingScheme);
     * const geoBox = quadTree.getGeoBox(tileKey);
     * console.log(geoBox.center);
     * ```
     *
     * @param tilingScheme The TilingScheme used by this `QuadTree`.
     */
    constructor(tilingScheme) {
        this.tilingScheme = tilingScheme;
    }
    /**
     * Visits this `QuadTree` and invoke the given accept method with the current [[TileKey]] and
     * its bounding box in geo coordinates.
     *
     * Example:
     * ```typescript
     * const geoPos = new GeoCoordinates(latitude, longitude);
     * const quadTree = new QuadTree(hereTilingScheme);
     * quadTree.visit((tileKey, geoBox) => {
     *     if (geoBox.contains(geoPos)) {
     *         console.log("tile", tileKey, "contains", geoPos);
     *         return tileKey.level < 14; // stop visiting the quadtree if the level is >= 14.
     *     }
     *     return false; // stop visiting the quadtree,
     *                   // the tile's geoBox doesn't contain the given coordinates.
     * });
     * ```
     *
     * @param accept A function that takes a [[TileKey]] and its bounding box in geo coordinates and
     * returns `true` if the visit of the `QuadTree` should continue; otherwise `false`.
     */
    visit(accept) {
        this.visitTileKey(TileKey_1.TileKey.fromRowColumnLevel(0, 0, 0), accept);
    }
    /**
     * Visits the subtree starting from the given tile.
     *
     * @param tileKey The root of the subtree that should be visited.
     * @param accept A function that takes a [[TileKey]] and its bounding box in geo coordinates and
     * returns `true` if the visit of the `QuadTree` should continue; otherwise `false`.
     */
    visitTileKey(tileKey, accept) {
        const geoBox = this.tilingScheme.getGeoBox(tileKey);
        if (!accept(tileKey, geoBox)) {
            return;
        }
        for (const subTileKey of this.tilingScheme.getSubTileKeys(tileKey)) {
            this.visitTileKey(subTileKey, accept);
        }
    }
}
exports.QuadTree = QuadTree;


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
class QuadTreeSubdivisionScheme {
    getSubdivisionX() {
        return 2;
    }
    getSubdivisionY() {
        return 2;
    }
    getLevelDimensionX(level) {
        // tslint:disable-next-line:no-bitwise
        return 1 << level;
    }
    getLevelDimensionY(level) {
        // tslint:disable-next-line:no-bitwise
        return 1 << level;
    }
}
/**
 * [[SubdivisionScheme]] representing a quadtree.
 */
exports.quadTreeSubdivisionScheme = new QuadTreeSubdivisionScheme();


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const TileKey_1 = __webpack_require__(/*! ./TileKey */ "./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js");
class SubTiles {
    constructor(tileKey, level, mask) {
        this.m_tileKey = tileKey;
        this.m_level = level;
        // tslint:disable:no-bitwise
        this.m_count = 1 << (level << 1);
        this.m_mask = mask;
        this.m_shift = level > 2 ? (level - 2) << 1 : 0;
        // tslint:enable:no-bitwise
    }
    get length() {
        return this.m_count;
    }
    get level() {
        return this.m_level;
    }
    get tileKey() {
        return this.m_tileKey;
    }
    iterator() {
        return new SubTiles.Iterator(this);
    }
    skip(index) {
        // tslint:disable:no-bitwise
        if (this.m_mask !== ~0) {
            while (index < this.m_count && (this.m_mask & (1 << (index >> this.m_shift))) === 0) {
                ++index;
            }
        }
        // tslint:enable:no-bitwise
        return index;
    }
}
exports.SubTiles = SubTiles;
(function (SubTiles) {
    class Iterator {
        constructor(parent, index = 0) {
            this.m_parent = parent;
            this.m_index = parent.skip(index);
        }
        get value() {
            const parentKey = this.m_parent.tileKey;
            const subLevel = this.m_parent.level;
            return TileKey_1.TileKey.fromRowColumnLevel(
            // tslint:disable:no-bitwise
            (parentKey.row << subLevel) | (this.m_index >> subLevel), (parentKey.column << subLevel) | (this.m_index & ((1 << subLevel) - 1)), parentKey.level + subLevel
            // tslint:enableno-bitwise
            );
        }
        next() {
            this.m_index = this.m_parent.skip(++this.m_index);
        }
    }
    SubTiles.Iterator = Iterator;
})(SubTiles = exports.SubTiles || (exports.SubTiles = {}));


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/** @hidden */
const powerOfTwo = [
    0x1,
    0x2,
    0x4,
    0x8,
    0x10,
    0x20,
    0x40,
    0x80,
    0x100,
    0x200,
    0x400,
    0x800,
    0x1000,
    0x2000,
    0x4000,
    0x8000,
    0x10000,
    0x20000,
    0x40000,
    0x80000,
    0x100000,
    0x200000,
    0x400000,
    0x800000,
    0x1000000,
    0x2000000,
    0x4000000,
    0x8000000,
    0x10000000,
    0x20000000,
    0x40000000,
    0x80000000,
    0x100000000,
    0x200000000,
    0x400000000,
    0x800000000,
    0x1000000000,
    0x2000000000,
    0x4000000000,
    0x8000000000,
    0x10000000000,
    0x20000000000,
    0x40000000000,
    0x80000000000,
    0x100000000000,
    0x200000000000,
    0x400000000000,
    0x800000000000,
    0x1000000000000,
    0x2000000000000,
    0x4000000000000,
    0x8000000000000,
    0x10000000000000 // Math.pow(2, 52), highest bit that can be set correctly.
];
/**
 * The `TileKey` instances are used to address a tile in a quadtree.
 *
 * A tile key is defined by a row, a column, and a level. The tree has a root at level 0, with one
 * single tile. On every level, each tile is divided into four children (therefore the name
 * quadtree).
 *
 * Within each [[level]], any particular tile is addressed with [[row]] and [[column]]. The number
 * of rows and columns in each level is 2 to the power of the level. This means: On level 0, only
 * one tile exists, [[columnsAtLevel]]() and [[rowsAtLevel]]() are both 1. On level 1, 4 tiles
 * exist, in 2 rows and 2 columns. On level 2 we have 16 tiles, in 4 rows and 4 columns. And so on.
 *
 * A tile key is usually created using [[fromRowColumnLevel]]() method.
 *
 * `TileKey` instances are immutable, all members return new instances of `TileKey` and do not
 * modify the original object.
 *
 * Utility functions like [[parent]](), [[changedLevelBy]](), and [[changedLevelTo]]() allow for
 * easy vertical navigation of the tree. The number of available rows and columns in the tile's
 * level is given with [[rowCount]]() and [[columnCount]]().
 *
 * Tile keys can be created from and converted into various alternative formats:
 *
 *  - [[toQuadKey]]() / [[fromQuadKey]]() - string representation 4-based
 *  - [[toHereTile]]() / [[fromHereTile]]() - string representation 10-based
 *  - [[mortonCode]]() / [[fromMortonCode]]() - number representation
 *
 * Note - as JavaScript's number type can hold 53 bits in its mantissa, only levels up to 26 can be
 * represented in the number representation returned by [[mortonCode]]().
 */
class TileKey {
    /**
     * Constructs a new immutable instance of a `TileKey`.
     *
     * For the better readability, [[TileKey.fromRowColumnLevel]] should be preferred.
     *
     * Note - row and column must not be greater than the maximum rows/columns for the given level.
     *
     * @param row Represents the row in the quadtree.
     * @param column Represents the column in the quadtree.
     * @param level Represents the level in the quadtree.
     */
    constructor(row, column, level) {
        this.row = row;
        this.column = column;
        this.level = level;
    }
    /**
     * Creates a tile key.
     *
     * @param row The requested row. Must be less than 2 to the power of level.
     * @param column The requested column. Must be less than 2 to the power of level.
     * @param level The requested level.
     */
    static fromRowColumnLevel(row, column, level) {
        return new TileKey(row, column, level);
    }
    /**
     * Creates a tile key from a quad string.
     *
     * The quad string can be created with [[toQuadKey]].
     *
     * @param quadkey The quadkey to convert.
     * @returns A new instance of `TileKey`.
     */
    static fromQuadKey(quadkey) {
        const level = quadkey.length;
        let row = 0;
        let column = 0;
        // tslint:disable:no-bitwise
        for (let i = 0; i < quadkey.length; ++i) {
            const mask = 1 << i;
            const d = parseInt(quadkey.charAt(level - i - 1), 10);
            if (d & 0x1) {
                column |= mask;
            }
            if (d & 0x2) {
                row |= mask;
            }
        }
        // tslint:enable:no-bitwise
        return TileKey.fromRowColumnLevel(row, column, level);
    }
    /**
     * Creates a tile key from a numeric Morton code representation.
     *
     * You can convert a tile key into a numeric Morton code with [[mortonCode]].
     *
     * @param quadKey64 The Morton code to be converted.
     * @returns A new instance of [[TileKey]].
     */
    static fromMortonCode(quadKey64) {
        let level = 0;
        let row = 0;
        let column = 0;
        let quadKey = quadKey64;
        // tslint:disable:no-bitwise
        while (quadKey > 1) {
            const mask = 1 << level;
            if (quadKey & 0x1) {
                column |= mask;
            }
            if (quadKey & 0x2) {
                row |= mask;
            }
            level++;
            quadKey = (quadKey - (quadKey & 0x3)) / 4;
        }
        // tslint:enable:no-bitwise
        const result = TileKey.fromRowColumnLevel(row, column, level);
        result.m_mortonCode = quadKey64;
        return result;
    }
    /**
     * Creates a tile key from a heretile code string.
     *
     * The string can be created with [[toHereTile]].
     *
     * @param quadkey64 The string representation of the HERE tile key.
     * @returns A new instance of `TileKey`.
     */
    static fromHereTile(quadkey64) {
        const result = TileKey.fromMortonCode(parseInt(quadkey64, 10));
        result.m_hereTile = quadkey64;
        return result;
    }
    /**
     * Returns the number of available columns at a given level.
     *
     * This is 2 to the power of the level.
     *
     * @param level The level for which to return the number of columns.
     * @returns The available columns at the given level.
     */
    static columnsAtLevel(level) {
        return Math.pow(2, level);
    }
    /**
     * Returns the number of available rows at a given level.
     *
     * This is 2 to the power of the level.
     *
     * @param level The level for which to return the number of rows.
     * @returns The available rows at the given level.
     */
    static rowsAtLevel(level) {
        return Math.pow(2, level);
    }
    /**
     * Returns the closest matching `TileKey` in a cartesian coordinate system.
     *
     * @param level The level for the tile key.
     * @param coordX The X coordinate.
     * @param coordY The Y coordinate.
     * @param totalWidth The maximum X coordinate.
     * @param totalHeight The maximum Y coordinate.
     * @returns A new tile key at the given level that includes the given coordinates.
     */
    static atCoords(level, coordX, coordY, totalWidth, totalHeight) {
        return TileKey.fromRowColumnLevel(Math.floor(coordY / (totalHeight / TileKey.rowsAtLevel(level))), Math.floor(coordX / (totalWidth / TileKey.columnsAtLevel(level))), level);
    }
    /**
     * Computes the Morton code of the parent tile key of the given Morton code.
     *
     * Note: The parent key of the root key is the root key itself.
     *
     * @param mortonCode A Morton code, for example, obtained from [[mortonCode]].
     * @returns The Morton code of the parent tile.
     */
    static parentMortonCode(mortonCode) {
        return Math.floor(mortonCode / 4);
    }
    /**
     * Returns a tile key representing the parent of the tile addressed by this tile key.
     *
     * Throws an exception is this tile is already the root.
     */
    parent() {
        if (this.level === 0) {
            throw new Error("Cannot get the parent of the root tile key");
        }
        // tslint:disable-next-line:no-bitwise
        return TileKey.fromRowColumnLevel(this.row >>> 1, this.column >>> 1, this.level - 1);
    }
    /**
     * Returns a new tile key at a level that differs from this tile's level by delta.
     *
     * Equivalent to `changedLevelTo(level() + delta)`.
     *
     * Note - root key is returned if `delta` is smaller than the level of this tile key.
     *
     * @param delta The numeric difference between the current level and the requested level.
     */
    changedLevelBy(delta) {
        const level = Math.max(0, this.level + delta);
        let row = this.row;
        let column = this.column;
        // tslint:disable:no-bitwise
        if (delta >= 0) {
            row <<= delta;
            column <<= delta;
        }
        else {
            row >>>= -delta;
            column >>>= -delta;
        }
        // tslint:enable:no-bitwise
        return TileKey.fromRowColumnLevel(row, column, level);
    }
    /**
     * Returns a new tile key at the requested level.
     *
     * If the requested level is smaller than the tile's level, then the key of an ancestor of this
     * tile is returned. If the requested level is larger than the tile's level, then the key of
     * first child or grandchild of this tile is returned, for example, the child with the lowest
     * row and column number. If the requested level equals this tile's level, then the tile key
     * itself is returned. If the requested level is negative, the root tile key is returned.
     *
     * @param level The requested level.
     */
    changedLevelTo(level) {
        return this.changedLevelBy(level - this.level);
    }
    /**
     * Converts the tile key to a numeric code representation.
     *
     * You can create a tile key from a numeric Morton code with [[fromMortonCode]].
     *
     * Note - only levels <= 26 are supported.
     */
    mortonCode() {
        if (this.m_mortonCode === undefined) {
            let column = this.column;
            let row = this.row;
            // tslint:disable:no-bitwise
            let result = powerOfTwo[this.level << 1];
            for (let i = 0; i < this.level; ++i) {
                if (column & 0x1) {
                    result += powerOfTwo[2 * i];
                }
                if (row & 0x1) {
                    result += powerOfTwo[2 * i + 1];
                }
                column >>>= 1;
                row >>>= 1;
            }
            // tslint:enable:no-bitwise
            this.m_mortonCode = result;
        }
        return this.m_mortonCode;
    }
    /**
     * Converts the tile key into a string for using in REST API calls.
     *
     * The string is a quadkey Morton code representation as a string.
     *
     * You can convert back from a quadkey string with [[fromHereTile]].
     */
    toHereTile() {
        if (this.m_hereTile === undefined) {
            this.m_hereTile = this.mortonCode().toString();
        }
        return this.m_hereTile;
    }
    /**
     * Converts the tile key into a string for using in REST API calls.
     *
     * If the tile is the root tile, the quadkey is '-'. Otherwise the string is a number to the
     * base of 4, but without the leading 1, with the following properties:
     *  1. the number of digits equals the level.
     *  2. removing the last digit gives the parent tile's quadkey string, i.e. appending 0,1,2,3
     *     to a quadkey string gives the tiles's children.
     *
     * You can convert back from a quadkey string with [[fromQuadKey]].
     */
    toQuadKey() {
        let result = "";
        // tslint:disable:no-bitwise
        for (let i = this.level; i > 0; --i) {
            const mask = 1 << (i - 1);
            const col = (this.column & mask) !== 0;
            const row = (this.row & mask) !== 0;
            if (col && row) {
                result += "3";
            }
            else if (row) {
                result += "2";
            }
            else if (col) {
                result += "1";
            }
            else {
                result += "0";
            }
        }
        // tslint:enable:no-bitwise
        return result;
    }
    /**
     * Equality operator.
     *
     * @param qnr The tile key to compare to.
     * @returns `true` if this tile key has identical row, column and level, `false` otherwise.
     */
    equals(qnr) {
        return this.row === qnr.row && this.column === qnr.column && this.level === qnr.level;
    }
    /**
     * Returns the absolute quadkey that is constructed from its sub quadkey.
     *
     * @param sub The sub key.
     * @returns The absolute tile key in the quadtree.
     */
    addedSubKey(sub) {
        const subQuad = TileKey.fromQuadKey(sub.length === 0 ? "-" : sub);
        const child = this.changedLevelBy(subQuad.level);
        return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);
    }
    /**
     * Returns the absolute quadkey that is constructed from its sub HERE tile key.
     *
     * @param sub The sub HERE key.
     * @returns The absolute tile key in the quadtree.
     */
    addedSubHereTile(sub) {
        const subQuad = TileKey.fromHereTile(sub);
        const child = this.changedLevelBy(subQuad.level);
        return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);
    }
    /**
     * Returns a sub quadkey that is relative to its parent.
     *
     * This function can be used to generate sub keys that are relative to a parent that is delta
     * levels up in the quadtree.
     *
     * This function can be used to create shortened keys for quads on lower levels if the parent is
     * known.
     *
     * Note - the sub quadkeys fit in a 16-bit unsigned integer if the `delta` is smaller than 8. If
     * `delta` is smaller than 16, the sub quadkey fits into an unsigned 32-bit integer.
     *
     * Deltas larger than 16 are not supported.
     *
     * @param delta The number of levels relative to its parent quadkey. Must be greater or equal to
     * 0 and smaller than 16.
     * @returns The quadkey relative to its parent that is `delta` levels up the tree.
     */
    getSubHereTile(delta) {
        const key = this.mortonCode();
        // tslint:disable-next-line:no-bitwise
        const msb = 1 << (delta * 2);
        const mask = msb - 1;
        // tslint:disable-next-line:no-bitwise
        const result = (key & mask) | msb;
        return result.toString();
    }
    /**
     * Returns the number of available rows in the tile's [[level]].
     *
     * This is 2 to the power of the level.
     */
    rowCount() {
        return TileKey.rowsAtLevel(this.level);
    }
    /**
     * Returns the number of available columns in the tile's [[level]].
     *
     * This is 2 to the power of the level.
     */
    columnCount() {
        return TileKey.columnsAtLevel(this.level);
    }
}
exports.TileKey = TileKey;


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js");
const TileKey_1 = __webpack_require__(/*! ./TileKey */ "./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js");
class TileKeyUtils {
    static geoCoordinatesToTileKey(tilingScheme, geoPoint, level) {
        const projection = tilingScheme.projection;
        const subdivisionScheme = tilingScheme.subdivisionScheme;
        const worldPoint = projection.projectPoint(geoPoint);
        const cx = subdivisionScheme.getLevelDimensionX(level);
        const cy = subdivisionScheme.getLevelDimensionY(level);
        const { min, max } = projection.worldExtent(0, 0);
        const worldSizeX = max.x - min.x;
        const worldSizeY = max.y - min.y;
        if (worldPoint.x < min.x || worldPoint.x > max.x) {
            return null;
        }
        if (worldPoint.y < min.y || worldPoint.y > max.y) {
            return null;
        }
        const column = Math.min(cx - 1, Math.floor((cx * (worldPoint.x - min.x)) / worldSizeX));
        const row = Math.min(cy - 1, Math.floor((cy * (worldPoint.y - min.y)) / worldSizeY));
        return TileKey_1.TileKey.fromRowColumnLevel(row, column, level);
    }
    static geoRectangleToTileKeys(tilingScheme, geoBox, level) {
        const wrap = (value, lower, upper) => {
            if (value < lower) {
                return upper - ((lower - value) % (upper - lower));
            }
            return lower + ((value - lower) % (upper - lower));
        };
        const clamp = (x, minVal, maxVal) => {
            return Math.min(Math.max(x, minVal), maxVal);
        };
        // Clamp at the poles and wrap around the international date line.
        const southWestLongitude = wrap(geoBox.southWest.longitudeInRadians, -Math.PI, Math.PI);
        const southWestLatitude = clamp(geoBox.southWest.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);
        const northEastLongitude = wrap(geoBox.northEast.longitudeInRadians, -Math.PI, Math.PI);
        const northEastLatitude = clamp(geoBox.northEast.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);
        const minTileKey = TileKeyUtils.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates_1.GeoCoordinates.fromRadians(southWestLatitude, southWestLongitude), level);
        const maxTileKey = TileKeyUtils.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates_1.GeoCoordinates.fromRadians(northEastLatitude, northEastLongitude), level);
        const columnCount = tilingScheme.subdivisionScheme.getLevelDimensionX(level);
        if (!minTileKey || !maxTileKey) {
            throw new Error("Invalid coordinates");
        }
        const minColumn = minTileKey.column;
        let maxColumn = maxTileKey.column;
        // wrap around case
        if (southWestLongitude > northEastLongitude) {
            if (maxColumn !== minColumn) {
                maxColumn += columnCount;
            }
            else {
                // do not duplicate
                maxColumn += columnCount - 1;
            }
        }
        const minRow = Math.min(minTileKey.row, maxTileKey.row);
        const maxRow = Math.max(minTileKey.row, maxTileKey.row);
        const keys = new Array();
        for (let row = minRow; row <= maxRow; ++row) {
            for (let column = minColumn; column <= maxColumn; ++column) {
                keys.push(TileKey_1.TileKey.fromRowColumnLevel(row, column % columnCount, level));
            }
        }
        return keys;
    }
}
exports.TileKeyUtils = TileKeyUtils;


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const SubTiles_1 = __webpack_require__(/*! ./SubTiles */ "./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js");
class TileTreeTraverse {
    constructor(subdivisionScheme) {
        this.m_subdivisionScheme = subdivisionScheme;
    }
    subTiles(tileKey) {
        const subTileCount = this.m_subdivisionScheme.getSubdivisionX(tileKey.level) *
            this.m_subdivisionScheme.getSubdivisionY(tileKey.level);
        // tslint:disable-next-line:no-bitwise
        const subTileMask = ~(~0 << subTileCount);
        const subTiles = new SubTiles_1.SubTiles(tileKey, 1, subTileMask);
        const it = subTiles.iterator();
        const result = new Array();
        // tslint:disable-next-line:prefer-for-of
        for (let i = 0; i < subTiles.length; ++i) {
            result.push(it.value);
            it.next();
        }
        return result;
    }
}
exports.TileTreeTraverse = TileTreeTraverse;


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const FlatTileBoundingBoxGenerator_1 = __webpack_require__(/*! ./FlatTileBoundingBoxGenerator */ "./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js");
const TileKeyUtils_1 = __webpack_require__(/*! ./TileKeyUtils */ "./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js");
const TileTreeTraverse_1 = __webpack_require__(/*! ./TileTreeTraverse */ "./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js");
/**
 * The `TilingScheme` represents how the data is tiled.
 */
class TilingScheme {
    /**
     * Constructs a new `TilingScheme` with the given subdivision scheme and projection.
     *
     * @param subdivisionScheme The subdivision scheme used by this `TilingScheme`.
     * @param projection The projection used by this `TilingScheme`.
     */
    constructor(subdivisionScheme, projection) {
        this.subdivisionScheme = subdivisionScheme;
        this.projection = projection;
        this.boundingBoxGenerator = new FlatTileBoundingBoxGenerator_1.FlatTileBoundingBoxGenerator(this);
        this.tileTreeTraverse = new TileTreeTraverse_1.TileTreeTraverse(subdivisionScheme);
    }
    /**
     * Returns the sub tile keys of the given tile.
     *
     * @param tileKey The [[TileKey]].
     * @returns The list of the sub tile keys.
     */
    getSubTileKeys(tileKey) {
        return this.tileTreeTraverse.subTiles(tileKey);
    }
    /**
     * Gets the [[TileKey]] from the given geo position and level.
     *
     * @param geoPoint The position in geo coordinates.
     * @param level The level of the resulting `TileKey`.
     */
    getTileKey(geoPoint, level) {
        return TileKeyUtils_1.TileKeyUtils.geoCoordinatesToTileKey(this, geoPoint, level);
    }
    /**
     * Gets the list of [[TileKey]]s contained in the given [[GeoBox]].
     *
     * @param geoBox The bounding box in geo coordinates.
     * @param level The level of the resulting `TileKey`.
     */
    getTileKeys(geoBox, level) {
        return TileKeyUtils_1.TileKeyUtils.geoRectangleToTileKeys(this, geoBox, level);
    }
    /**
     * Returns the bounding box in geo coordinates for the given [[TileKey]].
     *
     * @param tileKey The `TileKey`.
     */
    getGeoBox(tileKey) {
        return this.boundingBoxGenerator.getGeoBox(tileKey);
    }
    /**
     * Returns the bounding box in world coordinates.
     *
     * @param tileKey The `TileKey`.
     * @param result The optional object that will contain the resulting bounding box.
     */
    getWorldBox(tileKey, result) {
        return this.boundingBoxGenerator.getWorldBox(tileKey, result);
    }
}
exports.TilingScheme = TilingScheme;


/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const MercatorProjection_1 = __webpack_require__(/*! ../projection/MercatorProjection */ "./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js");
const QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js");
/**
 * A [[TilingScheme]] featuring quadtree subdivision scheme and web Mercator projection.
 */
exports.webMercatorTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, MercatorProjection_1.webMercatorProjection);


/***/ }),

/***/ "./node_modules/@here/harp-lines/index.js":
/*!************************************************!*\
  !*** ./node_modules/@here/harp-lines/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/Lines */ "./node_modules/@here/harp-lines/lib/Lines.js"));
__export(__webpack_require__(/*! ./lib/TriangulateLines */ "./node_modules/@here/harp-lines/lib/TriangulateLines.js"));
__export(__webpack_require__(/*! ./lib/HighPrecisionLines */ "./node_modules/@here/harp-lines/lib/HighPrecisionLines.js"));
__export(__webpack_require__(/*! ./lib/HighPrecisionUtils */ "./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js"));


/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/HighPrecisionLines.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/HighPrecisionLines.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const HighPrecisionUtils_1 = __webpack_require__(/*! ./HighPrecisionUtils */ "./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js");
/**
 * Class used to render high-precision wireframe lines.
 */
class HighPrecisionWireFrameLine extends THREE.Line {
    /**
     * Creates a `HighPrecisionWireFrameLine` object.
     *
     * @param geometry [[BufferGeometry]] used to render this object.
     * @param material [[HighPrecisionLineMaterial]] used to render this object.
     *     instances.
     * @param positions Array of 2D/3D positions.
     * @param color Color of the rendered line.
     * @param opacity Opacity of the rendered line.
     */
    constructor(geometry, material, positions, color, opacity) {
        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);
        if (material === undefined) {
            material = new harp_materials_1.HighPrecisionLineMaterial({
                color: color ? color : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_COLOR,
                opacity: opacity !== undefined ? opacity : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_OPACITY
            });
        }
        this.matrixWorldInverse = new THREE.Matrix4();
        if (positions) {
            this.setPositions(positions);
        }
    }
    get bufferGeometry() {
        return this.geometry;
    }
    get shaderMaterial() {
        return this.material;
    }
    setPositions(positions) {
        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);
    }
    setupForRendering() {
        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
        };
    }
    updateMatrixWorld(force) {
        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
        super.updateMatrixWorld(force);
        if (doUpdateMatrixWorldInverse) {
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        }
    }
}
exports.HighPrecisionWireFrameLine = HighPrecisionWireFrameLine;
/**
 * Class used to render high-precision lines.
 */
class HighPrecisionLine extends THREE.Mesh {
    /**
     * Creates a `HighPrecisionLine` object.
     *
     * @param geometry [[BufferGeometry]] used to render this object.
     * @param material [[HighPrecisionLineMaterial]] used to render this object.
     *     instances.
     * @param positions Array of 2D/3D positions.
     * @param color Color of the rendered line.
     * @param opacity Opacity of the rendered line.
     */
    constructor(geometry, material, positions, color, opacity) {
        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);
        if (material === undefined) {
            material = new harp_materials_1.HighPrecisionLineMaterial({
                color: color ? color : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_COLOR,
                opacity: opacity !== undefined ? opacity : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_OPACITY
            });
        }
        this.matrixWorldInverse = new THREE.Matrix4();
        if (positions) {
            this.setPositions(positions);
        }
    }
    get bufferGeometry() {
        return this.geometry;
    }
    get shaderMaterial() {
        return this.material;
    }
    setPositions(positions) {
        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);
    }
    setupForRendering() {
        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
        };
    }
    updateMatrixWorld(force) {
        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
        super.updateMatrixWorld(force);
        if (doUpdateMatrixWorldInverse) {
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        }
    }
}
exports.HighPrecisionLine = HighPrecisionLine;


/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/HighPrecisionPoints.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/HighPrecisionPoints.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const HighPrecisionUtils_1 = __webpack_require__(/*! ./HighPrecisionUtils */ "./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js");
/**
 * Class used to render high-precision points.
 */
class HighPrecisionPoints extends THREE.Points {
    /**
     * Creates a `HighPrecisionPoints` object.
     *
     * @param geometry [[BufferGeometry]] used to render this object.
     * @param material [[HighPrecisionLineMaterial]] used to render this object.
     *     instances.
     * @param positions Array of 2D/3D positions.
     * @param color Color of the rendered point.
     * @param opacity Opacity of the rendered point.
     */
    constructor(geometry, material, positions, color, opacity) {
        if (material === undefined) {
            material = new harp_materials_1.HighPrecisionPointMaterial({
                color: color ? color : harp_materials_1.HighPrecisionPointMaterial.DEFAULT_COLOR,
                opacity: opacity !== undefined ? opacity : 1
            });
        }
        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);
        this.matrixWorldInverse = new THREE.Matrix4();
        if (positions) {
            this.setPositions(positions);
        }
    }
    get bufferGeometry() {
        return this.geometry;
    }
    /**
     * Clears the [[BufferGeometry]] used to render this point.
     */
    clearGeometry() {
        return (this.geometry = new THREE.BufferGeometry());
    }
    get shaderMaterial() {
        return this.material;
    }
    setPositions(positions) {
        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);
    }
    setupForRendering() {
        if (this.material.isHighPrecisionPointsMaterial &&
            this.dimensionality !== undefined) {
            this.material.setDimensionality(this.dimensionality);
        }
        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
        };
    }
    updateMatrixWorld(force) {
        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
        super.updateMatrixWorld(force);
        if (doUpdateMatrixWorldInverse) {
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        }
    }
}
exports.HighPrecisionPoints = HighPrecisionPoints;


/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const three_1 = __webpack_require__(/*! three */ "three");
const HPL = __webpack_require__(/*! ./HighPrecisionLines */ "./node_modules/@here/harp-lines/lib/HighPrecisionLines.js");
const HPP = __webpack_require__(/*! ./HighPrecisionPoints */ "./node_modules/@here/harp-lines/lib/HighPrecisionPoints.js");
const TriangulateLines_1 = __webpack_require__(/*! ./TriangulateLines */ "./node_modules/@here/harp-lines/lib/TriangulateLines.js");
var HighPrecisionUtils;
(function (HighPrecisionUtils) {
    /**
     * Extract the `float` parts of all vector members, Making this a `Vector3` of `float`.
     * precision.
     *
     * @param v
     */
    function doubleToFloatVec(v) {
        return new three_1.Vector3(Math.fround(v.x), Math.fround(v.y), Math.fround(v.z));
    }
    HighPrecisionUtils.doubleToFloatVec = doubleToFloatVec;
    /**
     * Convert a `Vector3` to `float` (in place!) Returns the minor float vector, which is the
     * difference of the double elements and their float counterparts.
     *
     * @param v Vector3 to convert to float IN-PLACE!
     */
    function makeFloatVec(v) {
        const majorX = Math.fround(v.x);
        const majorY = Math.fround(v.y);
        const majorZ = Math.fround(v.z);
        const minorVec = new three_1.Vector3(v.x - majorX, v.y - majorY, v.z - majorZ);
        v.x = Math.fround(majorX);
        v.y = Math.fround(majorY);
        v.z = Math.fround(majorZ);
        return minorVec;
    }
    HighPrecisionUtils.makeFloatVec = makeFloatVec;
    /**
     * Calculate high-precision camera position used in vertex shader of high-precision materials.
     *
     * @param camera Camera used to get the high-precision position.
     * @param objectInverseWorldMatrix Inverse World Matrix of the rendered [[HighPrecisionObject]].
     */
    function createHighPrecisionCameraPos(camera, objectInverseWorldMatrix) {
        const _projScreenMatrix = new three_1.Matrix4().copy(camera.projectionMatrix);
        const mvp = _projScreenMatrix.multiply(camera.matrixWorldInverse);
        const eyePos = new three_1.Vector3(0, 0, 0).applyMatrix4(objectInverseWorldMatrix);
        // split the double float vector into hi and lo parts
        const eyePosFloat = doubleToFloatVec(eyePos);
        const eyePosLo = doubleToFloatVec(eyePos.sub(eyePosFloat));
        return {
            viewProjection: mvp,
            eyePosHi: eyePosFloat,
            eyePosLo
        };
    }
    HighPrecisionUtils.createHighPrecisionCameraPos = createHighPrecisionCameraPos;
    /**
     * Updates the high-precision uniform data of a material used to render a
     * [[HighPrecisionObject]].
     *
     * @param object [[HighPrecisionObject]] used for rendering.
     * @param camera Camera used to get the high-precision position.
     * @param shaderMaterial Material which uniforms will be updated.
     */
    function updateHpUniforms(object, camera, shaderMaterial) {
        const highPrecisionCameraInfo = createHighPrecisionCameraPos(camera, object.matrixWorldInverse);
        const mvp = highPrecisionCameraInfo.viewProjection;
        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {
            if (shaderMaterial.uniforms &&
                shaderMaterial.uniforms.u_mvp &&
                shaderMaterial.uniforms.u_eyepos &&
                shaderMaterial.uniforms.u_eyepos_lowpart) {
                shaderMaterial.uniforms.u_mvp.value = new Float32Array(mvp.elements);
                shaderMaterial.uniforms.u_eyepos.value = new Float32Array(highPrecisionCameraInfo.eyePosHi.toArray());
                shaderMaterial.uniforms.u_eyepos_lowpart.value = new Float32Array(highPrecisionCameraInfo.eyePosLo.toArray());
            }
            else {
                throw Error("High pecision material has missing uniforms");
            }
        }
        else {
            throw Error("High pecision line has no high precision material");
        }
    }
    HighPrecisionUtils.updateHpUniforms = updateHpUniforms;
    /**
     * Assembles the necessary attribute buffers needed to render [[HighPrecisionObject]].
     *
     * @param positions Array of positions.
     */
    function createAttributes(positions) {
        if (positions.length > 0) {
            const v = positions[0];
            if (v === undefined || v === null) {
                throw Error("Empty element in positions");
            }
            const positionVec = new Array();
            const positionVecLow = new Array();
            const addHPValue = (...values) => {
                for (const value of values) {
                    const major = Math.fround(value);
                    positionVecLow.push(value - major);
                    positionVec.push(major);
                }
            };
            const addHPVector = (vec) => {
                addHPValue(vec.x, vec.y, vec.z);
            };
            const vAny = v;
            if (vAny.z !== undefined) {
                positions.forEach(vec => {
                    addHPVector(vec);
                });
            }
            else {
                if (positionVec.length % 3 !== 0) {
                    throw Error("Positions must be 3D, not 2D");
                }
                positions.forEach((n) => {
                    addHPValue(n);
                });
            }
            return {
                positionHigh: new three_1.Float32BufferAttribute(positionVec, 3),
                positionLow: new three_1.Float32BufferAttribute(positionVecLow, 3)
            };
        }
        else {
            return {
                positionHigh: new three_1.Float32BufferAttribute([], 3),
                positionLow: new three_1.Float32BufferAttribute([], 3)
            };
        }
    }
    HighPrecisionUtils.createAttributes = createAttributes;
    /**
     * Assembles an interleaved buffer containing the position attribute data for a
     * [[HighPrecisionObject]].
     *
     * @param positions Array of positions.
     * @param stride Stride of the elements in the `positions` array.
     * @param positionOffset Offset into the `positions` array.
     */
    function addInterleavedAttributes3(positions, stride, positionOffset = 0) {
        const newPositions = new Array();
        const end = positions.length;
        for (let i = 0; i < end; i += stride) {
            for (let j = 0; j < positionOffset; j++) {
                newPositions.push(positions[i + j]);
            }
            const x = positions[i + positionOffset];
            const y = positions[i + positionOffset + 1];
            const z = positions[i + positionOffset + 2];
            const majorX = Math.fround(x);
            const minorX = x - majorX;
            const majorY = Math.fround(y);
            const minorY = y - majorY;
            const majorZ = Math.fround(z);
            const minorZ = z - majorZ;
            // insert values in interleaved buffer
            newPositions.push(majorX, majorY, majorZ, minorX, minorY, minorZ);
            for (let j = positionOffset + 3; j < stride; j++) {
                newPositions.push(positions[i + j]);
            }
        }
        return newPositions;
    }
    HighPrecisionUtils.addInterleavedAttributes3 = addInterleavedAttributes3;
    /**
     * Adds the high-precision position attribute data to a [[HighPrecisionObject]].
     *
     * @param object [[HighPrecisionObject]] which position attribute will be set.
     * @param positions Array of positions.
     */
    function setPositions(object, positions) {
        const attributes = createAttributes(positions);
        object.bufferGeometry.addAttribute("position", attributes.positionHigh);
        object.bufferGeometry.addAttribute("positionLow", attributes.positionLow);
        return attributes.positionHigh.itemSize;
    }
    HighPrecisionUtils.setPositions = setPositions;
    /**
     * Convert positions from `Array<Vector3>` to `Array<number>`.
     *
     * @param positions Array of positions.
     */
    function convertPositions(positions) {
        if (positions.length <= 0) {
            return { positions: [] };
        }
        const v = positions[0];
        if (v === undefined || v === null) {
            throw Error("Empty element in positions");
        }
        const vAny = v;
        if (vAny.y === undefined && vAny.z === undefined) {
            return { positions: positions };
        }
        const returnPositions = new Array();
        positions.forEach(vec => {
            returnPositions.push(vec.x, vec.y, vec.z);
        });
        return { positions: returnPositions };
    }
    HighPrecisionUtils.convertPositions = convertPositions;
    /**
     * Creates a [[HighPrecisionLine]] or [[HighPrecisionWireFrameLine]] object.
     *
     * @param linePositions Array of 2D/3D positions.
     * @param params Parameters used to configure the created [[HighPrecisionObject]].
     */
    function createLine(linePositions, params) {
        const lineWidth = params.lineWidth !== undefined ? params.lineWidth : 5;
        const addCircles = params.addCircles !== undefined ? params.addCircles : false;
        const wireFrame = params.wireFrame !== undefined ? params.wireFrame : false;
        const positions = [];
        const indices = [];
        TriangulateLines_1.triangulateLine(linePositions, lineWidth, positions, indices, addCircles);
        const hpLineGeometry = new three_1.BufferGeometry();
        const hpPositions = addInterleavedAttributes3(positions, 3);
        const buffer = new three_1.InterleavedBuffer(new Float32Array(hpPositions), 6);
        const positionAttribute = new three_1.InterleavedBufferAttribute(buffer, 3, 0, false);
        const positionLowAttribute = new three_1.InterleavedBufferAttribute(buffer, 3, 3, false);
        hpLineGeometry.addAttribute("position", positionAttribute);
        hpLineGeometry.addAttribute("positionLow", positionLowAttribute);
        hpLineGeometry.setIndex(new three_1.BufferAttribute(new Uint32Array(indices), 1));
        const hpSolidMaterial = new harp_materials_1.HighPrecisionLineMaterial(params);
        const lineObject = wireFrame
            ? new HPL.HighPrecisionWireFrameLine(hpLineGeometry, hpSolidMaterial)
            : new HPL.HighPrecisionLine(hpLineGeometry, hpSolidMaterial);
        lineObject.setupForRendering();
        return lineObject;
    }
    HighPrecisionUtils.createLine = createLine;
    /**
     * Creates a group of [[HighPrecisionPoints]].
     *
     * @param pointPositions Array of 2D/3D positions.
     * @param materialParameters Parameters used to configure the material used to render the
     * created [[HighPrecisionPoints]].
     */
    function createPoints(pointPositions, materialParameters) {
        const indices = [];
        // tslint:disable-next-line:prefer-for-of - pointPositions doesn't have iterable interface
        for (let i = 0; i < pointPositions.length; i++) {
            indices.push(indices.length / 3);
        }
        const hpPointsGeometry = new three_1.BufferGeometry();
        const hpPointsMaterial = harp_materials_1.isHighPrecisionPointMaterial(materialParameters)
            ? materialParameters
            : new harp_materials_1.HighPrecisionPointMaterial(materialParameters);
        const pointsObject = new HPP.HighPrecisionPoints(hpPointsGeometry, hpPointsMaterial);
        setPositions(pointsObject, pointPositions);
        pointsObject.setupForRendering();
        return pointsObject;
    }
    HighPrecisionUtils.createPoints = createPoints;
})(HighPrecisionUtils = exports.HighPrecisionUtils || (exports.HighPrecisionUtils = {}));


/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/Lines.js":
/*!****************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/Lines.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
// Preallocate temp variables used during line generation.
const tmpV = new THREE.Vector3();
const tmpNormal = new THREE.Vector3();
const tmpTangent0 = new THREE.Vector3();
const tmpTangent1 = new THREE.Vector3();
const tmpBitangent = new THREE.Vector3();
const SEGMENT_OFFSET = 0.1;
/**
 * Declares all the vertex attributes used for rendering a line using the [[SolidLineMaterial]].
 */
const LINE_VERTEX_ATTRIBUTES = [
    { name: "texcoord", itemSize: 2, offset: 0 },
    { name: "position", itemSize: 3, offset: 2 },
    { name: "tangent", itemSize: 3, offset: 5 },
    { name: "bitangent", itemSize: 4, offset: 8 }
];
/** Stride size for line vertex data. */
const LINE_STRIDE = 12;
/**
 * Declares all the vertex attributes used for rendering a line using the
 * [[HighPrecisionLineMaterial]].
 */
const HP_LINE_VERTEX_ATTRIBUTES = [
    { name: "texcoord", itemSize: 2, offset: 0 },
    { name: "position", itemSize: 3, offset: 2 },
    { name: "positionLow", itemSize: 3, offset: 5 },
    { name: "tangent", itemSize: 3, offset: 8 },
    { name: "bitangent", itemSize: 4, offset: 11 }
];
/** Stride size for high precision line vertex data. */
const HP_LINE_STRIDE = 15;
/**
 * Class that holds the vertex and index attributes for a [[Lines]] object.
 */
class LineGeometry {
    constructor() {
        this.vertices = [];
        this.vertexColors = [];
        this.indices = [];
    }
}
exports.LineGeometry = LineGeometry;
/**
 * Creates a [[LineGeometry]] object out of a polyline.
 *
 * @param center Center of the polyline.
 * @param polyline Array of `numbers` describing a polyline.
 * @param colors Array of `numbers` describing a polyline's colors.
 * @param geometry [[LineGeometry]] object used to store the vertex and index attributes.
 * @param highPrecision If `true` will create high-precision vertex information.
 */
function createLineGeometry(center, polyline, colors, geometry = new LineGeometry(), highPrecision = false) {
    if (polyline.length === 0) {
        return geometry;
    }
    const stride = highPrecision ? HP_LINE_STRIDE : LINE_STRIDE;
    const pointCount = polyline.length / 3;
    const segments = new Array(pointCount);
    const tangents = new Array(polyline.length - 3);
    const baseVertex = geometry.vertices.length / stride;
    const vertexColors = colors !== undefined && colors.length && polyline.length;
    // Compute segments and tangents.
    let sum = SEGMENT_OFFSET;
    segments[0] = sum;
    let isFlat = true;
    for (let i = 0; i < pointCount - 1; ++i) {
        let sqrLength = 0;
        for (let j = 0; j < 3; ++j) {
            const d = polyline[(i + 1) * 3 + j] - polyline[i * 3 + j];
            tangents[i * 3 + j] = d;
            sqrLength += d * d;
            isFlat = j === 2 ? isFlat && polyline[(i + 1) * 3 + j] === 0.0 : isFlat;
        }
        const len = Math.sqrt(sqrLength);
        sum = sum + len;
        segments[i + 1] = sum;
    }
    // Check if we're working with a closed line.
    let isClosed = true;
    for (let j = 0; j < 3; ++j) {
        isClosed = isClosed && polyline[j] === polyline[polyline.length - 3 + j];
    }
    for (let i = 0; i < pointCount; ++i) {
        // Retrieve the per-point tangents.
        const T1 = isClosed && i === 0 ? tangents.length - 3 : Math.max(0, i - 1) * 3;
        const T2 = isClosed && i === pointCount - 1 ? 0 : Math.min(i * 3, tangents.length - 3);
        // Process v0 and v1.
        if (i > 0) {
            for (let v = -1; v <= 1; v += 2) {
                // Store the segment and texcoord attributes.
                geometry.vertices.push(segments[i - 1], segments[i] * v);
                // Store the position attribute (component-dependant).
                for (let j = 0; j < 3; ++j) {
                    if (!highPrecision) {
                        geometry.vertices.push(polyline[i * 3 + j]);
                    }
                    else {
                        const highComp = Math.fround(polyline[i * 3 + j]);
                        const lowComp = polyline[i * 3 + j] - highComp;
                        geometry.vertices.push(highComp, lowComp);
                    }
                    tmpNormal.setComponent(j, polyline[i * 3 + j]);
                }
                // Store the bitangent attribute (component-dependant).
                for (let j = 0; j < 3; ++j) {
                    tmpTangent0.setComponent(j, tangents[T1 + j]);
                    tmpTangent1.setComponent(j, tangents[T2 + j]);
                }
                geometry.vertices.push(...tmpTangent0.normalize().toArray());
                const angle = computeBitangent(isFlat ? tmpNormal.set(0, 0, 1) : tmpNormal.add(center).normalize(), tmpTangent0.normalize(), tmpTangent1.normalize(), tmpBitangent);
                geometry.vertices.push(...tmpBitangent.toArray(), angle);
                // Add vertex colors (if supplied).
                if (vertexColors) {
                    geometry.vertexColors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                }
            }
        }
        // Process v2 and v3.
        if (i + 1 < pointCount) {
            for (let v = -1; v <= 1; v += 2) {
                // Store the segment and texcoord attributes.
                geometry.vertices.push(segments[Math.min(i, segments.length - 1)] * -1, segments[Math.min(i + 1, segments.length - 1)] * v);
                // Store the position attribute (component-dependant).
                for (let j = 0; j < 3; ++j) {
                    if (!highPrecision) {
                        geometry.vertices.push(polyline[i * 3 + j]);
                    }
                    else {
                        const highComp = Math.fround(polyline[i * 3 + j]);
                        const lowComp = polyline[i * 3 + j] - highComp;
                        geometry.vertices.push(highComp, lowComp);
                    }
                    tmpNormal.setComponent(j, polyline[i * 3 + j]);
                }
                // Store the bitangent attribute (component-dependant).
                for (let j = 0; j < 3; ++j) {
                    tmpTangent0.setComponent(j, tangents[T1 + j]);
                    tmpTangent1.setComponent(j, tangents[T2 + j]);
                }
                geometry.vertices.push(...tmpTangent0.normalize().toArray());
                const angle = computeBitangent(isFlat ? tmpNormal.set(0, 0, 1) : tmpNormal.add(center).normalize(), tmpTangent0.normalize(), tmpTangent1.normalize(), tmpBitangent);
                geometry.vertices.push(...tmpBitangent.toArray(), angle);
                // Add vertex colors (if supplied).
                if (vertexColors) {
                    geometry.vertexColors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                }
            }
        }
    }
    // Store the triangle indices in the final index buffer.
    for (let i = 0; i < pointCount - 1; ++i) {
        const base = baseVertex + i * 4;
        geometry.indices.push(base, base + 1, base + 2, base + 2, base + 1, base + 3);
    }
    return geometry;
}
exports.createLineGeometry = createLineGeometry;
/**
 * Creates a [[LineGeometry]] object out of a polyline.
 *
 * @param polyline Array of `numbers` describing a polyline.
 * @param polyline Array of `numbers` describing a polyline's colors.
 * @param geometry [[LineGeometry]] object used to store the vertex and index attributes.
 */
function createSimpleLineGeometry(polyline, colors, geometry = new LineGeometry()) {
    if (polyline.length === 0) {
        return geometry;
    }
    const pointCount = polyline.length / 3;
    let index = geometry.vertices.length / 3;
    const vertexColors = colors !== undefined && colors.length && polyline.length;
    for (let i = 0; i < pointCount; ++i, index++) {
        if (i > 0) {
            geometry.indices.push(index);
        }
        if (i < pointCount - 1) {
            geometry.indices.push(index);
        }
        for (let j = 0; j < 3; ++j) {
            geometry.vertices.push(polyline[i * 3 + j]);
            if (vertexColors) {
                geometry.vertexColors.push(colors[i * 3 + j]);
            }
        }
    }
    return geometry;
}
exports.createSimpleLineGeometry = createSimpleLineGeometry;
/**
 * Class used to render groups (or batches) of width-variable lines (in the same tile).
 */
class LineGroup {
    constructor(highPrecision = false, isSimple = false) {
        this.highPrecision = highPrecision;
        this.isSimple = isSimple;
        this.m_geometry = new LineGeometry();
    }
    /**
     * Adds all the attribute data needed to a [[BufferGeometry]] object for rendering `Lines`.
     *
     * @param vertices Array of vertex attributes.
     * @param colors Array of vertex colors.
     * @param indices Array of vertex indices.
     * @param geometry [[BufferGeometry]] object which will store all the `Lines` attribute data.
     * @param highPrecision If `true` will create high-precision vertex information.
     * @param isSimple `true` to create simple (nonsolid, nonextruded) lines. Defaults to `false`.
     */
    static createGeometry(vertices, colors, indices, geometry, highPrecision = false, isSimple = false) {
        if (isSimple) {
            geometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(vertices), 3));
            if (colors.length === vertices.length) {
                geometry.addAttribute("color", new THREE.BufferAttribute(new Float32Array(colors), 3));
            }
            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
            return geometry;
        }
        else {
            const stride = highPrecision ? HP_LINE_STRIDE : LINE_STRIDE;
            const descriptors = highPrecision ? HP_LINE_VERTEX_ATTRIBUTES : LINE_VERTEX_ATTRIBUTES;
            const buffer = new THREE.InterleavedBuffer(new Float32Array(vertices), stride);
            descriptors.forEach(descr => {
                const attribute = new THREE.InterleavedBufferAttribute(buffer, descr.itemSize, descr.offset, false);
                geometry.addAttribute(descr.name, attribute);
            });
            if (colors.length === vertices.length) {
                geometry.addAttribute("color", new THREE.BufferAttribute(new Float32Array(colors), 3));
            }
            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
            return geometry;
        }
    }
    /**
     * Clears the list of line strips.
     */
    clear() {
        this.m_geometry.vertices = [];
        this.m_geometry.vertexColors = [];
        this.m_geometry.indices = [];
    }
    /**
     * Add the given points to this line group.
     *
     * @param center World center of the provided points.
     * @param points Sequence of (x,y,z) coordinates.
     * @param colors Sequence of (r,g,b) color components.
     */
    add(center, points, colors) {
        if (!this.isSimple) {
            createLineGeometry(center, points, colors, this.m_geometry, this.highPrecision);
        }
        else {
            createSimpleLineGeometry(points, colors, this.m_geometry);
        }
        return this;
    }
    /**
     * Returns the list of vertices.
     */
    get vertices() {
        return this.m_geometry.vertices;
    }
    /**
     * Returns the list of vertex colors.
     */
    get vertexColors() {
        return this.m_geometry.vertexColors;
    }
    /**
     * Returns the list of indices.
     */
    get indices() {
        return this.m_geometry.indices;
    }
    /**
     * Returns the list of [[VertexAttributeDescriptor]]s.
     */
    get vertexAttributes() {
        return this.highPrecision ? HP_LINE_VERTEX_ATTRIBUTES : LINE_VERTEX_ATTRIBUTES;
    }
    /**
     * Returns the vertex attribute stride.
     */
    get stride() {
        return this.highPrecision ? HP_LINE_STRIDE : LINE_STRIDE;
    }
    /**
     * Creates a three.js geometry.
     */
    createGeometry(geometry) {
        if (geometry === undefined) {
            geometry = new THREE.BufferGeometry();
        }
        return LineGroup.createGeometry(this.m_geometry.vertices, this.m_geometry.vertexColors, this.m_geometry.indices, geometry, this.highPrecision);
    }
}
exports.LineGroup = LineGroup;
function computeBitangent(n, t0, t1, bt) {
    let angle = 0;
    if (!t0.equals(t1)) {
        angle = Math.acos(t0.dot(t1)) * Math.sign(n.dot(tmpV.copy(t0).cross(t1)));
        if (Number.isNaN(angle)) {
            angle = 0;
        }
    }
    bt.copy(t0)
        .add(t1)
        .normalize()
        .cross(n)
        .normalize();
    return angle;
}


/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/TriangulateLines.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/TriangulateLines.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const UNIT_Z = new THREE.Vector3(0, 0, 1);
const POINTS = [0, 1, 2, 1, 3, 2];
const BEVEL_POINTS = [0, 1, 3, 3, 1, 2, 0, 3, 4, 5, 4, 3];
const SECTORS_IN_CIRCLE = 8;
const STEP = Math.PI / SECTORS_IN_CIRCLE;
/**
 * Adds a half-circle geometry to original line
 *
 * @param x The line end X (used as circle center X)
 * @param y The line end Y (used as circle center Y)
 * @param lineAngle The cap incline angle
 * @param radius The cap (circle) radius
 * @param vertices The input vertex buffer (cap vertices are added there)
 * @param indices The input index buffer (cap indices are is added there)
 */
function addCircle(x, y, lineAngle, radius, vertices, indices) {
    const baseVertex = vertices.length / 3;
    // Add cap center to vertices directly (it doesn't need rotation)
    vertices.push(x, y, 0);
    for (let i = 0; i < SECTORS_IN_CIRCLE + 1; ++i) {
        const angle = STEP * i + Math.PI / 2 + lineAngle; // Start angle is -90deg
        vertices.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle), 0);
        indices.push(baseVertex, baseVertex + i + 1, baseVertex + ((i + 1) % (SECTORS_IN_CIRCLE + 1)) + 1);
    }
}
/**
 * Returns the number of points in circle used for caps.
 *
 * @param lineWidth Width of line.
 */
// tslint:disable-next-line:no-unused-variable
function numCirclePoints(lineWidth) {
    return SECTORS_IN_CIRCLE + 1;
}
exports.numCirclePoints = numCirclePoints;
/**
 * Create a triangle mesh from the given polyline.
 *
 * @param points Sequence of (x,y,z) coordinates.
 * @param width The width of the extruded line.
 * @param vertices The output vertex buffer.
 * @param indices The output index buffer.
 * @param startWithCircle `true` if the line should start will a circle.
 * @param endWithCircle `true` if the line should end with a circle.
 */
function triangulateLine(points, width, vertices, indices, startWithCircle = true, endWithCircle = startWithCircle) {
    if (points.length < 3) {
        return;
    }
    // This vector is used for computing cap angle
    const angleVec = new THREE.Vector2();
    if (startWithCircle) {
        // Define lineAngle as (direction - origin) vector angle to X axis
        const lineAngle = points.length !== 3
            ? angleVec.set(points[3] - points[0], points[4] - points[1]).angle()
            : 0;
        addCircle(points[0], points[1], lineAngle, width, vertices, indices);
    }
    const baseVertex = vertices.length / 3;
    // bt = Bitangent (i.e. extrusion vector)
    const prevBt = new THREE.Vector3();
    const p = new THREE.Vector3(); // current point
    const n = new THREE.Vector3(); // next point
    const bt = new THREE.Vector3();
    const averageBt = new THREE.Vector3();
    const p0 = new THREE.Vector3();
    const p1 = new THREE.Vector3();
    const p2 = new THREE.Vector3();
    const p3 = new THREE.Vector3();
    const N = points.length / 3;
    let vertexOffset = 0;
    for (let i = 0; i < N; ++i) {
        let useBevel = false;
        p.set(points[i * 3], points[i * 3 + 1], points[i * 3 + 2]);
        if (i + 1 < N) {
            n.set(points[(i + 1) * 3], points[(i + 1) * 3 + 1], points[(i + 1) * 3 + 2]);
            bt.copy(n)
                .sub(p)
                .normalize()
                .cross(UNIT_Z);
            averageBt.copy(bt);
            if (i > 0) {
                averageBt.add(prevBt).multiplyScalar(1.0 - 0.5 * bt.dot(prevBt));
                useBevel = prevBt.angleTo(bt) > Math.PI / 2;
                if (useBevel) {
                    const inclineWidth = width / Math.cos(bt.angleTo(prevBt) / 2);
                    p0.copy(bt)
                        .add(prevBt)
                        .normalize()
                        .multiplyScalar(-inclineWidth)
                        .add(p);
                    p1.copy(prevBt)
                        .multiplyScalar(width)
                        .add(p);
                    // p2 is used for "miter" connections
                    p2.copy(bt)
                        .add(prevBt)
                        .normalize()
                        .multiplyScalar(inclineWidth)
                        .add(p);
                    p3.copy(bt)
                        .multiplyScalar(width)
                        .add(p);
                }
            }
            if (useBevel) {
                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);
            }
            else {
                p0.copy(averageBt)
                    .multiplyScalar(-width)
                    .add(p);
                p1.copy(averageBt)
                    .multiplyScalar(width)
                    .add(p);
                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
            }
            prevBt.copy(bt);
        }
        else {
            p0.copy(prevBt)
                .multiplyScalar(-width)
                .add(p);
            p1.copy(prevBt)
                .multiplyScalar(width)
                .add(p);
            vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
        }
        if (i !== N - 1) {
            (useBevel ? BEVEL_POINTS : POINTS).forEach(o => indices.push(baseVertex + vertexOffset + o));
            vertexOffset += useBevel ? 4 : 2;
        }
    }
    if (endWithCircle) {
        const lineAngle = points.length !== 2
            ? angleVec
                .set(points[(N - 3) * 3] - points[(N - 2) * 3], points[(N - 3) * 3 + 1] - points[(N - 2) * 3 + 1])
                .angle()
            : Math.PI;
        addCircle(points[(N - 2) * 3], points[(N - 2) * 3 + 1], lineAngle, width, vertices, indices);
    }
}
exports.triangulateLine = triangulateLine;
/**
 * Reconstruct the original points of a line from the vertices of the triangulated line.
 *
 * @param inBuffer Buffer with vertices.
 * @param startOffset Start index, will differ from `0` if the line has caps.
 * @returns Buffer containing the original points of the triangulated line.
 */
function reconstructLine(inBuffer, startOffset) {
    const outBuffer = new Float32Array(inBuffer.length / 2);
    for (let i = startOffset * 3, i2 = i * 2; i < outBuffer.length; i += 3, i2 += 6) {
        outBuffer[i] = inBuffer[i2] + (inBuffer[i2 + 3] - inBuffer[i2]) * 0.5;
        outBuffer[i + 1] = inBuffer[i2 + 1] + (inBuffer[i2 + 3 + 1] - inBuffer[i2 + 1]) * 0.5;
        outBuffer[i + 2] = inBuffer[i2 + 2] + (inBuffer[i2 + 3 + 2] - inBuffer[i2 + 2]) * 0.5;
    }
    return outBuffer;
}
exports.reconstructLine = reconstructLine;
/**
 * Extract the line width from a triangulated line.
 *
 * @param inBuffer Array of vertex elements of a triangulated line.
 * @param startIndex Start index, will differ from `0` if the line has caps.
 */
function reconstructLineWidth(inBuffer, startIndex) {
    const xd = inBuffer[startIndex * 2 + 3] - inBuffer[startIndex * 2];
    const yd = inBuffer[startIndex * 2 + 3 + 1] - inBuffer[startIndex * 2 + 1];
    const zd = inBuffer[startIndex * 2 + 3 + 2] - inBuffer[startIndex * 2 + 2];
    return Math.sqrt(xd * xd + yd * yd + zd * zd) * 0.5;
}
exports.reconstructLineWidth = reconstructLineWidth;


/***/ }),

/***/ "./node_modules/@here/harp-lrucache/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@here/harp-lrucache/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/LRUCache */ "./node_modules/@here/harp-lrucache/lib/LRUCache.js"));


/***/ }),

/***/ "./node_modules/@here/harp-lrucache/lib/LRUCache.js":
/*!**********************************************************!*\
  !*** ./node_modules/@here/harp-lrucache/lib/LRUCache.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
/** @hidden */
class Entry {
    constructor(key, value, size, newer, older) {
        this.key = key;
        this.value = value;
        this.size = size;
        this.newer = newer;
        this.older = older;
    }
}
exports.Entry = Entry;
/**
 * Fixed size cache that evicts its entries in least-recently-used order when it overflows.
 * Modeled after standard JavaScript `Map` otherwise.
 */
class LRUCache {
    /**
     * Creates a new instance of `LRUCache`. The optional sizeFunction can be used
     * fine tune the size required to cache that item.
     *
     * @param cacheCapacity The maximum number of entries to store in the cache.
     * @param sizeFunction A function determining the size per element.
     */
    constructor(cacheCapacity, sizeFunction = () => 1) {
        this.m_size = 0;
        /**
         * The internal map object that keeps the key-value pairs and their order.
         */
        this.m_map = new Map();
        /**
         * The newest entry, i.e. the most recently used item.
         */
        this.m_newest = null;
        /**
         * The oldest entry, i.e. the least recently used item.
         */
        this.m_oldest = null;
        this.m_capacity = cacheCapacity;
        this.m_sizeFunction = sizeFunction;
    }
    /**
     * Iterates over all items from the most recently used item to the least recently used one.
     *
     * **Note**: Results are undefined if the cache is modified during iteration.
     *
     * @param callbackfn The callback to call for each item.
     * @param thisArg Optional this argument for the callback.
     */
    forEach(callbackfn, thisArg) {
        let entry = this.m_newest;
        while (entry !== null) {
            callbackfn.call(thisArg, entry.value, entry.key, this);
            entry = entry.older;
        }
    }
    /**
     * The size of the cache, i.e. the sum of all the sizes of all the objects in the cache.
     *
     * @returns The size of the cache.
     */
    get size() {
        return this.m_size;
    }
    /**
     * Returns the maximum capacity of the cache, i.e. the maximum number of elements this cache can
     * contain.
     *
     * @returns The capacity of the cache.
     */
    get capacity() {
        return this.m_capacity;
    }
    /**
     * @deprecated - DO NOT USE. Will be removed in future versions.
     *
     * Returns the internal map object that keeps the key-value pairs and their order.
     *
     * @returns The internal map object.
     */
    get map() {
        // ### TODO - remove me. Cache must not expose its internal object,
        // modifications to it are fatal for the internal state machine.
        return this.m_map;
    }
    /**
     * Returns the newest entry in the cache.
     *
     * @returns Newest entry in the cache.
     */
    get newest() {
        return this.m_newest;
    }
    /**
     * Returns the oldest entry in the cache.
     *
     * Note: Does not promote the oldest item as most recently used item.
     *
     * @returns Oldest entry in the cache.
     */
    get oldest() {
        return this.m_oldest;
    }
    /**
     * Resets the capacity of this cache. If `newCapacity` is smaller than the current cache size,
     * all items will be evicted until the cache shrinks to `newCapacity`.
     *
     * @param newCapacity The new capacity of this cache.
     */
    setCapacity(newCapacity) {
        this.m_capacity = newCapacity;
        this.evict();
    }
    /**
     * Updates the size of all elements in this cache. If their aggregated size is larger than the
     * capacity, items will be evicted until the cache shrinks to fit the capacity.
     */
    shrinkToCapacity() {
        let size = 0;
        const sizeFunction = this.m_sizeFunction;
        let entry = this.m_newest;
        while (entry !== null) {
            const entrySize = sizeFunction(entry.value);
            entry.size = entrySize;
            size += entrySize;
            entry = entry.older;
        }
        this.m_size = size;
        this.evict();
    }
    /**
     * Inserts or updates a key/value pair in the cache.
     *
     * If the key already existed in the cache, it will be updated and promoted to the most recently
     * used item.
     *
     * If the key didn't exist in the cache, it will be inserted as most recently used item. An
     * eviction of the least recently used item takes place if the cache exceeded its capacity.
     *
     * @param key The key for the key-value pair to insert or update.
     * @param value The value for the key-value pair to insert or update.
     */
    set(key, value) {
        const valueSize = this.m_sizeFunction(value);
        let entry = this.m_map.get(key);
        if (entry !== undefined) {
            this.m_size = this.m_size - entry.size + valueSize;
            entry.value = value;
            entry.size = valueSize;
            this.promote(entry);
            this.evict();
        }
        else {
            if (valueSize > this.m_capacity) {
                return; // single item too big to cache
            }
            entry = new Entry(key, value, valueSize, null, null);
            if (this.m_map.size === 0) {
                this.m_newest = this.m_oldest = entry;
            }
            else {
                harp_utils_1.assert(this.m_newest !== null);
                const newest = this.m_newest;
                entry.older = this.m_newest;
                newest.newer = entry;
                this.m_newest = entry;
            }
            this.m_map.set(key, entry);
            this.m_size += valueSize;
            this.evict();
        }
    }
    /**
     * Looks up key in the cache and returns the associated value.
     *
     * @param key The key to look up.
     * @returns The associated value, or `undefined` if the key-value pair is not in the cache.
     */
    get(key) {
        const entry = this.m_map.get(key);
        if (entry === undefined) {
            return undefined;
        }
        this.promote(entry);
        return entry.value;
    }
    /**
     * Test if a key/value pair is in the cache.
     *
     * @param key The key to look up.
     * @returns `true` if the key-value pair is in the cache, `false` otherwise.
     */
    has(key) {
        return this.m_map.has(key);
    }
    /**
     * Clears the cache and removes all stored key-value pairs.
     *
     * Does not call the eviction callback. Use [[evictAll]] to clear the cache and call the
     * eviction callback.
     */
    clear() {
        this.m_newest = this.m_oldest = null;
        this.m_size = 0;
        this.m_map.clear();
    }
    /**
     * Evicts all items from the cache, calling the eviction callback on each item.
     *
     * Use [[clear]] to remove all items without calling the eviction callback.
     */
    evictAll() {
        const cb = this.evictionCallback;
        if (cb !== undefined) {
            this.forEach((value, key) => cb(key, value));
        }
        this.clear();
    }
    /**
     * Explicitly removes a key-value pair from the cache.
     *
     * **Note**: This is an explicit removal, thus, the eviction callback will not be called.
     *
     * @param key The key of the key-value pair to delete.
     * @returns `true` if the key-value pair existed and was deleted, `false` otherwise.
     */
    delete(key) {
        const entry = this.m_map.get(key);
        if (entry === undefined) {
            return false;
        }
        if (entry === this.m_newest) {
            this.m_newest = entry.older;
        }
        else if (entry.newer) {
            entry.newer.older = entry.older;
        }
        else {
            harp_utils_1.assert(false);
        }
        if (entry === this.m_oldest) {
            this.m_oldest = entry.newer;
        }
        else if (entry.older) {
            entry.older.newer = entry.newer;
        }
        else {
            harp_utils_1.assert(false);
        }
        this.m_size -= entry.size;
        return this.m_map.delete(key);
    }
    evict() {
        while (this.m_oldest !== null && this.m_size > this.m_capacity) {
            const evicted = this.evictOldest();
            if (evicted === undefined) {
                return;
            }
        }
    }
    evictOldest() {
        harp_utils_1.assert(this.m_oldest !== null);
        const oldest = this.m_oldest;
        harp_utils_1.assert(oldest.older === null);
        let itemToRemove = oldest;
        if (this.canEvict !== undefined) {
            while (!this.canEvict(itemToRemove.key, itemToRemove.value)) {
                if (itemToRemove.newer === null) {
                    return undefined;
                }
                itemToRemove = itemToRemove.newer;
            }
        }
        if (itemToRemove === oldest) {
            this.m_oldest = itemToRemove.newer;
            if (itemToRemove.newer !== null) {
                harp_utils_1.assert(itemToRemove.newer.older === itemToRemove);
                itemToRemove.newer.older = null;
            }
        }
        else {
            if (itemToRemove.newer !== null) {
                harp_utils_1.assert(itemToRemove.newer.older === itemToRemove);
                itemToRemove.newer.older = itemToRemove.older;
                if (itemToRemove.older !== null) {
                    itemToRemove.older.newer = itemToRemove.newer;
                }
            }
            else {
                return undefined;
            }
        }
        const isOk = this.m_map.delete(itemToRemove.key);
        harp_utils_1.assert(isOk === true);
        if (isOk && this.evictionCallback !== undefined) {
            this.evictionCallback(itemToRemove.key, itemToRemove.value);
        }
        this.m_size -= itemToRemove.size;
        return itemToRemove;
    }
    promote(entry) {
        if (entry === this.m_newest) {
            return;
        } // already newest, nothing to do
        // re-link newer and older items
        if (entry.newer) {
            harp_utils_1.assert(entry.newer.older === entry);
            entry.newer.older = entry.older;
        }
        if (entry.older) {
            harp_utils_1.assert(entry.older.newer === entry);
            entry.older.newer = entry.newer;
        }
        if (entry === this.m_oldest) {
            this.m_oldest = entry.newer;
        }
        // re-link ourselves
        entry.newer = null;
        entry.older = this.m_newest;
        // finally, set ourselves as the newest entry
        harp_utils_1.assert(this.m_newest !== null);
        const newest = this.m_newest;
        harp_utils_1.assert(newest.newer === null);
        newest.newer = entry;
        this.m_newest = entry;
    }
}
exports.LRUCache = LRUCache;


/***/ }),

/***/ "./node_modules/@here/harp-map-controls/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/MapControls */ "./node_modules/@here/harp-map-controls/lib/MapControls.js"));
__export(__webpack_require__(/*! ./lib/MapControlsUI */ "./node_modules/@here/harp-map-controls/lib/MapControlsUI.js"));
__export(__webpack_require__(/*! ./lib/LongPressHandler */ "./node_modules/@here/harp-map-controls/lib/LongPressHandler.js"));
__export(__webpack_require__(/*! ./lib/Utils */ "./node_modules/@here/harp-map-controls/lib/Utils.js"));
__export(__webpack_require__(/*! ./lib/MapAnimations */ "./node_modules/@here/harp-map-controls/lib/MapAnimations.js"));


/***/ }),

/***/ "./node_modules/@here/harp-map-controls/lib/LongPressHandler.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/lib/LongPressHandler.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class that can be used to track long presses on an HTML Element. A long press is a press that
 * lasts a minimum duration (see the [[timeout]] member) while the mouse is not moved more than a
 * certain threshold (see the [[moveThreshold]] member).
 */
class LongPressHandler {
    /**
     * Default constructor.
     *
     * @param element The HTML element to track.
     * @param onLongPress The callback to call when a long press occurred.
     */
    constructor(element, onLongPress) {
        this.element = element;
        this.onLongPress = onLongPress;
        /**
         * How long to wait (in ms) until a press is considered a long press.
         */
        this.timeout = 500;
        /**
         * If the cursor moves more than the given number of pixels, it is not a long-press, but a pan.
         */
        this.moveThreshold = 5;
        /**
         * Button id that should be handled by this event.
         */
        this.buttonId = 0;
        this.m_mouseDownEvent = undefined;
        this.m_timerId = undefined;
        this.m_moveHandlerRegistered = false;
        // workaround - need to bind 'this' for our dynamic mouse move handler
        this.m_boundMouseMoveHandler = this.onMouseMove.bind(this);
        this.m_boundMouseDownHandler = this.onMousedown.bind(this);
        this.m_boundMouseUpHandler = this.onMouseup.bind(this);
        this.element.addEventListener("mousedown", this.m_boundMouseDownHandler);
        this.element.addEventListener("mouseup", this.m_boundMouseUpHandler);
    }
    /**
     * Removes all events listeners. No more events will be sent.
     */
    dispose() {
        this.cancel();
        this.element.removeEventListener("mousedown", this.m_boundMouseDownHandler);
        this.element.removeEventListener("mouseup", this.m_boundMouseUpHandler);
    }
    onMousedown(event) {
        if (event.button !== this.buttonId) {
            return;
        }
        this.cancelTimer();
        this.m_mouseDownEvent = event;
        this.m_timerId = setTimeout(() => this.onTimeout(), this.timeout);
        this.addMouseMoveHandler();
    }
    onMouseup(event) {
        if (event.button !== this.buttonId) {
            return;
        }
        this.cancel();
    }
    onMouseMove(event) {
        if (this.m_mouseDownEvent === undefined) {
            return; // Must not happen
        }
        const manhattanLength = Math.abs(event.clientX - this.m_mouseDownEvent.clientX) +
            Math.abs(event.clientY - this.m_mouseDownEvent.clientY);
        if (manhattanLength >= this.moveThreshold) {
            this.cancel();
        }
    }
    cancel() {
        this.m_mouseDownEvent = undefined;
        this.cancelTimer();
        this.removeMouseMoveHandler();
    }
    cancelTimer() {
        if (this.m_timerId === undefined) {
            return;
        }
        clearTimeout(this.m_timerId);
        this.m_timerId = undefined;
    }
    addMouseMoveHandler() {
        if (this.m_moveHandlerRegistered) {
            return;
        }
        this.element.addEventListener("mousemove", this.m_boundMouseMoveHandler);
        this.m_moveHandlerRegistered = true;
    }
    removeMouseMoveHandler() {
        if (!this.m_moveHandlerRegistered) {
            return;
        }
        this.element.removeEventListener("mousemove", this.m_boundMouseMoveHandler);
        this.m_moveHandlerRegistered = false;
    }
    onTimeout() {
        const event = this.m_mouseDownEvent;
        this.m_timerId = undefined;
        this.cancel();
        if (event !== undefined) {
            this.onLongPress(event);
        }
    }
}
exports.LongPressHandler = LongPressHandler;


/***/ }),

/***/ "./node_modules/@here/harp-map-controls/lib/MapAnimations.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/lib/MapAnimations.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const MapControls_1 = __webpack_require__(/*! ./MapControls */ "./node_modules/@here/harp-map-controls/lib/MapControls.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const TWEEN = __webpack_require__(/*! @tweenjs/tween.js */ "./node_modules/@tweenjs/tween.js/src/Tween.js");
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Functions used for specifying animations' speed.
 */
var EasingFunction;
(function (EasingFunction) {
    EasingFunction[EasingFunction["Linear"] = 0] = "Linear";
    EasingFunction[EasingFunction["QuadraticIn"] = 1] = "QuadraticIn";
    EasingFunction[EasingFunction["QuadraticOut"] = 2] = "QuadraticOut";
    EasingFunction[EasingFunction["QuadraticInOut"] = 3] = "QuadraticInOut";
    EasingFunction[EasingFunction["CubicIn"] = 4] = "CubicIn";
    EasingFunction[EasingFunction["CubicOut"] = 5] = "CubicOut";
    EasingFunction[EasingFunction["CubicInOut"] = 6] = "CubicInOut";
    EasingFunction[EasingFunction["QuarticIn"] = 7] = "QuarticIn";
    EasingFunction[EasingFunction["QuarticOut"] = 8] = "QuarticOut";
    EasingFunction[EasingFunction["QuarticInOut"] = 9] = "QuarticInOut";
    EasingFunction[EasingFunction["QuinticIn"] = 10] = "QuinticIn";
    EasingFunction[EasingFunction["QuinticOut"] = 11] = "QuinticOut";
    EasingFunction[EasingFunction["QuinticInOut"] = 12] = "QuinticInOut";
    EasingFunction[EasingFunction["SinusoidalIn"] = 13] = "SinusoidalIn";
    EasingFunction[EasingFunction["SinusoidalOut"] = 14] = "SinusoidalOut";
    EasingFunction[EasingFunction["SinusoidalInOut"] = 15] = "SinusoidalInOut";
    EasingFunction[EasingFunction["ExponentialIn"] = 16] = "ExponentialIn";
    EasingFunction[EasingFunction["ExponentialOut"] = 17] = "ExponentialOut";
    EasingFunction[EasingFunction["ExponentialInOut"] = 18] = "ExponentialInOut";
    EasingFunction[EasingFunction["CircularIn"] = 19] = "CircularIn";
    EasingFunction[EasingFunction["CircularOut"] = 20] = "CircularOut";
    EasingFunction[EasingFunction["CircularInOut"] = 21] = "CircularInOut";
    EasingFunction[EasingFunction["ElasticIn"] = 22] = "ElasticIn";
    EasingFunction[EasingFunction["ElasticOut"] = 23] = "ElasticOut";
    EasingFunction[EasingFunction["ElasticInOut"] = 24] = "ElasticInOut";
    EasingFunction[EasingFunction["BackIn"] = 25] = "BackIn";
    EasingFunction[EasingFunction["BackOut"] = 26] = "BackOut";
    EasingFunction[EasingFunction["BackInOut"] = 27] = "BackInOut";
    EasingFunction[EasingFunction["BounceIn"] = 28] = "BounceIn";
    EasingFunction[EasingFunction["BounceOut"] = 29] = "BounceOut";
    EasingFunction[EasingFunction["BounceInOut"] = 30] = "BounceInOut";
})(EasingFunction = exports.EasingFunction || (exports.EasingFunction = {}));
/**
 * Functions used to generate intermediate animation values.
 */
var InterpolationFunction;
(function (InterpolationFunction) {
    InterpolationFunction[InterpolationFunction["Linear"] = 0] = "Linear";
    InterpolationFunction[InterpolationFunction["Bezier"] = 1] = "Bezier";
    InterpolationFunction[InterpolationFunction["CatmullRom"] = 2] = "CatmullRom";
})(InterpolationFunction = exports.InterpolationFunction || (exports.InterpolationFunction = {}));
/**
 * Abstract class used as base to define camera animations.
 */
class CameraAnimation {
    /**
     * Creates a new `CameraAnimation` object.
     *
     * @param mapView [[MapView]] which will be affected by the animation.
     * @param name Animation's name.
     */
    constructor(mapView, name) {
        this.mapView = mapView;
        this.name = name;
        /**
         * `True` if animation is being played.
         */
        this.running = false;
        /**
         * `True` if the animation has been interrupted.
         */
        this.stopped = false;
        /**
         * Duration of a whole animation in milliseconds. Defaults to `10` seconds.
         */
        this.duration = 10000;
        /**
         * Number of times the animation should be repeated. Defaults to `0`.
         */
        this.repeat = 0;
        /**
         * Easing function that control acceleration. Defaults to [[EasingFunction.Linear]].
         */
        this.easing = TWEEN.Easing.Linear.None;
        checkSetupTween();
    }
    /**
     * Update function is to be called before the next frame is rendered.
     */
    update(time) {
        if (this.tween) {
            return this.tween.update(time || harp_utils_1.PerformanceTimer.now());
        }
        return false;
    }
    /**
     * Returns `true` if the animation is being played.
     */
    get isRunning() {
        return this.running;
    }
}
exports.CameraAnimation = CameraAnimation;
/**
 * Create an animation around the Z-axis of the camera.
 */
class CameraRotationAnimation extends CameraAnimation {
    /**
     * Creates a new `CameraRotationAnimation` object.
     *
     * @param mapView [[MapView]] which will be affected by the animation.
     * @param m_mapControls [[MapControls]] this animation will be taking control of.
     * @param options Animation's options.
     * @param name Animation's name.
     */
    constructor(mapView, m_mapControls, options, name) {
        super(mapView, name);
        this.m_mapControls = m_mapControls;
        /**
         * Initial camera rotation (in the Z-axis).
         */
        this.startAngle = 0;
        /**
         * Final camera rotation (in the Z-axis).
         */
        this.endAngle = 360;
        // tslint:disable-next-line:no-unused-variable
        this.m_axis = new THREE.Vector3(0, 0, 1);
        this.beginInteractionListener = () => {
            if (!this.stopped) {
                this.stopTween();
            }
        };
        this.endInteractionListener = () => {
            if (!this.stopped) {
                this.startTween();
            }
        };
        if (options.axis !== undefined) {
            this.m_axis = options.axis;
        }
        if (options.startAngle !== undefined) {
            this.startAngle = options.startAngle;
        }
        if (options.endAngle !== undefined) {
            this.endAngle = options.endAngle;
        }
        if (options.duration !== undefined) {
            this.duration = options.duration;
        }
        if (options.repeat !== undefined) {
            this.repeat = options.repeat;
        }
        if (options.easing !== undefined) {
            this.easing =
                typeof options.easing === "function"
                    ? options.easing
                    : easingMap.get(options.easing) || TWEEN.Easing.Linear.None;
        }
        this.m_lastRotationValue = this.startAngle;
    }
    /**
     * Start the animation.
     *
     * @param time Duration of the animation in milliseconds.
     * @param onFinished Callback that gets triggered once the animation ends.
     */
    start(time, onFinished) {
        if (this.running) {
            throw new Error("Animation already running" + this.name !== undefined ? this.name : "");
        }
        this.running = true;
        this.onFinished = onFinished;
        this.stopped = false;
        if (this.m_mapControls) {
            this.m_mapControls.addEventListener(MapControls_1.EventNames.BeginInteraction, this.beginInteractionListener);
            this.m_mapControls.addEventListener(MapControls_1.EventNames.EndInteraction, this.endInteractionListener);
        }
        this.startTween(time);
        this.mapView.beginAnimation();
    }
    /**
     * Stop the animation. Can be started again (with original values only, though).
     */
    stop() {
        if (!this.running) {
            throw new Error("Animation not running" + this.name !== undefined ? this.name : "");
        }
        this.running = false;
        this.stopped = true;
        this.mapView.endAnimation();
        if (this.tween) {
            this.tween.stop();
        }
        if (this.m_mapControls) {
            this.m_mapControls.removeEventListener(MapControls_1.EventNames.BeginInteraction, this.beginInteractionListener);
            this.m_mapControls.removeEventListener(MapControls_1.EventNames.EndInteraction, this.endInteractionListener);
        }
    }
    /**
     * Internal start of tween. Required because the tween may be interrupted by the
     * [[MapControls]].
     */
    startTween(time) {
        const rotZ = new THREE.Quaternion();
        this.m_userCamerRotation = new THREE.Quaternion();
        this.mapView.camera.getWorldQuaternion(this.m_userCamerRotation);
        // Create a tween to animate the camera rotation around the Z axis.
        //
        // make this a relative rotation, always starting from 0. Take into account the
        // lastRotationValue which may be a leftover from the previous run of "this" tween.
        this.tween = new TWEEN.Tween({ rotation: 0 })
            .to({ rotation: this.endAngle - this.m_lastRotationValue }, this.duration)
            .onComplete(() => {
            this.stop();
            if (this.onFinished) {
                this.onFinished();
            }
        })
            .onUpdate(({ rotation }) => {
            this.m_lastRotationValue = rotation;
            rotZ.setFromEuler(new THREE.Euler(0, 0, harp_geoutils_1.MathUtils.degToRad(rotation)));
            if (this.m_userCamerRotation !== undefined) {
                rotZ.multiply(this.m_userCamerRotation);
            }
            this.mapView.camera.quaternion.copy(rotZ);
        });
        this.tween.repeat(this.repeat);
        this.tween.easing(this.easing);
        this.tween.start(time);
    }
    /**
     * Internal stop of tween. Required because the tween may be interrupted by the [[MapControls]].
     */
    stopTween() {
        if (this.tween) {
            this.tween.stop();
        }
    }
}
exports.CameraRotationAnimation = CameraRotationAnimation;
/**
 * Class to pan between the specified geo coordinates. Height can be specified to move the camera in
 * and out.
 */
class CameraPanAnimation extends CameraAnimation {
    /**
     * Creates a new `CameraPanAnimation` object.
     *
     * @param mapView [[MapView]] which will be affected by the animation.
     * @param options Animation's options.
     * @param name Animation's name.
     */
    constructor(mapView, options, name) {
        super(mapView, name);
        this.name = name;
        /**
         * Specifies interpolation. Defaults to [[InterpolationFunction.CatmullRom]]
         */
        this.interpolation = TWEEN.Interpolation.CatmullRom;
        if (options.duration !== undefined) {
            this.duration = options.duration;
        }
        if (options.repeat !== undefined) {
            this.repeat = options.repeat;
        }
        if (options.easing !== undefined) {
            this.easing =
                typeof options.easing === "function"
                    ? options.easing
                    : easingMap.get(options.easing) || TWEEN.Easing.Linear.None;
        }
        if (options.interpolation !== undefined) {
            this.interpolation =
                typeof options.interpolation === "function"
                    ? options.interpolation
                    : interpolationMap.get(options.interpolation) || TWEEN.Interpolation.Linear;
        }
        this.m_geoCoordinates = options.geoCoordinates !== undefined ? options.geoCoordinates : [];
    }
    /**
     * Add a geo coordinate that should be visited.
     *
     * @param geoPos Geographical coordinate to animate to.
     */
    addPosition(geoPos) {
        this.m_geoCoordinates.push(geoPos);
    }
    /**
     * Start the animation.
     *
     * @param time Duration of the animation in milliseconds.
     * @param onFinished Callback that gets triggered once the animation ends.
     */
    start(time, onFinished) {
        if (this.running) {
            throw new Error("Animation already running" + this.name !== undefined ? this.name : "");
        }
        this.onFinished = onFinished;
        this.running = true;
        const from = new harp_geoutils_1.GeoCoordinates(this.mapView.geoCenter.latitude, this.mapView.geoCenter.longitude, this.mapView.camera.position.z);
        const to = {
            latitude: new Array(),
            longitude: new Array(),
            altitude: new Array()
        };
        for (const pos of this.m_geoCoordinates) {
            to.latitude.push(pos.latitude);
            to.longitude.push(pos.longitude);
            to.altitude.push(pos.altitude || this.mapView.camera.position.z);
        }
        this.tween = new TWEEN.Tween(from)
            .to(to, this.duration)
            .onComplete(() => {
            this.stop();
            if (this.onFinished) {
                this.onFinished();
            }
        })
            .onUpdate(({ latitude, longitude, altitude }) => {
            this.mapView.geoCenter = new harp_geoutils_1.GeoCoordinates(latitude, longitude, altitude);
            this.mapView.camera.position.z = altitude;
        });
        this.tween.repeat(this.repeat);
        this.tween.easing(this.easing);
        this.tween.interpolation(this.interpolation);
        this.tween.start(time);
        this.mapView.beginAnimation();
    }
    /**
     * Stop the animation. Can be started again (with original values only, though).
     */
    stop() {
        if (!this.running) {
            throw new Error("Animation not running" + this.name !== undefined ? this.name : "");
        }
        this.running = false;
        this.mapView.endAnimation();
        if (this.tween) {
            this.tween.stop();
        }
    }
    /**
     * Returns `true` if the animation is being played.
     */
    get isRunning() {
        return this.running;
    }
}
exports.CameraPanAnimation = CameraPanAnimation;
// Cannot use enum as map index in a typesave manner, otherwise I would love to make it more
// elegant...
let easingMap;
let interpolationMap;
function checkSetupTween() {
    if (easingMap !== undefined) {
        return;
    }
    easingMap = new Map();
    interpolationMap = new Map();
    easingMap.set(EasingFunction.Linear, TWEEN.Easing.Linear.None);
    easingMap.set(EasingFunction.QuadraticIn, TWEEN.Easing.Quadratic.In);
    easingMap.set(EasingFunction.QuadraticOut, TWEEN.Easing.Quadratic.Out);
    easingMap.set(EasingFunction.QuadraticInOut, TWEEN.Easing.Quadratic.InOut);
    easingMap.set(EasingFunction.CubicIn, TWEEN.Easing.Cubic.In);
    easingMap.set(EasingFunction.CubicOut, TWEEN.Easing.Cubic.Out);
    easingMap.set(EasingFunction.CubicInOut, TWEEN.Easing.Cubic.InOut);
    easingMap.set(EasingFunction.QuarticIn, TWEEN.Easing.Quartic.In);
    easingMap.set(EasingFunction.QuarticOut, TWEEN.Easing.Quartic.Out);
    easingMap.set(EasingFunction.QuarticInOut, TWEEN.Easing.Quartic.InOut);
    easingMap.set(EasingFunction.QuinticIn, TWEEN.Easing.Quintic.In);
    easingMap.set(EasingFunction.QuinticOut, TWEEN.Easing.Quintic.Out);
    easingMap.set(EasingFunction.QuinticInOut, TWEEN.Easing.Quintic.InOut);
    easingMap.set(EasingFunction.SinusoidalIn, TWEEN.Easing.Sinusoidal.In);
    easingMap.set(EasingFunction.SinusoidalOut, TWEEN.Easing.Sinusoidal.Out);
    easingMap.set(EasingFunction.SinusoidalInOut, TWEEN.Easing.Sinusoidal.InOut);
    easingMap.set(EasingFunction.ExponentialIn, TWEEN.Easing.Exponential.In);
    easingMap.set(EasingFunction.ExponentialOut, TWEEN.Easing.Exponential.Out);
    easingMap.set(EasingFunction.ExponentialInOut, TWEEN.Easing.Exponential.InOut);
    easingMap.set(EasingFunction.CircularIn, TWEEN.Easing.Circular.In);
    easingMap.set(EasingFunction.CircularOut, TWEEN.Easing.Circular.Out);
    easingMap.set(EasingFunction.CircularOut, TWEEN.Easing.Circular.InOut);
    easingMap.set(EasingFunction.ElasticIn, TWEEN.Easing.Elastic.In);
    easingMap.set(EasingFunction.ElasticOut, TWEEN.Easing.Elastic.Out);
    easingMap.set(EasingFunction.ElasticInOut, TWEEN.Easing.Elastic.InOut);
    easingMap.set(EasingFunction.BackIn, TWEEN.Easing.Back.In);
    easingMap.set(EasingFunction.BackOut, TWEEN.Easing.Back.Out);
    easingMap.set(EasingFunction.BackInOut, TWEEN.Easing.Back.InOut);
    easingMap.set(EasingFunction.BounceIn, TWEEN.Easing.Bounce.In);
    easingMap.set(EasingFunction.BounceOut, TWEEN.Easing.Bounce.Out);
    easingMap.set(EasingFunction.BounceInOut, TWEEN.Easing.Bounce.InOut);
    interpolationMap.set(InterpolationFunction.Linear, TWEEN.Interpolation.Linear);
    interpolationMap.set(InterpolationFunction.Bezier, TWEEN.Interpolation.Bezier);
    interpolationMap.set(InterpolationFunction.CatmullRom, TWEEN.Interpolation.CatmullRom);
}


/***/ }),

/***/ "./node_modules/@here/harp-map-controls/lib/MapControls.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/lib/MapControls.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const geoUtils = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "./node_modules/@here/harp-mapview/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const utils = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-map-controls/lib/Utils.js");
var State;
(function (State) {
    State[State["NONE"] = 0] = "NONE";
    State[State["PAN"] = 1] = "PAN";
    State[State["ROTATE"] = 2] = "ROTATE";
    State[State["ORBIT"] = 3] = "ORBIT";
    State[State["TOUCH"] = 4] = "TOUCH";
})(State || (State = {}));
var TiltState;
(function (TiltState) {
    TiltState[TiltState["Tilted"] = 0] = "Tilted";
    TiltState[TiltState["Down"] = 1] = "Down";
})(TiltState = exports.TiltState || (exports.TiltState = {}));
/**
 * Map interaction events' names.
 */
var EventNames;
(function (EventNames) {
    EventNames["Update"] = "update";
    EventNames["BeginInteraction"] = "begin-interaction";
    EventNames["EndInteraction"] = "end-interaction";
})(EventNames = exports.EventNames || (exports.EventNames = {}));
// cast needed to workaround wrong three.js typings.
const MAPCONTROL_EVENT = { type: EventNames.Update };
const MAPCONTROL_EVENT_BEGIN_INTERACTION = {
    type: EventNames.BeginInteraction
};
const MAPCONTROL_EVENT_END_INTERACTION = {
    type: EventNames.EndInteraction
};
/**
 * Yaw rotation as quaternion. Declared as a const to avoid object re-creation across frames.
 */
const yawQuaternion = new THREE.Quaternion();
/**
 * Pitch rotation as quaternion. Declared as a const to avoid object re-creation across frames.
 */
const pitchQuaternion = new THREE.Quaternion();
/**
 * Quaternion used for globe calculations. Declared as a const to avoid re-creation across frames.
 */
const quaternion = new THREE.Quaternion();
/**
 * Matrix declared as a const to avoid re-creation across frames.
 */
const matrix = new THREE.Matrix4();
/**
 * The yaw axis around which we rotate when we change the yaw.
 * This axis is fixed and is the -Z axis `(0,0,1)`.
 */
const yawAxis = new THREE.Vector3(0, 0, 1);
/**
 * The pitch axis which we use to rotate around when we change the pitch.
 * The axis is fix and is the +X axis `(1,0,0)`.
 */
const pitchAxis = new THREE.Vector3(1, 0, 0);
/**
 * The number of the steps for which, when pitching the camera, the delta altitude is scaled until
 * it reaches the minimum camera height.
 */
const MAX_DELTA_ALTITUDE_STEPS = 10;
/**
 * The number of user's inputs to consider for panning inertia, to reduce erratic inputs.
 */
const USER_INPUTS_TO_CONSIDER = 5;
/**
 * The default maximum for the camera pitch. This value avoids seeing the horizon.
 */
const DEFAULT_MAX_PITCH_ANGLE = Math.PI / 4;
/**
 * Epsilon value to rule out when a number can be considered 0.
 */
const EPSILON = 0.01;
/**
 * This map control provides basic map-related building blocks to interact with the map. It also
 * provides a default way of handling user input. Currently we support basic mouse interaction and
 * touch input interaction.
 *
 * Mouse interaction:
 *  - Left mouse button + move = Panning the map.
 *  - Right mouse button + move = Orbits the camera around the focus point.
 *  - Middle mouse button + move = Rotating the view. Up down movement changes the pitch. Left/right
 *    movement changes the yaw.
 *  - Mouse wheel = Zooms up and down by one zoom level, zooms on target.
 *
 * Touch interaction:
 *  - One finger = Panning the map.
 *  - Two fingers = Scale, rotate and panning the map.
 *  - Three fingers = Orbiting the map. Up down movements influences the current orbit altitude.
 *    Left/right changes the azimuth.
 */
class MapControls extends THREE.EventDispatcher {
    /**
     * Constructs a new `MapControls` object.
     *
     * @param mapView [[MapView]] this controller modifies.Z
     */
    constructor(mapView) {
        super();
        this.mapView = mapView;
        /**
         * This factor will be applied to the delta of the current mouse pointer position and the last
         * mouse pointer position: The result then will be used as an offset for the rotation then.
         * Default value is `0.1`.
         */
        this.rotationMouseDeltaFactor = 0.1;
        /**
         * This factor will be applied to the delta of the current mouse pointer position and the last
         * mouse pointer position: The result then will be used as an offset to orbit the camera.
         * Default value is `0.1`.
         */
        this.orbitingMouseDeltaFactor = 0.1;
        /**
         * This factor will be applied to the delta of the current touch pointer position and the last
         * touch pointer position: The result then will be used as an offset to orbit the camera.
         * Default value is `0.1`.
         */
        this.orbitingTouchDeltaFactor = 0.1;
        /**
         * Set to `true` to enable input handling through this map control, `false` to disable input
         * handling. Even when disabling input handling, you can manually use the public functions to
         * change the view to the current map.
         */
        this.enabled = true;
        /**
         * Set to `true` to enable orbiting and Pitch axis rotation through this map control, `false` to
         * disable orbiting and Pitch axis rotation.
         */
        this.tiltEnabled = true;
        /**
         * Set to `true` to enable rotation through this map control, `false` to disable rotation.
         */
        this.rotateEnabled = true;
        /**
         * Set to `true` to enable an inertia dampening on zooming and panning. `false` cancels inertia.
         */
        this.inertiaEnabled = true;
        /**
         * Inertia damping duration for the zoom, in seconds.
         */
        this.zoomInertiaDampingDuration = 0.5;
        /**
         * Inertia damping duration for the panning, in seconds.
         */
        this.panInertiaDampingDuration = 1.0;
        /**
         * Duration in seconds of the camera animation when the tilt button is clicked. Independent of
         * inertia.
         */
        this.tiltToggleDuration = 0.5;
        /**
         * Camera pitch target when tilting it from the UI button.
         */
        this.tiltAngle = Math.PI / 4;
        /**
         * Determines the zoom level delta for single mouse wheel movement. So after each mouse wheel
         * movement the current zoom level will be added or subtracted by this value. The default value
         * is `0.2` - this means that every 5th mouse wheel movement you will cross a zoom level.
         *
         * **Note**: To reverse the zoom direction, you can provide a negative value.
         */
        this.zoomLevelDeltaOnMouseWheel = 0.2;
        /**
         * Zoom level delta when using the UI controls.
         */
        this.zoomLevelDeltaOnControl = 1.0;
        /**
         * Determines the minimum zoom level we can zoom to.
         */
        this.minZoomLevel = 0;
        /**
         * Determines the maximum zoom level we can zoom to.
         */
        this.maxZoomLevel = 20;
        /**
         * Determines the minimum camera height in meter.
         */
        this.minCameraHeight = 3;
        this.m_currentViewDirection = new THREE.Vector3();
        this.m_lastMousePosition = new THREE.Vector2(0, 0);
        this.m_mouseDelta = new THREE.Vector2(0, 0);
        this.m_needsRenderLastFrame = true;
        this.m_panIsAnimated = false;
        this.m_panDistanceFrameDelta = new THREE.Vector3();
        this.m_panAnimationTime = 0;
        this.m_panAnimationStartTime = 0;
        this.m_lastAveragedPanDistance = 0;
        this.m_currentInertialPanningSpeed = 0;
        this.m_lastPanVector = new THREE.Vector3();
        this.m_recentPanDistances = [0, 0, 0, 0, 0];
        this.m_currentPanDistanceIndex = 0;
        this.m_zoomIsAnimated = false;
        this.m_zoomDeltaRequested = 0;
        this.m_zoomTargetNormalizedCoordinates = new THREE.Vector2();
        this.m_zoomAnimationTime = 0;
        this.m_zoomAnimationStartTime = 0;
        this.m_startZoom = 0;
        this.m_tiltIsAnimated = false;
        this.m_pitchRequested = undefined;
        this.m_tiltAnimationTime = 0;
        this.m_tiltAnimationStartTime = 0;
        this.m_startPitch = 0;
        this.m_state = State.NONE;
        this.m_tmpVector2 = new THREE.Vector2();
        this.m_tmpVector3 = new THREE.Vector3();
        /**
         * Determines the minimum angle the camera can pitch to. It is defined in radians.
         */
        this.m_minPitchAngle = 0;
        /**
         * Determines the maximum angle the camera can pitch to. It is defined in radians.
         */
        this.m_maxPitchAngle = DEFAULT_MAX_PITCH_ANGLE;
        this.m_touchState = {
            touches: [],
            currentRotation: 0,
            initialRotation: 0
        };
        /**
         * Destroy this `MapControls` instance.
         *
         * Unregisters all grobal event handlers used. This is method should be called when you stop
         * using `MapControls`.
         */
        this.dispose = () => {
            // replaced with real code in bindInputEvents
        };
        this.camera = mapView.camera;
        this.domElement = mapView.renderer.domElement;
        this.maxZoomLevel = mapView.maxZoomLevel;
        this.minZoomLevel = mapView.minZoomLevel;
        this.minCameraHeight = mapView.minCameraHeight;
        this.bindInputEvents(this.domElement);
        this.handleZoom = this.handleZoom.bind(this);
        this.pan = this.pan.bind(this);
        this.tilt = this.tilt.bind(this);
    }
    /**
     * Creates MapControls object and attaches it specified [[MapView]].
     *
     * @param mapView - [[MapView]] object to which MapControls should be attached to.
     */
    static create(mapView) {
        return new MapControls(mapView);
    }
    /**
     * Rotates the camera by the given delta yaw and delta pitch.
     *
     * @param deltaYaw Delta yaw in degrees.
     * @param deltaPitch Delta pitch in degrees.
     */
    rotate(deltaYaw, deltaPitch) {
        if (this.inertiaEnabled && this.m_zoomIsAnimated) {
            this.stopZoom();
        }
        const yawPitchRoll = harp_mapview_1.MapViewUtils.extractYawPitchRoll(this.camera.quaternion);
        //yaw
        let yawAngle = yawPitchRoll.yaw;
        if (this.rotateEnabled) {
            yawAngle -= geoUtils.MathUtils.degToRad(deltaYaw);
        }
        yawQuaternion.setFromAxisAngle(yawAxis, yawAngle);
        //pitch
        const deltaPitchRadians = geoUtils.MathUtils.degToRad(deltaPitch);
        const pitchAngle = this.constrainPitchAngle(yawPitchRoll.pitch, deltaPitchRadians);
        pitchQuaternion.setFromAxisAngle(pitchAxis, pitchAngle);
        yawQuaternion.multiply(pitchQuaternion);
        this.mapView.camera.quaternion.copy(yawQuaternion);
        this.mapView.camera.matrixWorldNeedsUpdate = true;
    }
    /**
     * Current viewing angles yaw/pitch/roll in degrees.
     */
    get yawPitchRoll() {
        const ypr = harp_mapview_1.MapViewUtils.extractYawPitchRoll(this.camera.quaternion);
        return {
            yaw: geoUtils.MathUtils.radToDeg(ypr.yaw),
            pitch: geoUtils.MathUtils.radToDeg(ypr.pitch),
            roll: geoUtils.MathUtils.radToDeg(ypr.roll)
        };
    }
    /*
     * Orbits the camera around the focus point of the camera. The `deltaAzimuth` and
     * `deltaAltitude` are offsets in degrees to the current azimuth and altitude of the current
     * orbit.
     *
     * @param deltaAzimuth Delta azimuth in degrees.
     * @param deltaAltitude Delta altitude in degrees.
     */
    orbitFocusPoint(deltaAzimuth, deltaAltitude) {
        if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            return;
        }
        if (this.inertiaEnabled && this.m_zoomIsAnimated) {
            this.stopZoom();
        }
        this.mapView.camera.getWorldDirection(this.m_currentViewDirection);
        const currentAzimuthAltitude = utils.directionToAzimuthAltitude(this.m_currentViewDirection);
        const topElevation = (1.0 / Math.sin(currentAzimuthAltitude.altitude)) * this.mapView.camera.position.z;
        const focusPointInWorldPosition = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, 0, 0);
        const deltaAltitudeConstrained = this.getMinDelta(deltaAltitude);
        this.rotate(deltaAzimuth, deltaAltitudeConstrained);
        this.mapView.camera.getWorldDirection(this.m_currentViewDirection);
        const newAzimuthAltitude = utils.directionToAzimuthAltitude(this.m_currentViewDirection);
        const newElevation = Math.sin(newAzimuthAltitude.altitude) * topElevation;
        this.mapView.camera.position.z = newElevation;
        const newFocusPointInWorldPosition = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, 0, 0);
        if (!focusPointInWorldPosition || !newFocusPointInWorldPosition) {
            // We do this to trigger an update in all cases.
            this.updateMapView();
            return;
        }
        const diff = focusPointInWorldPosition.sub(newFocusPointInWorldPosition);
        harp_mapview_1.MapViewUtils.pan(this.mapView, diff.x, diff.y);
    }
    /**
     * Moves the camera along the view direction in meters.
     * A positive value will move the camera further away from the point where the camera looks at.
     * A negative value will move the camera near to the point where the camera looks at.
     *
     * @param amount Amount to move along the view direction in meters.
     */
    moveAlongTheViewDirection(amount) {
        this.mapView.camera.getWorldDirection(this.m_currentViewDirection);
        this.m_currentViewDirection.multiplyScalar(amount);
        this.mapView.camera.position.z += this.m_currentViewDirection.z;
        this.updateMapView();
    }
    /**
     * Sets the rotation of the camera according to yaw and pitch in degrees.
     *
     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the
     * map.
     *
     * @param yaw Yaw in degrees.
     * @param pitch Pitch in degrees.
     */
    setRotation(yaw, pitch) {
        harp_mapview_1.MapViewUtils.setRotation(this.mapView, yaw, pitch);
    }
    /**
     * Zooms and moves the map in such a way that the given target position remains at the same
     * position after the zoom.
     *
     * @param targetPositionOnScreenXinNDC Target x position in NDC space.
     * @param targetPositionOnScreenYinNDC Target y position in NDC space.
     */
    zoomOnTargetPosition(targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC, zoomLevel) {
        harp_mapview_1.MapViewUtils.zoomOnTargetPosition(this.mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC, zoomLevel);
    }
    /**
     * Zooms to the desired location by the provided value.
     *
     * @param zoomLevel Zoom level.
     * @param screenTarget Zoom target on screen.
     */
    setZoomLevel(zoomLevel, screenTarget = { x: 0, y: 0 }) {
        if (this.enabled === false) {
            return;
        }
        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
        // Register the zoom request
        this.m_startZoom = this.currentZoom;
        this.m_zoomDeltaRequested = zoomLevel - this.zoomLevelTargeted;
        // Cancel panning so the point of origin of the zoom is maintained.
        this.m_panDistanceFrameDelta.set(0, 0, 0);
        this.m_lastAveragedPanDistance = 0;
        // Assign the new animation start time.
        this.m_zoomAnimationStartTime = performance.now();
        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
            this.m_zoomTargetNormalizedCoordinates.set(screenTarget.x, screenTarget.y);
            this.handleZoom();
        }
        else {
            const surfaceNormal = this.mapView.projection.surfaceNormal(this.camera.position, new THREE.Vector3());
            // TODO: HARP-5431 Use the elevation provider to find the ground distance
            // if terrain is enabled.
            this.camera.position.addScaledVector(surfaceNormal, ((this.zoomLevelTargeted - zoomLevel) / this.zoomLevelDeltaOnMouseWheel) *
                this.mapView.projection.groundDistance(this.camera.position) *
                0.05);
            // TODO: HARP-5430 Ensures that we don't intersect the terrain, a similar
            // approach to that should be used here, at least for consistency sake.
            if (this.mapView.projection.groundDistance(this.camera.position) < 500) {
                this.mapView.projection.scalePointToSurface(this.camera.position);
                this.camera.position.addScaledVector(surfaceNormal, 500);
            }
            this.updateMapView();
        }
        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
    }
    /**
     * Toggles the camera pitch between 0 (looking down) and the value at `this.tiltAngle`.
     */
    toggleTilt() {
        this.m_startPitch = this.currentPitch;
        const aimTilt = this.m_startPitch < EPSILON || this.m_tiltState === TiltState.Down;
        this.m_pitchRequested = aimTilt ? this.tiltAngle : 0;
        this.m_tiltState = aimTilt ? TiltState.Tilted : TiltState.Down;
        this.m_tiltAnimationStartTime = performance.now();
        this.tilt();
    }
    /**
     * Set the camera height.
     */
    set cameraHeight(height) {
        //Set the cameras height according to the given zoom level.
        this.camera.position.setZ(height);
        this.camera.matrixWorldNeedsUpdate = true;
    }
    /**
     * Get the current camera height.
     */
    get cameraHeight() {
        // ### Sync with the way geoviz is computing the zoom level.
        return this.mapView.camera.position.z;
    }
    /**
     * Set camera max pitch angle.
     *
     * @param angle Angle in degrees.
     */
    set maxPitchAngle(angle) {
        this.m_maxPitchAngle = geoUtils.MathUtils.degToRad(angle);
    }
    /**
     * Get the camera max pitch angle in degrees.
     */
    get maxPitchAngle() {
        return geoUtils.MathUtils.radToDeg(this.m_maxPitchAngle);
    }
    /**
     * Set camera min pitch angle.
     *
     * @param angle Angle in degrees.
     */
    set minPitchAngle(angle) {
        this.m_minPitchAngle = geoUtils.MathUtils.degToRad(angle);
    }
    /**
     * Get the camera min pitch angle in degrees.
     */
    get minPitchAngle() {
        return geoUtils.MathUtils.radToDeg(this.m_minPitchAngle);
    }
    /**
     * Get the zoom level targeted by `MapControls`. Useful when inertia is on, to add incremented
     * values to the target instead of getting the random zoomLevel value during the interpolation.
     */
    get zoomLevelTargeted() {
        return this.m_targetedZoom === undefined ? this.currentZoom : this.m_targetedZoom;
    }
    /**
     * Handy getter to know if the view is in the process of looking down or not.
     */
    get tiltState() {
        if (this.m_tiltState === undefined) {
            this.m_tiltState =
                this.currentPitch < EPSILON || this.m_tiltState === TiltState.Down
                    ? TiltState.Tilted
                    : TiltState.Down;
        }
        return this.m_tiltState;
    }
    set currentZoom(zoom) {
        this.m_currentZoom = zoom;
    }
    get currentZoom() {
        return this.m_currentZoom !== undefined ? this.m_currentZoom : this.mapView.zoomLevel;
    }
    set currentPitch(pitch) {
        this.m_currentPitch = pitch;
    }
    get currentPitch() {
        return harp_mapview_1.MapViewUtils.extractYawPitchRoll(this.mapView.camera.quaternion).pitch;
    }
    get targetedPitch() {
        return this.m_targetedPitch === undefined
            ? this.m_currentPitch === undefined
                ? this.currentPitch
                : this.m_currentPitch
            : this.m_targetedPitch;
    }
    tilt() {
        if (this.m_pitchRequested !== undefined) {
            this.m_targetedPitch = Math.max(Math.min(this.m_pitchRequested, this.maxPitchAngle), this.m_minPitchAngle);
            this.m_pitchRequested = undefined;
        }
        if (this.inertiaEnabled) {
            if (!this.m_tiltIsAnimated) {
                this.m_tiltIsAnimated = true;
                this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.tilt);
            }
            const currentTime = performance.now();
            this.m_tiltAnimationTime = (currentTime - this.m_tiltAnimationStartTime) / 1000;
            const tiltFinished = this.m_tiltAnimationTime > this.tiltToggleDuration;
            if (tiltFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.m_tiltAnimationTime = this.tiltToggleDuration;
                    this.stopTilt();
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
        }
        this.m_currentPitch = this.inertiaEnabled
            ? this.easeOutCubic(this.m_startPitch, this.targetedPitch, Math.min(1, this.m_tiltAnimationTime / this.tiltToggleDuration))
            : this.targetedPitch;
        const initialPitch = this.currentPitch;
        const deltaAngle = this.m_currentPitch - initialPitch;
        const oldCameraDistance = this.mapView.camera.position.z / Math.cos(initialPitch);
        const newHeight = Math.cos(this.currentPitch) * oldCameraDistance;
        this.orbitFocusPoint(newHeight - this.camera.position.z, geoUtils.MathUtils.radToDeg(deltaAngle));
        this.updateMapView();
    }
    stopTilt() {
        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.tilt);
        this.m_tiltIsAnimated = false;
        this.m_targetedPitch = this.m_currentPitch = undefined;
    }
    easeOutCubic(startValue, endValue, time) {
        return startValue + (endValue - startValue) * (--time * time * time + 1);
    }
    handleZoom() {
        if (this.m_zoomDeltaRequested !== 0) {
            this.m_targetedZoom = Math.max(Math.min(this.zoomLevelTargeted + this.m_zoomDeltaRequested, this.maxZoomLevel), this.minZoomLevel);
            this.m_zoomDeltaRequested = 0;
        }
        if (this.inertiaEnabled) {
            if (!this.m_zoomIsAnimated) {
                this.m_zoomIsAnimated = true;
                this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handleZoom);
            }
            const currentTime = performance.now();
            this.m_zoomAnimationTime = (currentTime - this.m_zoomAnimationStartTime) / 1000;
            const zoomFinished = this.m_zoomAnimationTime > this.zoomInertiaDampingDuration;
            if (zoomFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.m_zoomAnimationTime = this.zoomInertiaDampingDuration;
                    this.stopZoom();
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
        }
        this.currentZoom =
            !this.inertiaEnabled || Math.abs(this.zoomLevelTargeted - this.m_startZoom) < EPSILON
                ? this.zoomLevelTargeted
                : this.easeOutCubic(this.m_startZoom, this.zoomLevelTargeted, Math.min(1, this.m_zoomAnimationTime / this.zoomInertiaDampingDuration));
        harp_mapview_1.MapViewUtils.zoomOnTargetPosition(this.mapView, this.m_zoomTargetNormalizedCoordinates.x, this.m_zoomTargetNormalizedCoordinates.y, this.currentZoom);
        this.updateMapView();
    }
    stopZoom() {
        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handleZoom);
        this.m_zoomIsAnimated = false;
    }
    pan() {
        if (this.m_state === State.NONE && this.m_lastAveragedPanDistance === 0) {
            return;
        }
        if (this.inertiaEnabled && !this.m_panIsAnimated) {
            this.m_panIsAnimated = true;
            this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.pan);
        }
        const applyInertia = this.inertiaEnabled &&
            this.m_state === State.NONE &&
            this.m_lastAveragedPanDistance > 0;
        if (applyInertia) {
            const currentTime = performance.now();
            this.m_panAnimationTime = (currentTime - this.m_panAnimationStartTime) / 1000;
            const panFinished = this.m_panAnimationTime > this.panInertiaDampingDuration;
            if (panFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.m_panAnimationTime = this.panInertiaDampingDuration;
                    this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.pan);
                    this.m_panIsAnimated = false;
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
            const animationTime = this.m_panAnimationTime / this.panInertiaDampingDuration;
            this.m_currentInertialPanningSpeed = this.easeOutCubic(this.m_lastAveragedPanDistance, 0, Math.min(1, animationTime));
            if (this.m_currentInertialPanningSpeed === 0) {
                this.m_lastAveragedPanDistance = 0;
            }
            this.m_panDistanceFrameDelta
                .copy(this.m_lastPanVector)
                .setLength(this.m_currentInertialPanningSpeed);
        }
        else {
            this.m_lastPanVector.copy(this.m_panDistanceFrameDelta);
            const panDistance = this.m_lastPanVector.length();
            this.m_currentPanDistanceIndex =
                (this.m_currentPanDistanceIndex + 1) % USER_INPUTS_TO_CONSIDER;
            this.m_recentPanDistances[this.m_currentPanDistanceIndex] = panDistance;
            this.m_lastAveragedPanDistance =
                this.m_recentPanDistances.reduce((a, b) => a + b) / USER_INPUTS_TO_CONSIDER;
        }
        harp_mapview_1.MapViewUtils.pan(this.mapView, this.m_panDistanceFrameDelta.x, this.m_panDistanceFrameDelta.y);
        if (!applyInertia) {
            this.m_panDistanceFrameDelta.set(0, 0, 0);
        }
        this.updateMapView();
    }
    bindInputEvents(domElement) {
        const onContextMenu = this.contextMenu.bind(this);
        const onMouseDown = this.mouseDown.bind(this);
        const onMouseWheel = this.mouseWheel.bind(this);
        const onTouchStart = this.touchStart.bind(this);
        const onTouchEnd = this.touchEnd.bind(this);
        const onTouchMove = this.touchMove.bind(this);
        domElement.addEventListener("contextmenu", onContextMenu, false);
        domElement.addEventListener("mousedown", onMouseDown, false);
        domElement.addEventListener("wheel", onMouseWheel, false);
        domElement.addEventListener("touchstart", onTouchStart, false);
        domElement.addEventListener("touchend", onTouchEnd, false);
        domElement.addEventListener("touchmove", onTouchMove, false);
        this.dispose = () => {
            domElement.removeEventListener("contextmenu", onContextMenu, false);
            domElement.removeEventListener("mousedown", onMouseDown, false);
            domElement.removeEventListener("wheel", onMouseWheel, false);
            domElement.removeEventListener("touchstart", onTouchStart, false);
            domElement.removeEventListener("touchend", onTouchEnd, false);
            domElement.removeEventListener("touchmove", onTouchMove, false);
        };
    }
    updateMapView() {
        this.dispatchEvent(MAPCONTROL_EVENT);
        this.mapView.update();
    }
    mouseDown(event) {
        if (this.enabled === false) {
            return;
        }
        if (event.shiftKey || event.ctrlKey) {
            return;
        }
        event.stopPropagation();
        if (this.m_state !== State.NONE) {
            return;
        }
        if (event.button === 0) {
            this.m_state = State.PAN;
        }
        else if (event.button === 1) {
            this.m_state = State.ROTATE;
        }
        else if (event.button === 2 && this.tiltEnabled) {
            this.m_state = State.ORBIT;
        }
        else {
            return;
        }
        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
        this.m_lastMousePosition.setX(event.clientX);
        this.m_lastMousePosition.setY(event.clientY);
        const onMouseMove = this.mouseMove.bind(this);
        const onMouseUp = this.mouseUp.bind(this);
        window.addEventListener("mousemove", onMouseMove, false);
        window.addEventListener("mouseup", onMouseUp, false);
        this.m_cleanupMouseEventListeners = () => {
            window.removeEventListener("mousemove", onMouseMove);
            window.removeEventListener("mouseup", onMouseUp);
        };
    }
    mouseMove(event) {
        if (this.enabled === false) {
            return;
        }
        this.m_mouseDelta.set(event.clientX - this.m_lastMousePosition.x, event.clientY - this.m_lastMousePosition.y);
        if (this.m_state === State.PAN) {
            this.panFromTo(this.m_lastMousePosition.x, this.m_lastMousePosition.y, event.clientX, event.clientY);
        }
        else if (this.m_state === State.ROTATE) {
            this.rotate(-this.rotationMouseDeltaFactor * this.m_mouseDelta.x, this.rotationMouseDeltaFactor * this.m_mouseDelta.y);
        }
        else if (this.m_state === State.ORBIT) {
            this.orbitFocusPoint(this.orbitingMouseDeltaFactor * this.m_mouseDelta.x, -this.orbitingMouseDeltaFactor * this.m_mouseDelta.y);
        }
        this.m_lastMousePosition.setX(event.clientX);
        this.m_lastMousePosition.setY(event.clientY);
        this.m_zoomAnimationStartTime = performance.now();
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
    }
    mouseUp(event) {
        if (this.enabled === false) {
            return;
        }
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
        this.m_state = State.NONE;
        if (this.m_cleanupMouseEventListeners) {
            this.m_cleanupMouseEventListeners();
        }
        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
    }
    mouseWheel(event) {
        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
        const screenTarget = utils.calculateNormalizedDeviceCoordinates(event.offsetX, event.offsetY, width, height);
        this.setZoomLevel(this.zoomLevelTargeted + this.zoomLevelDeltaOnMouseWheel * (event.deltaY > 0 ? -1 : 1), screenTarget);
        event.preventDefault();
        event.stopPropagation();
    }
    /**
     * Calculates the angle of the vector, which is formed by two touch points in world space
     * against the X axis in world space on the map. The resulting angle is in radians and between
     * `-PI` and `PI`.
     */
    calculateAngleFromTouchPointsInWorldspace() {
        if (this.m_touchState.touches.length < 2) {
            return 0;
        }
        const x = this.m_touchState.touches[1].currentWorldPosition.x -
            this.m_touchState.touches[0].currentWorldPosition.x;
        const y = this.m_touchState.touches[1].currentWorldPosition.y -
            this.m_touchState.touches[0].currentWorldPosition.y;
        return Math.atan2(y, x);
    }
    /**
     * Calculates the difference of the current distance of two touch points against their initial
     * distance in world space.
     */
    calculatePinchDistanceInWorldSpace() {
        if (this.m_touchState.touches.length < 2) {
            return 0;
        }
        const initialDistance = this.m_tmpVector3
            .subVectors(this.m_touchState.touches[0].initialWorldPosition, this.m_touchState.touches[1].initialWorldPosition)
            .length();
        const currentDistance = this.m_tmpVector3
            .subVectors(this.m_touchState.touches[0].currentWorldPosition, this.m_touchState.touches[1].currentWorldPosition)
            .length();
        return currentDistance - initialDistance;
    }
    convertTouchPoint(touch) {
        const newTouchPoint = new THREE.Vector2(touch.pageX, touch.pageY);
        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
        const touchPointInNDC = utils.calculateNormalizedDeviceCoordinates(newTouchPoint.x, newTouchPoint.y, width, height);
        const newWorldPosition = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, touchPointInNDC.x, touchPointInNDC.y);
        if (newWorldPosition === null) {
            return null;
        }
        return {
            currentTouchPoint: newTouchPoint,
            lastTouchPoint: newTouchPoint,
            currentWorldPosition: newWorldPosition,
            initialWorldPosition: newWorldPosition
        };
    }
    setTouchState(touches) {
        this.m_touchState.touches = [];
        // TouchList doesn't conform to iterator interface so we cannot use 'for of'
        // tslint:disable-next-line:prefer-for-of
        for (let i = 0; i < touches.length; ++i) {
            const touchState = this.convertTouchPoint(touches[i]);
            if (touchState) {
                this.m_touchState.touches.push(touchState);
            }
        }
        if (this.m_touchState.touches.length !== 0) {
            this.updateTouchState();
            this.m_touchState.initialRotation = this.m_touchState.currentRotation;
        }
    }
    updateTouchState() {
        this.m_touchState.currentRotation = this.calculateAngleFromTouchPointsInWorldspace();
    }
    updateTouches(touches) {
        const length = Math.min(touches.length, this.m_touchState.touches.length);
        for (let i = 0; i < length; ++i) {
            const oldTouchState = this.m_touchState.touches[i];
            const newTouchState = this.convertTouchPoint(touches[i]);
            if (newTouchState !== null) {
                newTouchState.initialWorldPosition = oldTouchState.initialWorldPosition;
                newTouchState.lastTouchPoint = oldTouchState.currentTouchPoint;
                this.m_touchState.touches[i] = newTouchState;
            }
        }
    }
    touchStart(event) {
        if (this.enabled === false) {
            return;
        }
        this.m_state = State.TOUCH;
        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
        this.setTouchState(event.touches);
        event.preventDefault();
        event.stopPropagation();
    }
    touchMove(event) {
        if (this.enabled === false) {
            return;
        }
        this.updateTouches(event.touches);
        this.updateTouchState();
        if (this.m_touchState.touches.length <= 2) {
            this.m_panDistanceFrameDelta.subVectors(this.m_touchState.touches[0].initialWorldPosition, this.m_touchState.touches[0].currentWorldPosition);
            // Cancel zoom inertia if a panning is triggered, so that the mouse location is kept.
            this.m_startZoom = this.m_targetedZoom = this.currentZoom;
            // Assign the new animation start time.
            this.m_panAnimationStartTime = performance.now();
            this.pan();
        }
        if (this.m_touchState.touches.length === 2) {
            const deltaRotation = this.m_touchState.currentRotation - this.m_touchState.initialRotation;
            this.rotate(geoUtils.MathUtils.radToDeg(deltaRotation), 0);
            this.moveAlongTheViewDirection(this.calculatePinchDistanceInWorldSpace());
        }
        if (this.m_touchState.touches.length === 3 && this.tiltEnabled) {
            const firstTouch = this.m_touchState.touches[0];
            const diff = this.m_tmpVector2.subVectors(firstTouch.currentTouchPoint, firstTouch.lastTouchPoint);
            this.orbitFocusPoint(this.orbitingTouchDeltaFactor * diff.x, -this.orbitingTouchDeltaFactor * diff.y);
        }
        this.m_zoomAnimationStartTime = performance.now();
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
    }
    touchEnd(event) {
        if (this.enabled === false) {
            return;
        }
        this.m_state = State.NONE;
        this.setTouchState(event.touches);
        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
    }
    contextMenu(event) {
        event.preventDefault();
    }
    panFromTo(fromX, fromY, toX, toY) {
        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
        const from = utils.calculateNormalizedDeviceCoordinates(fromX, fromY, width, height);
        const to = utils.calculateNormalizedDeviceCoordinates(toX, toY, width, height);
        let toWorld;
        let fromWorld;
        if (this.mapView.elevationProvider === undefined) {
            fromWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, from.x, from.y);
            toWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y);
        }
        else {
            fromWorld = this.mapView.elevationProvider.rayCast(fromX, fromY);
            if (fromWorld === undefined) {
                return;
            }
            const fromGeoAltitude = this.mapView.projection.unprojectAltitude(fromWorld);
            // We can ensure that points under the mouse stay there by projecting the to point onto
            // a plane with the altitude based on the initial point.
            // Todo: Check this works for spherical panning.
            toWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y, fromGeoAltitude);
        }
        if (toWorld === undefined || fromWorld === undefined) {
            return;
        }
        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
            // Cancel zoom inertia if a panning is triggered, so that the mouse location is kept.
            this.stopZoom();
            // Assign the new animation start time.
            this.m_panAnimationStartTime = performance.now();
            this.m_panDistanceFrameDelta = fromWorld.sub(toWorld);
            this.pan();
        }
        else {
            quaternion.setFromUnitVectors(fromWorld.normalize(), toWorld.normalize()).inverse();
            matrix.copyPosition(this.camera.matrix).makeRotationFromQuaternion(quaternion);
            this.camera.applyMatrix(matrix);
        }
    }
    constrainPitchAngle(pitchAngle, deltaPitch) {
        const tmpPitchAngle = geoUtils.MathUtils.clamp(pitchAngle + deltaPitch, this.m_minPitchAngle, this.m_maxPitchAngle);
        if (this.tiltEnabled &&
            tmpPitchAngle <= this.m_maxPitchAngle &&
            tmpPitchAngle >= this.m_minPitchAngle) {
            pitchAngle = tmpPitchAngle;
        }
        return pitchAngle;
    }
    /**
     * This method approximates the minimum delta altitude by attempts. It has been preferred over a
     * solution where the minimum delta is calculated adding the new delta to the current delta,
     * because that solution would not have worked with terrains.
     */
    getMinDelta(deltaAltitude) {
        // Do not even start to calculate a delta if the camera is already under the minimum height.
        if (this.mapView.camera.position.z < this.minCameraHeight && deltaAltitude > 0) {
            return 0;
        }
        const checkMinCamHeight = (deltaAlt, camera) => {
            const cameraPos = camera.position;
            const cameraQuat = camera.quaternion;
            const newPitchQuaternion = new THREE.Quaternion();
            const viewDirection = new THREE.Vector3();
            const mockCamera = new THREE.Object3D();
            mockCamera.position.set(cameraPos.x, cameraPos.y, cameraPos.z);
            mockCamera.quaternion.set(cameraQuat.x, cameraQuat.y, cameraQuat.z, cameraQuat.w);
            // save the current direction of the camera in viewDirection
            mockCamera.getWorldDirection(viewDirection);
            //calculate the new azimuth and altitude
            const currentAzimuthAltitude = utils.directionToAzimuthAltitude(viewDirection);
            const topElevation = (1.0 / Math.sin(currentAzimuthAltitude.altitude)) * mockCamera.position.z;
            // get the current quaternion from the camera
            const yawPitchRoll = harp_mapview_1.MapViewUtils.extractYawPitchRoll(mockCamera.quaternion);
            //calculate the pitch
            const deltaPitchRadians = geoUtils.MathUtils.degToRad(deltaAlt);
            const pitchAngle = this.constrainPitchAngle(yawPitchRoll.pitch, deltaPitchRadians);
            newPitchQuaternion.setFromAxisAngle(pitchAxis, pitchAngle);
            // update the camera and the viewDirection vector
            mockCamera.quaternion.copy(newPitchQuaternion);
            mockCamera.matrixWorldNeedsUpdate = true;
            mockCamera.getWorldDirection(viewDirection);
            // use the viewDirection to get the height
            const newAzimuthAltitude = utils.directionToAzimuthAltitude(viewDirection);
            const newElevation = Math.sin(newAzimuthAltitude.altitude) * topElevation;
            return newElevation;
        };
        let constrainedDeltaAltitude = deltaAltitude;
        for (let i = 0; i < MAX_DELTA_ALTITUDE_STEPS; i++) {
            const cameraHeight = checkMinCamHeight(constrainedDeltaAltitude, this.mapView.camera);
            if (cameraHeight < this.minCameraHeight) {
                constrainedDeltaAltitude *= 0.5;
            }
            else {
                return constrainedDeltaAltitude;
            }
        }
        return constrainedDeltaAltitude;
    }
}
exports.MapControls = MapControls;


/***/ }),

/***/ "./node_modules/@here/harp-map-controls/lib/MapControlsUI.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/lib/MapControlsUI.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "./node_modules/@here/harp-mapview/index.js");
/**
 * Base class to handle UI overlay elements.
 */
class MapControlsUI {
    /**
     * Constructor of the UI.
     *
     * @param controls Controls referencing a [[MapView]].
     */
    constructor(controls, options = {}) {
        this.controls = controls;
        /**
         * The DOM node containing the UI.
         */
        this.domElement = document.createElement("div");
        /**
         * Displays zoom level if [[MapControlsUIOptions.zoomLevel]] is defined.
         */
        this.m_zoomLevelElement = null;
        this.m_onMapViewRenderEvent = () => {
            if (this.m_zoomLevelElement === null) {
                return;
            }
            const zoom = this.controls.zoomLevelTargeted.toFixed(1);
            if (this.m_zoomLevelElement.tagName === "INPUT") {
                this.m_zoomLevelElement.value = zoom;
            }
            else {
                this.m_zoomLevelElement.innerHTML = zoom;
            }
        };
        this.m_onWindowClick = (event) => {
            const input = this.m_zoomLevelElement;
            if (!event ||
                !event.target ||
                !event.target.contains ||
                (event.target === input || event.target.contains(input))) {
                return;
            }
            input.blur();
        };
        const zoomInButton = document.createElement("button");
        zoomInButton.innerText = "+";
        const zoomOutButton = document.createElement("button");
        zoomOutButton.innerText = "-";
        const tiltButton = document.createElement("button");
        tiltButton.innerText = "3D";
        // Optional zoom level displaying
        if (options.zoomLevel === "show") {
            const div = document.createElement("div");
            controls.mapView.addEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);
            this.m_zoomLevelElement = div;
        }
        else if (options.zoomLevel === "input") {
            const input = document.createElement("input");
            input.type = "number";
            controls.mapView.addEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);
            const updateZoom = (event) => {
                controls.setZoomLevel(parseFloat(input.value));
                event.preventDefault();
            };
            input.addEventListener("blur", updateZoom);
            input.addEventListener("keypress", event => {
                if (event.key === "Enter") {
                    updateZoom(event);
                }
            });
            window.addEventListener("click", this.m_onWindowClick);
            this.m_zoomLevelElement = input;
        }
        this.domElement.appendChild(zoomInButton);
        this.domElement.appendChild(tiltButton);
        if (this.m_zoomLevelElement !== null) {
            this.domElement.appendChild(this.m_zoomLevelElement);
        }
        this.domElement.appendChild(zoomOutButton);
        zoomInButton.addEventListener("click", event => {
            const zoomLevel = controls.zoomLevelTargeted + controls.zoomLevelDeltaOnControl;
            controls.setZoomLevel(zoomLevel);
        });
        zoomOutButton.addEventListener("click", event => {
            const zoomLevel = controls.zoomLevelTargeted - controls.zoomLevelDeltaOnControl;
            controls.setZoomLevel(zoomLevel);
        });
        tiltButton.addEventListener("click", event => {
            controls.toggleTilt();
        });
        this.domElement.className = "harp-gl_controls";
        zoomInButton.className = zoomOutButton.className = tiltButton.className =
            "harp-gl_controls-button";
        if (this.m_zoomLevelElement !== null) {
            this.m_zoomLevelElement.className = "harp-gl_controls-zoom";
        }
        if (options.disableDefaultStyle !== true) {
            this.initStyle();
            this.domElement.style.cssText =
                "position: absolute; right: 10px; top: 50%; margin-top: -70px;";
        }
        return this;
    }
    /**
     * Destroy this [[MapControlsUI]] instance. Unregisters all event handlers used. This method
     * should be called when you stop using [[MapControlsUI]].
     */
    dispose() {
        if (this.m_zoomLevelElement !== null && this.m_zoomLevelElement.tagName === "INPUT") {
            window.removeEventListener("click", this.m_onWindowClick);
        }
        this.controls.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);
        this.domElement.remove();
    }
    initStyle() {
        if (document.getElementById("here-harp-controls.map-controls-ui-styles") !== null) {
            return;
        }
        const style = document.createElement("style");
        style.id = "here-harp-controls.map-controls-ui-styles";
        style.appendChild(document.createTextNode(`
            .harp-gl_controls-button {
                display: block;
                background-color: #fff;
                width: 40px;
                height: 40px;
                font-size: 22px;
                font-weight: bold;
                outline: none;
                margin: 5px;
                border: none;
                color: #555;
                opacity: 0.87;
                cursor: pointer;
                border-radius: 4px;
                box-shadow: 0px 0px 4px #aaa;
                transition: all 0.1s;
                padding: 0 0 1px 1px;
                user-select: none;
            }
            .harp-gl_controls-button:active {
                background-color: #37afaa;
                color: #eee;
            }
            .harp-gl_controls-zoom {
                display: block;
                background-color: #fff;
                width: 40px;
                height: 20px;
                font-size: 12px;
                font-weight: bold;
                outline: none;
                margin: 5px;
                border: none;
                color: #555;
                opacity: 0.87;
                border-radius: 4px;
                box-shadow: 0px 0px 4px #aaa;
                padding: 2px 0 0;
                text-align: center;
                user-select: text;
            }
            input.harp-gl_controls-zoom::-webkit-outer-spin-button,
            input.harp-gl_controls-zoom::-webkit-inner-spin-button {
                /* display: none; <- Crashes Chrome on hover */
                -webkit-appearance: none;
                margin: 0; /* <-- Apparently some margin are still there even though it's hidden */
            }
            input.harp-gl_controls-zoom[type=number] {
                -moz-appearance:textfield; /* Firefox */
            }`));
        document.head.appendChild(style);
    }
}
exports.MapControlsUI = MapControlsUI;


/***/ }),

/***/ "./node_modules/@here/harp-map-controls/lib/Utils.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/lib/Utils.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const three_1 = __webpack_require__(/*! three */ "three");
/**
 * Transforms the given point in screen space into NDC space by taking the given screen dimension
 * into account.
 *
 * @param screenCoordinateX X coordinate in screen space.
 * @param screenCoordinateY Y coordinate in screen space.
 * @param screenSizeX Width of the reference screen size.
 * @param screenSizeY Height of the reference screen size.
 */
function calculateNormalizedDeviceCoordinates(screenCoordinateX, screenCoordinateY, screenSizeX, screenSizeY) {
    return new three_1.Vector2((screenCoordinateX / screenSizeX) * 2 - 1, -((screenCoordinateY / screenSizeY) * 2) + 1);
}
exports.calculateNormalizedDeviceCoordinates = calculateNormalizedDeviceCoordinates;
/**
 * Returns the azimuth and altitude in radians for the given direction vector.
 *
 * @param direction The direction vector. Does not have to be normalized.
 */
function directionToAzimuthAltitude(direction) {
    const normalizedDirection = direction.clone().normalize();
    //Shamelessly copied from Jan ;)
    const xy = new three_1.Vector2(normalizedDirection.x, normalizedDirection.y);
    const nxz = new three_1.Vector2(xy.length(), normalizedDirection.z).normalize();
    const azimuth = Math.atan2(xy.x, xy.y);
    const altitude = -Math.asin(nxz.y);
    return { azimuth, altitude };
}
exports.directionToAzimuthAltitude = directionToAzimuthAltitude;
/**
 * Returns the direction vector that is described by the given azimuth and altitude.
 *
 * @param azimuth Azimuth in radians.
 * @param altitude Altitude in radians.
 */
function azimuthAltitudeToDirection(azimuth, altitude) {
    azimuth = azimuth;
    altitude = altitude;
    //Shamelessly copied from Jan ;)
    const result = new three_1.Vector3();
    const cosAltitude = Math.cos(altitude);
    result.setX(Math.sin(azimuth) * cosAltitude);
    result.setY(Math.cos(azimuth) * cosAltitude);
    result.setZ(Math.sin(altitude));
    return result;
}
exports.azimuthAltitudeToDirection = azimuthAltitudeToDirection;
/**
 * Safely parses decimal value into `number`.
 *
 * Safely falls back to default value for `null`, `undefined`, `NaN`, empty strings, and strings
 * with characters other than digits.
 *
 * @param text Number as a text to be parsed.
 * @param fallback Default value, which is returned if `text` doesn't represent a valid number.
 */
function safeParseDecimalInt(text, fallback) {
    if (text === null || text === undefined || text === "") {
        return fallback;
    }
    if (!text.match(integerRe)) {
        return fallback;
    }
    const result = Number.parseInt(text, 10);
    if (isNaN(result)) {
        return fallback;
    }
    return result;
}
exports.safeParseDecimalInt = safeParseDecimalInt;
const integerRe = /^\d+$/;
/**
 * Extracts the CSS width and height of the given canvas if available, or width and height of the
 * canvas otherwise.
 *
 * @param canvas The canvas.
 */
function getWidthAndHeightFromCanvas(canvas) {
    return {
        //use clientWidth and clientHeight to support HiDPI devices
        width: safeParseDecimalInt(canvas.style.width, canvas.clientWidth),
        height: safeParseDecimalInt(canvas.style.height, canvas.clientHeight)
    };
}
exports.getWidthAndHeightFromCanvas = getWidthAndHeightFromCanvas;


/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/TileDataSource */ "./node_modules/@here/harp-mapview-decoder/lib/TileDataSource.js"));
__export(__webpack_require__(/*! ./lib/TileLoader */ "./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js"));


/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/lib/TileDataSource.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/lib/TileDataSource.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "./node_modules/@here/harp-mapview/index.js");
const harp_lrucache_1 = __webpack_require__(/*! @here/harp-lrucache */ "./node_modules/@here/harp-lrucache/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const TileLoader_1 = __webpack_require__(/*! ./TileLoader */ "./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js");
/**
 * Templated factory class to create instances of [[Tile]].
 */
class TileFactory {
    /**
     * Initialize the factory using the constructor of the element to be called when a [[Tile]] is
     * created.
     *
     * @param m_modelConstructor Constructor of (subclass of) [[Tile]].
     */
    constructor(m_modelConstructor) {
        this.m_modelConstructor = m_modelConstructor;
    }
    /**
     * Create an instance of (subclass of) [[Tile]]. The required parameters are passed as arguments
     * to the constructor of [[Tile]].
     *
     * @param dataSource [[Datasource]] this class belongs to.
     * @param tileKey Quadtree address of the [[Tile]].
     */
    create(dataSource, tileKey) {
        return new this.m_modelConstructor(dataSource, tileKey);
    }
}
exports.TileFactory = TileFactory;
const maxLevelTileLoaderCache = 3;
/**
 * Common base class for the typical [[DataSource]] which uses an [[ITileDecoder]] to decode the
 * tile content asynchronously. The decoder can be passed in as an option, or a default
 * asynchronous one is generated.
 */
class TileDataSource extends harp_mapview_1.DataSource {
    /**
     * Set up the `TileDataSource`.
     *
     * @param m_tileFactory Factory to create the [[Tile]] instances.
     * @param m_options Options specifying the parameters of the [[DataSource]].
     */
    constructor(m_tileFactory, m_options) {
        super(m_options.name, m_options.styleSetName, m_options.minZoomLevel, m_options.maxZoomLevel, m_options.storageLevelOffset);
        this.m_tileFactory = m_tileFactory;
        this.m_options = m_options;
        this.logger = harp_utils_1.LoggerManager.instance.create("TileDataSource");
        this.m_isReady = false;
        if (m_options.decoder) {
            this.m_decoder = m_options.decoder;
        }
        else if (m_options.concurrentDecoderServiceName) {
            this.m_decoder = harp_mapview_1.ConcurrentDecoderFacade.getTileDecoder(m_options.concurrentDecoderServiceName, m_options.concurrentDecoderScriptUrl);
        }
        else {
            throw new Error(`TileDataSource[${this.name}]: unable to create, missing decoder or ` +
                `concurrentDecoderServiceName`);
        }
        this.m_decoder.configure(undefined, undefined, {
            storageLevelOffset: this.m_options.storageLevelOffset
        });
        this.cacheable = true;
        this.m_tileLoaderCache = new harp_lrucache_1.LRUCache(this.getCacheCount());
    }
    dispose() {
        this.decoder.dispose();
    }
    ready() {
        return this.m_isReady && this.m_options.dataProvider.ready();
    }
    /**
     * Get the [[ITileDecoder]] of this `ITileDataSource`, which has either been passed in with
     * the options, or has been supplied by the [[ConcurrentDecoderFacade]].
     */
    get decoder() {
        return this.m_decoder;
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all([this.m_options.dataProvider.connect(), this.m_decoder.connect()]);
            this.m_isReady = true;
        });
    }
    setStyleSet(styleSet, languages) {
        this.m_tileLoaderCache.clear();
        this.m_decoder.configure(styleSet, languages);
        this.mapView.markTilesDirty(this);
    }
    /**
     * Get the [[DataProvider]] that has been passed in with the options.
     */
    dataProvider() {
        return this.m_options.dataProvider;
    }
    getTilingScheme() {
        return this.m_options.tilingScheme;
    }
    /**
     * Create a [[Tile]] and start the asynchronous download of the tile content. The [[Tile]] will
     * be empty, but the download and decoding will be scheduled immediately.
     *
     * @param tileKey Quadtree address of the requested tile.
     */
    getTile(tileKey) {
        const tile = this.m_tileFactory.create(this, tileKey);
        const mortonCode = tileKey.mortonCode();
        const tileLoader = this.m_tileLoaderCache.get(mortonCode);
        if (tileLoader !== undefined) {
            tile.tileLoader = tileLoader;
        }
        else {
            const newTileLoader = new TileLoader_1.TileLoader(this, tileKey, this.m_options.dataProvider, this.decoder, 0);
            tile.tileLoader = newTileLoader;
            // We don't cache tiles with level 4 and above, at this level, there are 16 (2^4) tiles
            // horizontally, given the assumption that the zoom level assumes the tile should be 256
            // pixels wide (see function [[calculateZoomLevelFromDistance]]), and the current
            // storage offset of -2 (which makes the tiles then 1024 pixels wide). this would mean a
            // horizontal width of ~16k pixels for the entire earth, this would be quite a lot to
            // pan, hence caching doesn't make sense above this point (as the chance that we need to
            // share the TileLoader is small, and even if we did eventually see it, the original
            // TileLoader would probably be evicted because it was removed by other more recent
            // tiles).
            if (tileKey.level <= maxLevelTileLoaderCache) {
                this.m_tileLoaderCache.set(mortonCode, newTileLoader);
            }
        }
        this.updateTile(tile);
        return tile;
    }
    updateTile(tile) {
        const tileLoader = tile.tileLoader;
        if (tileLoader === undefined) {
            return;
        }
        if (tileLoader.decodedTile !== undefined) {
            this.setDecodedTileOnTile(tileLoader.decodedTile, tile);
        }
        else {
            tileLoader
                .loadAndDecode()
                .then(tileLoaderState => {
                harp_utils_1.assert(tileLoaderState === harp_mapview_1.TileLoaderState.Ready);
                const decodedTile = tileLoader.decodedTile;
                this.setDecodedTileOnTile(decodedTile, tile);
            })
                .catch(tileLoaderState => {
                if (tileLoaderState !== harp_mapview_1.TileLoaderState.Canceled &&
                    tileLoaderState !== harp_mapview_1.TileLoaderState.Failed) {
                    this.logger.error("Unknown error" + tileLoaderState);
                }
            });
        }
    }
    /**
     * Get [[TileInfo]] of a tile.
     *
     * @param tileKey Quadtree address of the requested tile.
     * @returns A promise which will contain the [[TileInfo]] when resolved.
     */
    getTileInfo(tileKey) {
        const promise = new Promise((resolve, reject) => {
            const tileLoader = new TileLoader_1.TileInfoLoader(this, tileKey, this.m_options.dataProvider, this.decoder, 0);
            tileLoader.loadAndDecode().then(loaderState => {
                if (loaderState === harp_mapview_1.TileLoaderState.Ready) {
                    resolve(tileLoader.tileInfo);
                }
                else {
                    reject(new Error(`TileDataSource#getInfoTile wrong final state: ${loaderState}`));
                }
            });
        });
        return promise;
    }
    decodedTileHasGeometry(decodedTile) {
        return (decodedTile.geometries.length ||
            (decodedTile.poiGeometries !== undefined && decodedTile.poiGeometries.length) ||
            (decodedTile.textGeometries !== undefined && decodedTile.textGeometries.length) ||
            (decodedTile.textPathGeometries !== undefined && decodedTile.textPathGeometries.length));
    }
    getCacheCount() {
        // We support up to [[maxLevelTileLoaderCache]] levels, this equates to roughly
        // 2^maxLevelTileLoaderCache^2 tiles in total (at level maxLevelTileLoaderCache), we don't
        // generally see that many, so we add a factor of 2 to try to get the worst case.
        return Math.pow(2, maxLevelTileLoaderCache) * 2;
    }
    // Applies the decoded tile to the tile.
    // If the geometry is empty, then the tile's forceHasGeometry flag is set.
    // Map is updated.
    setDecodedTileOnTile(decodedTile, tile) {
        if (decodedTile && this.decodedTileHasGeometry(decodedTile)) {
            tile.copyrightInfo =
                decodedTile.copyrightHolderIds !== undefined
                    ? decodedTile.copyrightHolderIds.map(id => ({ id }))
                    : this.m_options.copyrightInfo;
            tile.setDecodedTile(decodedTile);
        }
        else {
            // empty tiles are traditionally ignored and don't need decode
            tile.forceHasGeometry(true);
        }
        this.requestUpdate();
    }
}
exports.TileDataSource = TileDataSource;


/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
__webpack_require__(/*! @here/harp-fetch */ "./node_modules/@here/harp-fetch/index.web.js");
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "./node_modules/@here/harp-mapview/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const logger = harp_utils_1.LoggerManager.instance.create("TileLoader");
/**
 * The [[TileLoader]] manages the different states of loading and decoding for a [[Tile]]. Used by
 * the [[TileDataSource]].
 *
 * A TileLoader supports loading for multiple tiles, this is required for the wrap around, where
 * it is possible to see the same tile multiple times.
 */
class TileLoader {
    /**
     * Set up loading of a single [[Tile]].
     *
     * @param dataSource The [[DataSource]] the tile belongs to.
     * @param tileKey The quadtree address of a [[Tile]].
     * @param dataProvider The [[DataProvider]] that retrieves the binary tile data.
     * @param tileDecoder The [[ITileDecoder]] that decodes the binary tile to a [[DecodeTile]].
     * @param priority The priority given to the loading job. Highest number will be served first.
     */
    constructor(dataSource, tileKey, dataProvider, tileDecoder, priority) {
        this.dataSource = dataSource;
        this.tileKey = tileKey;
        this.dataProvider = dataProvider;
        this.tileDecoder = tileDecoder;
        this.priority = priority;
        /**
         * Current state of `TileLoader`.
         */
        this.state = harp_mapview_1.TileLoaderState.Initialized;
        /**
         * The abort controller notifying the [[DataProvider]] to cancel loading.
         */
        this.loadAbortController = new AbortController();
        /**
         * This is a form of reference counting for the result. We keep a track of this because when
         * cancelling, it is important to know if we can actually cancel, or if there is another Tile
         * that needs the result.
         */
        this.countRequests = 0;
    }
    /**
     * Start loading and/or proceed through the various states of loading of this tile.
     *
     * @returns A promise which resolves the [[TileLoaderState]].
     */
    loadAndDecode() {
        switch (this.state) {
            case harp_mapview_1.TileLoaderState.Loading:
                this.countRequests++;
                return this.donePromise;
            case harp_mapview_1.TileLoaderState.Ready:
            case harp_mapview_1.TileLoaderState.Failed:
            case harp_mapview_1.TileLoaderState.Initialized:
            case harp_mapview_1.TileLoaderState.Canceled:
                this.countRequests++;
                this.ensureLoadingStarted();
                return this.donePromise;
            case harp_mapview_1.TileLoaderState.Loaded:
                this.countRequests++;
                this.startDecodeTile();
                return this.donePromise;
            case harp_mapview_1.TileLoaderState.Decoding:
                this.cancelDecoding();
                this.ensureLoadingStarted();
                return this.donePromise;
        }
    }
    /**
     * Return the current state in form of a promise. Caller can then wait for the promise to be
     * resolved.
     *
     * @returns A promise which resolves the current [[TileLoaderState]].
     */
    waitSettled() {
        if (!this.donePromise) {
            return Promise.resolve(this.state);
        }
        return this.donePromise;
    }
    /**
     * Cancel loading of the [[Tile]] if there is only a single request remaining. Cancellation
     * token is notified, an internal state is cleaned up.
     *
     * Otherwise this just reduces the count of requests by one.
     */
    cancel() {
        if (--this.countRequests !== 0) {
            return;
        }
        switch (this.state) {
            case harp_mapview_1.TileLoaderState.Loading:
                this.loadAbortController.abort();
                this.loadAbortController = new AbortController();
                break;
            case harp_mapview_1.TileLoaderState.Decoding:
                if (this.requestController) {
                    this.requestController.abort();
                    this.requestController = undefined;
                }
                break;
        }
        this.onDone(harp_mapview_1.TileLoaderState.Canceled);
    }
    /**
     * Return `true` if [[Tile]] is still loading, `false` otherwise.
     */
    get isFinished() {
        return (this.state === harp_mapview_1.TileLoaderState.Ready ||
            this.state === harp_mapview_1.TileLoaderState.Canceled ||
            this.state === harp_mapview_1.TileLoaderState.Failed);
    }
    /**
     * Update the priority of this [[Tile]]'s priority. Is effective to sort the decoding requests
     * in the request queue (used during heavy load).
     */
    updatePriority(priority) {
        this.priority = priority;
        if (this.requestController !== undefined) {
            this.requestController.priority = priority;
        }
    }
    /**
     * Depending on state: if not loaded yet, make sure it is loading.
     */
    ensureLoadingStarted() {
        switch (this.state) {
            case harp_mapview_1.TileLoaderState.Ready:
            case harp_mapview_1.TileLoaderState.Initialized:
            case harp_mapview_1.TileLoaderState.Canceled:
                this.doStartLoad();
                return;
            case harp_mapview_1.TileLoaderState.Loading:
            case harp_mapview_1.TileLoaderState.Loaded:
                // we may reuse already started loading promise
                logger.info("reusing already started load operation");
                return;
            case harp_mapview_1.TileLoaderState.Decoding:
                this.cancelDecoding();
                this.doStartLoad();
                return;
        }
    }
    /**
     * Start loading. Only call if loading did not start yet.
     */
    doStartLoad() {
        const myLoadCancellationToken = this.loadAbortController.signal;
        this.dataProvider
            .getTile(this.tileKey, myLoadCancellationToken)
            .then(payload => {
            if (myLoadCancellationToken.aborted) {
                // safety belt if getTile doesn't really support cancellation tokens
                const err = new Error("Aborted");
                err.name = "AbortError";
                throw err;
            }
            this.onLoaded(payload);
        })
            .catch(error => {
            // Handle abort messages from fetch and also our own.
            if (error.name === "AbortError" || error.message === "AbortError: Aborted") {
                return;
            }
            this.onError(error);
        });
        if (this.donePromise === undefined) {
            this.donePromise = new Promise((resolve, reject) => {
                this.resolveDonePromise = resolve;
                this.rejectedDonePromise = reject;
            });
        }
        this.state = harp_mapview_1.TileLoaderState.Loading;
    }
    /**
     * Called when binary data has been loaded. The loading state is now progressing to decoding.
     *
     * @param payload Binary data in form of [[ArrayBufferLike]], or any object.
     */
    onLoaded(payload) {
        this.state = harp_mapview_1.TileLoaderState.Loaded;
        this.payload = payload;
        if (payload.byteLength !== undefined) {
            if (payload.byteLength === 0) {
                this.onDone(harp_mapview_1.TileLoaderState.Ready);
                return;
            }
        }
        // Object is empty
        if (payload === {}) {
            this.onDone(harp_mapview_1.TileLoaderState.Ready);
            return;
        }
        // TBD: we might suspend decode if tile is not visible ... ?
        this.startDecodeTile();
    }
    /**
     * Start decoding the payload.
     */
    startDecodeTile() {
        const payload = this.payload;
        if (payload === undefined) {
            logger.error("TileLoader#startDecodeTile: Cannot decode without payload");
            return;
        }
        this.state = harp_mapview_1.TileLoaderState.Decoding;
        this.payload = undefined;
        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode
        // attempts
        const requestController = new harp_datasource_protocol_1.RequestController(this.priority);
        this.requestController = requestController;
        const dataSource = this.dataSource;
        this.tileDecoder
            .decodeTile(payload, this.tileKey, dataSource.projection, requestController)
            .then(decodedTile => {
            if (requestController.signal.aborted) {
                // our flow is cancelled, silently return
                return;
            }
            this.onDecoded(decodedTile);
        })
            .catch(error => {
            // Handle abort messages from fetch and also our own.
            if (error.name === "AbortError" || error.message === "AbortError: Aborted") {
                // our flow is cancelled, silently return
                return;
            }
            this.onError(error);
        });
    }
    /**
     * Called when the decoding is finished, and the [[DecodedTile]] has been created.
     *
     * @param decodedTile The [[DecodedTile]].
     */
    onDecoded(decodedTile) {
        this.decodedTile = decodedTile;
        this.onDone(harp_mapview_1.TileLoaderState.Ready);
    }
    /**
     * Cancel the decoding process.
     */
    cancelDecoding() {
        if (this.requestController !== undefined) {
            // we should cancel any decodes already in progress!
            this.requestController.abort();
            this.requestController = undefined;
        }
    }
    /**
     * Called when loading and decoding has finished successfully. Resolves loading promise if the
     * state is Ready, otherwise it rejects the promise with the supplied state.
     *
     * @param doneState The latest state of loading.
     */
    onDone(doneState) {
        if (this.resolveDonePromise && doneState === harp_mapview_1.TileLoaderState.Ready) {
            this.resolveDonePromise(doneState);
        }
        else if (this.rejectedDonePromise) {
            this.rejectedDonePromise(doneState);
        }
        this.resolveDonePromise = undefined;
        this.rejectedDonePromise = undefined;
        this.donePromise = undefined;
        this.state = doneState;
    }
    /**
     * Called when loading or decoding has finished with an error.
     *
     * @param error Error object describing the failing.
     */
    onError(error) {
        const dataSource = this.dataSource;
        logger.error(`[${dataSource.name}]: failed to load tile ${this.tileKey.toHereTile()}`, error);
        this.error = error;
        this.onDone(harp_mapview_1.TileLoaderState.Failed);
    }
}
exports.TileLoader = TileLoader;
/**
 * Subclass of [[TileLoader]] which is used by [[TileDataSource]] to load the [[TileInfo]] meta
 * data, not the tile data itself.
 */
class TileInfoLoader extends TileLoader {
    startDecodeTile() {
        const payload = this.payload;
        if (payload === undefined) {
            logger.error("TileInfoLoader#startDecodeTile: Cannot decode without payload");
            return;
        }
        this.state = harp_mapview_1.TileLoaderState.Decoding;
        this.payload = undefined;
        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode
        // attempts
        const requestController = new harp_datasource_protocol_1.RequestController(this.priority);
        this.requestController = requestController;
        const dataSource = this.dataSource;
        this.tileDecoder
            .getTileInfo(payload, this.tileKey, dataSource.projection, requestController)
            .then(tileInfo => {
            if (requestController.signal.aborted) {
                // our flow is cancelled, silently return
                return;
            }
            this.tileInfo = tileInfo;
            this.onDone(harp_mapview_1.TileLoaderState.Ready);
        })
            .catch(error => {
            // Handle abort messages from fetch and also our own.
            if (error.name === "AbortError" || error.message === "AbortError: Aborted") {
                // our flow is cancelled, silently return
                return;
            }
            this.onError(error);
        });
    }
}
exports.TileInfoLoader = TileInfoLoader;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@here/harp-mapview/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/AnimatedExtrusionHandler */ "./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js"));
__export(__webpack_require__(/*! ./lib/CameraMovementDetector */ "./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js"));
__export(__webpack_require__(/*! ./lib/ColorCache */ "./node_modules/@here/harp-mapview/lib/ColorCache.js"));
__export(__webpack_require__(/*! ./lib/composing */ "./node_modules/@here/harp-mapview/lib/composing/index.js"));
__export(__webpack_require__(/*! ./lib/ConcurrentDecoderFacade */ "./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js"));
__export(__webpack_require__(/*! ./lib/ConcurrentDecoderFacade */ "./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js"));
__export(__webpack_require__(/*! ./lib/ConcurrentTilerFacade */ "./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js"));
__export(__webpack_require__(/*! ./lib/ConcurrentTilerFacade */ "./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js"));
__export(__webpack_require__(/*! ./lib/CopyrightElementHandler */ "./node_modules/@here/harp-mapview/lib/CopyrightElementHandler.js"));
__export(__webpack_require__(/*! ./lib/CopyrightInfo */ "./node_modules/@here/harp-mapview/lib/CopyrightInfo.js"));
__export(__webpack_require__(/*! ./lib/DataSource */ "./node_modules/@here/harp-mapview/lib/DataSource.js"));
__export(__webpack_require__(/*! ./lib/DecodedTileHelpers */ "./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js"));
__export(__webpack_require__(/*! ./lib/DepthPrePass */ "./node_modules/@here/harp-mapview/lib/DepthPrePass.js"));
__export(__webpack_require__(/*! ./lib/ElevationRangeSource */ "./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js"));
__export(__webpack_require__(/*! ./lib/image/Image */ "./node_modules/@here/harp-mapview/lib/image/Image.js"));
__export(__webpack_require__(/*! ./lib/image/ImageCache */ "./node_modules/@here/harp-mapview/lib/image/ImageCache.js"));
__export(__webpack_require__(/*! ./lib/image/MapViewImageCache */ "./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js"));
__export(__webpack_require__(/*! ./lib/MapView */ "./node_modules/@here/harp-mapview/lib/MapView.js"));
__export(__webpack_require__(/*! ./lib/MapViewFog */ "./node_modules/@here/harp-mapview/lib/MapViewFog.js"));
__export(__webpack_require__(/*! ./lib/MapViewPoints */ "./node_modules/@here/harp-mapview/lib/MapViewPoints.js"));
__export(__webpack_require__(/*! ./lib/PickHandler */ "./node_modules/@here/harp-mapview/lib/PickHandler.js"));
__export(__webpack_require__(/*! ./lib/poi/Poi */ "./node_modules/@here/harp-mapview/lib/poi/Poi.js"));
__export(__webpack_require__(/*! ./lib/poi/PoiManager */ "./node_modules/@here/harp-mapview/lib/poi/PoiManager.js"));
__export(__webpack_require__(/*! ./lib/poi/PoiTableManager */ "./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js"));
__export(__webpack_require__(/*! ./lib/RoadPicker */ "./node_modules/@here/harp-mapview/lib/RoadPicker.js"));
__export(__webpack_require__(/*! ./lib/Statistics */ "./node_modules/@here/harp-mapview/lib/Statistics.js"));
__export(__webpack_require__(/*! ./lib/text/TextElement */ "./node_modules/@here/harp-mapview/lib/text/TextElement.js"));
__export(__webpack_require__(/*! ./lib/text/TextElementsRenderer */ "./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js"));
__export(__webpack_require__(/*! ./lib/text/TextStyleCache */ "./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js"));
__export(__webpack_require__(/*! ./lib/ThemeLoader */ "./node_modules/@here/harp-mapview/lib/ThemeLoader.js"));
__export(__webpack_require__(/*! ./lib/Tile */ "./node_modules/@here/harp-mapview/lib/Tile.js"));
__export(__webpack_require__(/*! ./lib/geometry/TileDataAccessor */ "./node_modules/@here/harp-mapview/lib/geometry/TileDataAccessor.js"));
__export(__webpack_require__(/*! ./lib/geometry/TileGeometry */ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js"));
__export(__webpack_require__(/*! ./lib/Utils */ "./node_modules/@here/harp-mapview/lib/Utils.js"));
__export(__webpack_require__(/*! ./lib/VisibleTileSet */ "./node_modules/@here/harp-mapview/lib/VisibleTileSet.js"));
__export(__webpack_require__(/*! ./lib/WorkerBasedDecoder */ "./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js"));
__export(__webpack_require__(/*! ./lib/WorkerBasedTiler */ "./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js"));
__export(__webpack_require__(/*! ./lib/workers/WorkerLoader */ "./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js"));


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const MapView_1 = __webpack_require__(/*! ./MapView */ "./node_modules/@here/harp-mapview/lib/MapView.js");
/**
 * Animation states for extrusion effect
 */
var AnimatedExtrusionState;
(function (AnimatedExtrusionState) {
    AnimatedExtrusionState[AnimatedExtrusionState["None"] = 0] = "None";
    AnimatedExtrusionState[AnimatedExtrusionState["Started"] = 1] = "Started";
    AnimatedExtrusionState[AnimatedExtrusionState["Playing"] = 2] = "Playing";
    AnimatedExtrusionState[AnimatedExtrusionState["Finished"] = 3] = "Finished";
})(AnimatedExtrusionState = exports.AnimatedExtrusionState || (exports.AnimatedExtrusionState = {}));
/**
 * Handles animated extrusion effect of the buildings in [[MapView]].
 */
class AnimatedExtrusionHandler {
    /**
     * Creates an [[AnimatedExtrusionHandler]] in [[MapView]].
     *
     * @param m_mapView Instance of [[MapView]] that passes `zoomLevel`
     * through the `zoom` poperty update
     */
    constructor(m_mapView) {
        this.m_mapView = m_mapView;
        /**
         * Animate the extrusion of the buildings if set to `true`.
         */
        this.enabled = true;
        /**
         * Duration of the building's extrusion in milliseconds
         */
        this.duration = 750;
        /**
         * If `forceEnabled` is set to `true` then `animateExtrusion` and `animateExtrusionDuration`
         * values from [[extrudedPolygonTechnique]] will be ignored in [[Tile]] and
         * `AnimatedExtrusionHandler.enabled` with `AnimatedExtrusionHandler.duration` will be used
         */
        this.forceEnabled = false;
        this.m_tileHandlerMap = new Map();
        this.m_zoomDirection = 0;
        this.m_zoomLevelPrevious = this.m_mapView.zoomLevel;
    }
    /**
     * Returns direction of the last zoom event.
     * Zoom in - positive value, zoom out - negative value
     */
    get zoomDirection() {
        return this.m_zoomDirection;
    }
    /**
     * [[MapView]] updates zoom level. Then [[AnimatedExtrusionTileHandler]] calculates actual
     * extrusion ratio and trigger animation
     */
    set zoom(zoomLevel) {
        // if zoomLevel has been changed since last render
        if (this.m_zoomLevelPrevious !== zoomLevel) {
            this.m_tileHandlerMap.forEach(tileHandler => {
                if (this.m_mapView.getDataSourceByName(tileHandler.tile.dataSource.name) !==
                    undefined) {
                    this.m_zoomDirection = zoomLevel > this.m_zoomLevelPrevious ? 1 : -1;
                    tileHandler.zoomLevelChanged(this.m_zoomDirection);
                }
            });
            this.m_zoomLevelPrevious = zoomLevel;
        }
    }
    /**
     * Checks whether animated extrusion effect was forcibly turned off/on in [[MapView]]
     */
    get forceAnimatedExtrusion() {
        return this.m_forceAnimatedExtrusion;
    }
    /**
     * If set to `true` it will force the animation extrusion effect to run.
     * In case it was set to `false` animation extrusion effect will be switched off.
     */
    set forceAnimatedExtrusion(animatedExtrusion) {
        this.m_forceAnimatedExtrusion = animatedExtrusion;
    }
    /**
     * Returns `animatedExtrusionDuration` value that was set in [[MapView]].
     */
    get forceAnimatedExtrusionDuration() {
        return this.m_forceAnimatedExtrusionDuration;
    }
    /**
     * If value is set, it will overlap in [[Tile]] with
     * `animatedExtrusionDuration` property from [[ExtrudedPolygonTechnique]]
     * and `DEFAULT_DURATION` from [[AnimatedExtrusionTileHandler]].
     */
    set forceAnimatedExtrusionDuration(extrusionDuration) {
        this.m_forceAnimatedExtrusionDuration = extrusionDuration;
    }
    /**
     * Adds an [[AnimatedExtrusionTileHandler]] to [[AnimatedExtrusionHandler]]
     */
    add(tileHandler) {
        this.m_tileHandlerMap.set(tileHandler.tile, tileHandler);
    }
    /**
     * Removes tile from the list subscribed for extrusion ratio updates
     */
    removeTile(tile) {
        this.m_tileHandlerMap.delete(tile);
    }
    /**
     * Returns first [[AnimatedExtrusionTileHandler]] existed from the list of [[Tile]]s
     */
    find(tileKeys) {
        for (const tileHandler of this.m_tileHandlerMap) {
            for (const tileKey of tileKeys) {
                if (tileKey !== undefined &&
                    tileHandler[0].tileKey.mortonCode() === tileKey.mortonCode()) {
                    return tileHandler[1];
                }
            }
        }
        return undefined;
    }
}
exports.AnimatedExtrusionHandler = AnimatedExtrusionHandler;
/**
 * Implements animated extrusion effect for the extruded objects in the [[Tile]]
 */
class AnimatedExtrusionTileHandler {
    constructor(m_tile, extrudedObjects, m_animatedExtrusionDuration) {
        this.m_tile = m_tile;
        this.m_animatedExtrusionDuration = m_animatedExtrusionDuration;
        this.m_extrudedObjects = [];
        this.m_animatedExtrusionRatio = AnimatedExtrusionTileHandler.DEFAULT_RATIO_MAX;
        this.m_animatedExtrusionState = AnimatedExtrusionState.None;
        this.m_animatedExtrusionStartTime = undefined;
        this.animateExtrusion = (event) => {
            if (this.m_animatedExtrusionState !== AnimatedExtrusionState.Playing) {
                if (this.m_animatedExtrusionState === AnimatedExtrusionState.Started) {
                    this.m_animatedExtrusionState = AnimatedExtrusionState.Playing;
                }
                else {
                    return;
                }
            }
            const currentTime = Date.now();
            if (this.m_animatedExtrusionStartTime === undefined ||
                this.m_animatedExtrusionStartTime <= 0) {
                this.m_animatedExtrusionStartTime = currentTime;
            }
            const timeProgress = Math.min(currentTime - this.m_animatedExtrusionStartTime, this.m_animatedExtrusionDuration);
            this.extrusionRatio = harp_utils_1.MathUtils.easeInOutCubic(AnimatedExtrusionTileHandler.DEFAULT_RATIO_MIN, AnimatedExtrusionTileHandler.DEFAULT_RATIO_MAX, timeProgress / this.m_animatedExtrusionDuration);
            if (timeProgress >= this.m_animatedExtrusionDuration) {
                this.m_animatedExtrusionState = AnimatedExtrusionState.Finished;
                this.stopExtrusionAnimation();
            }
            this.m_tile.dataSource.requestUpdate();
        };
        this.m_mapView = m_tile.mapView;
        this.m_animatedExtrusionHandler = this.m_mapView.animatedExtrusionHandler;
        extrudedObjects.forEach(extrudedObject => {
            if (extrudedObject.materialFeature) {
                harp_materials_1.ExtrusionFeature.addRenderHelper(extrudedObject.object);
            }
            this.m_extrudedObjects.push(extrudedObject.object);
        });
        this.startExtrusionAnimationIfNeeded(this.m_animatedExtrusionHandler.zoomDirection);
    }
    /**
     * Set an extrusion ratio value for the materials [[MapMeshBasicMaterial]]
     * and [[EdgeMaterial]]. Controlled by [[AnimatedExtrusionHandler]]
     * for extrusion animation effect.
     */
    set extrusionRatio(value) {
        this.m_animatedExtrusionRatio = value;
        this.m_extrudedObjects.forEach(object => {
            const material = object
                .material;
            material.extrusionRatio = this.m_animatedExtrusionRatio;
        });
    }
    /**
     * Returns the [[Tile]] related to [[AnimatedExtrusionTileHandler]]
     */
    get tile() {
        return this.m_tile;
    }
    /**
     * Return the current state of animated extrusion effect
     */
    get animationState() {
        return this.m_animatedExtrusionState;
    }
    /**
     * Cancel animation and remove from [[AnimatedExtrusionHandler]]
     */
    dispose() {
        this.stopExtrusionAnimation();
        this.m_animatedExtrusionHandler.removeTile(this.m_tile);
    }
    /**
     * Start / Stop extrusion animation if zoom level was changed
     */
    zoomLevelChanged(zoomDirection) {
        if (this.m_tile.isVisible === false &&
            this.m_animatedExtrusionState !== AnimatedExtrusionState.None) {
            this.m_animatedExtrusionState = AnimatedExtrusionState.None;
            this.stopExtrusionAnimation();
        }
        if (this.m_tile.isVisible === true &&
            this.m_animatedExtrusionState === AnimatedExtrusionState.None) {
            this.startExtrusionAnimationIfNeeded(zoomDirection);
        }
    }
    getChildTiles(tileKeys) {
        let result = [];
        tileKeys.forEach(tileKey => {
            const dataSource = this.tile.dataSource;
            const childTileKeys = dataSource.getTilingScheme().getSubTileKeys(tileKey);
            result = result.concat(childTileKeys);
        });
        return result;
    }
    // search for the [[Tile]] with extrusion animation started
    startExtrusionAnimationIfNeeded(zoomDirection) {
        const { quadTreeSearchDistanceUp, quadTreeSearchDistanceDown } = this.tile.mapView.visibleTileSet.options;
        const tile = this.m_tile;
        let extrusionStartTime;
        if (zoomDirection !== undefined) {
            let tileHandler;
            // if zoom out, go down and look for a child tile
            if (zoomDirection < 0) {
                let nextLevelDiff = 0;
                let tileKeys = [tile.tileKey];
                while (quadTreeSearchDistanceDown > nextLevelDiff &&
                    extrusionStartTime === undefined) {
                    const childTileKeys = this.getChildTiles(tileKeys);
                    if (childTileKeys !== undefined) {
                        tileHandler = this.m_animatedExtrusionHandler.find(childTileKeys);
                        if (tileHandler !== undefined) {
                            extrusionStartTime = tileHandler.m_animatedExtrusionStartTime;
                            break;
                        }
                        tileKeys = childTileKeys;
                    }
                    nextLevelDiff++;
                }
            }
            // if zoom in, go up and get the parent tile
            if (zoomDirection > 0) {
                let nextLevelDiff = 0;
                let tileKey = tile.tileKey;
                while (quadTreeSearchDistanceUp > nextLevelDiff &&
                    extrusionStartTime === undefined &&
                    tileKey.level !== 0) {
                    const parentTileKey = tileKey.parent();
                    tileHandler = this.m_animatedExtrusionHandler.find([parentTileKey]);
                    if (tileHandler !== undefined) {
                        extrusionStartTime = tileHandler.m_animatedExtrusionStartTime;
                        break;
                    }
                    tileKey = parentTileKey;
                    nextLevelDiff++;
                }
            }
        }
        this.startExtrusionAnimation(extrusionStartTime);
    }
    startExtrusionAnimation(startTime) {
        this.m_animatedExtrusionState = AnimatedExtrusionState.Started;
        this.m_animatedExtrusionStartTime = startTime;
        this.animateExtrusion();
        this.m_mapView.addEventListener(MapView_1.MapViewEventNames.AfterRender, this.animateExtrusion);
    }
    stopExtrusionAnimation() {
        this.m_mapView.removeEventListener(MapView_1.MapViewEventNames.AfterRender, this.animateExtrusion);
    }
}
/**
 * Minimum ratio value for extrusion effect
 */
AnimatedExtrusionTileHandler.DEFAULT_RATIO_MIN = 0.001;
/**
 * Maximum ratio value for extrusion effect
 */
AnimatedExtrusionTileHandler.DEFAULT_RATIO_MAX = 1;
exports.AnimatedExtrusionTileHandler = AnimatedExtrusionTileHandler;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const three_1 = __webpack_require__(/*! three */ "three");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-mapview/lib/Utils.js");
/**
 * The default value for camera movement throttling, in milliseconds.
 */
const DEFAULT_THROTTLING_TIMEOUT = 300;
/**
 * The `CameraMovementDetector` class checks for changes in camera position and orientation, to
 * detect continuous movements without the animation mode activated in [[MapView]]. If the
 * interaction is not continuous enough, you can use a throttling timer to reduce the number of
 * callbacks.
 */
class CameraMovementDetector {
    /**
     * Initializes the detector with timeout value and callbacks. [[MapView]] also provides
     * events for client code to be notified when these cues occur.
     *
     * @param m_throttlingTimeout The delay, in milliseconds, between the last user interaction
     * detected and the call to `m_movementFinishedFunc`; the default is `300`.
     * @param m_movementStartedFunc Callback function, called when the user starts interacting.
     * @param m_movementFinishedFunc Callback function, called when the user stops interacting.
     */
    constructor(m_throttlingTimeout, m_movementStartedFunc, m_movementFinishedFunc) {
        this.m_throttlingTimeout = m_throttlingTimeout;
        this.m_movementStartedFunc = m_movementStartedFunc;
        this.m_movementFinishedFunc = m_movementFinishedFunc;
        this.m_lastCameraPos = new three_1.Vector3();
        this.m_newCameraPos = new three_1.Vector3();
        this.m_throttlingTimerId = undefined;
        this.m_movementDetectorDeadline = 0;
        this.onDeadlineTimer = () => {
            this.m_throttlingTimerId = undefined;
            const now = performance.now();
            if (now >= this.m_movementDetectorDeadline) {
                this.movementFinished();
            }
            else {
                this.startMovementFinishedTimer(now);
            }
        };
        if (this.m_throttlingTimeout === undefined) {
            this.m_throttlingTimeout = DEFAULT_THROTTLING_TIMEOUT;
        }
    }
    /**
     * Checks if the camera has moved since the last time it was checked. The
     * `m_movementStartedFunc` is called when a movement starts. If no movement
     * is detected, a timer for `m_movementFinishedFunc` starts.
     *
     * @param mapView [[Mapview]]'s position and camera are checked for modifications.
     */
    checkCameraMoved(mapView, now) {
        const newYawPitchRoll = Utils_1.MapViewUtils.extractYawPitchRoll(mapView.camera.quaternion);
        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);
        const cameraMoved = this.m_lastYawPitchRoll === undefined ||
            !this.m_lastCameraPos.equals(newCameraPos) ||
            newYawPitchRoll.yaw !== this.m_lastYawPitchRoll.yaw ||
            newYawPitchRoll.pitch !== this.m_lastYawPitchRoll.pitch ||
            newYawPitchRoll.roll !== this.m_lastYawPitchRoll.roll;
        if (cameraMoved) {
            this.m_lastCameraPos.copy(newCameraPos);
            this.m_lastYawPitchRoll = newYawPitchRoll;
        }
        if (cameraMoved !== this.m_cameraMovedLastFrame) {
            if (cameraMoved) {
                this.movementStarted();
            }
            this.m_cameraMovedLastFrame = cameraMoved;
        }
        if (cameraMoved) {
            // Start timer
            this.m_movementDetectorDeadline = now + this.m_throttlingTimeout;
            this.startMovementFinishedTimer(now);
        }
        return this.m_cameraMovedLastFrame;
    }
    /**
     * Reset the saved camera position. Next time checkCameraMoved is called, it will return
     * `false`.
     */
    clear(mapView) {
        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);
        this.m_lastCameraPos.set(newCameraPos.x, newCameraPos.y, newCameraPos.z);
    }
    /**
     * Force change of camera position. Next time checkCameraMoved is called, it will return `true`.
     */
    forceMoved() {
        this.m_lastCameraPos.set(Number.NaN, Number.NaN, Number.NaN);
    }
    /**
     * Returns `true` if the camera of this [[MapView]] is currently moving. In this case the
     * `m_movementFinishedFunc` is waiting to be called after the throttling timer runs out.
     */
    get cameraIsMoving() {
        return this.m_throttlingTimerId !== undefined;
    }
    /**
     * Disposes resources and kills the throttling timer.
     */
    dispose() {
        this.removeMovementFinishedTimer();
        this.m_movementStartedFunc = undefined;
        this.m_movementFinishedFunc = undefined;
    }
    /**
     * Returns `true` if the camera has moved in the last frame.
     */
    get cameraMovedLastFrame() {
        return this.m_cameraMovedLastFrame === true;
    }
    movementStarted() {
        if (this.m_movementStartedFunc !== undefined) {
            this.m_movementStartedFunc();
        }
    }
    movementFinished() {
        this.removeMovementFinishedTimer();
        if (this.m_movementFinishedFunc !== undefined) {
            this.m_movementFinishedFunc();
        }
    }
    startMovementFinishedTimer(now) {
        if (this.m_throttlingTimerId === undefined) {
            const remainingTime = Math.max(0, this.m_movementDetectorDeadline - now);
            this.m_throttlingTimerId = setTimeout(this.onDeadlineTimer, remainingTime);
        }
    }
    removeMovementFinishedTimer() {
        if (this.m_throttlingTimerId !== undefined) {
            clearTimeout(this.m_throttlingTimerId);
            this.m_throttlingTimerId = undefined;
        }
    }
}
exports.CameraMovementDetector = CameraMovementDetector;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ColorCache.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ColorCache.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Use `ColorCache` to reuse a color specified by name and save allocation as well as
 * setup time.
 *
 * Implemented as a singleton. Do not modify colors after getting them from the `ColorCache`.
 */
class ColorCache {
    constructor() {
        this.m_map = new Map();
    }
    /**
     * Return instance of `ColorCache`.
     */
    static get instance() {
        return this.m_instance;
    }
    /**
     * Returns the color for the given `colorCode`. This function may reuse a previously generated
     * color, so you cannot modify the contents of the color.
     *
     * @param colorCode ThreeJS color code or name. You must provide a valid color code or name,
     * as this function does not do any validation.
     */
    getColor(colorCode) {
        let color = this.m_map.get(colorCode);
        if (color !== undefined) {
            return color;
        }
        color = new THREE.Color(colorCode);
        this.m_map.set(colorCode, color);
        return color;
    }
    /**
     * Returns the number of elements in the cache.
     */
    get size() {
        return this.m_map.size;
    }
    /**
     * Clears the cache. Only references to the THREE.Color are removed from the cache.
     * Consequently, clearing the cache does not cause any negative visual impact.
     */
    clear() {
        this.m_map.clear();
    }
}
ColorCache.m_instance = new ColorCache();
exports.ColorCache = ColorCache;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ConcurrentWorkerSet_1 = __webpack_require__(/*! ./ConcurrentWorkerSet */ "./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js");
const WorkerBasedDecoder_1 = __webpack_require__(/*! ./WorkerBasedDecoder */ "./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js");
/**
 * Default concurrent decoder helper.
 *
 * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle
 * requested. Provides easy access to [[WorkerBasedDecoder]]s for data sources.
 */
class ConcurrentDecoderFacade {
    /**
     * Returns a [[WorkerBasedDecoder]] instance.
     *
     * @param decoderServiceType The name of the decoder service type.
     * @param scriptUrl The optional URL with the workers' script.
     */
    static getTileDecoder(decoderServiceType, scriptUrl) {
        const workerSet = this.getWorkerSet(scriptUrl);
        return new WorkerBasedDecoder_1.WorkerBasedDecoder(workerSet, decoderServiceType);
    }
    /**
     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.
     *
     * @param scriptUrl The optional URL with the workers' script. If not specified,
     * the function uses [[defaultScriptUrl]] instead.
     */
    static getWorkerSet(scriptUrl) {
        if (scriptUrl === undefined) {
            scriptUrl = this.defaultScriptUrl;
        }
        let workerSet = this.workerSets[scriptUrl];
        if (workerSet === undefined) {
            workerSet = new ConcurrentWorkerSet_1.ConcurrentWorkerSet({
                scriptUrl,
                workerCount: this.defaultWorkerCount
            });
            this.workerSets[scriptUrl] = workerSet;
        }
        return workerSet;
    }
    /**
     * Destroys a [[ConcurrentWorkerSet]] instance.
     *
     * @param scriptUrl The worker script URL that was used to create the [[ConcurrentWorkerSet]].
     */
    static destroyWorkerSet(scriptUrl) {
        const workerSet = this.workerSets[scriptUrl];
        if (workerSet !== undefined) {
            workerSet.destroy();
            delete this.workerSets[scriptUrl];
        }
    }
    /**
     * Destroys all managed [[ConcurrentWorkerSet]]s.
     */
    static destroy() {
        Object.keys(this.workerSets).forEach(name => {
            this.workerSets[name].destroy();
        });
        this.workerSets = {};
    }
}
/**
 * The URL containing a script to fall back (default) to when looking for worker sets
 * and decoders.
 */
ConcurrentDecoderFacade.defaultScriptUrl = "./decoder.bundle.js";
/**
 * The default number of workers.
 */
ConcurrentDecoderFacade.defaultWorkerCount = undefined;
/**
 * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.
 */
ConcurrentDecoderFacade.workerSets = {};
exports.ConcurrentDecoderFacade = ConcurrentDecoderFacade;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ConcurrentWorkerSet_1 = __webpack_require__(/*! ./ConcurrentWorkerSet */ "./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js");
const WorkerBasedTiler_1 = __webpack_require__(/*! ./WorkerBasedTiler */ "./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js");
/**
 * Default concurrent tiler helper.
 *
 * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle
 * requested. Provides easy access to [[WorkerBasedTiler]]s for data sources.
 */
class ConcurrentTilerFacade {
    /**
     * Returns a [[WorkerBasedTiler]] instance.
     *
     * @param tilerServiceType The name of the tiler service type.
     * @param scriptUrl The optional URL with the workers' script.
     */
    static getTiler(tilerServiceType, scriptUrl) {
        const workerSet = this.getWorkerSet(scriptUrl);
        return new WorkerBasedTiler_1.WorkerBasedTiler(workerSet, tilerServiceType);
    }
    /**
     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.
     *
     * @param scriptUrl The optional URL with the workers' script. If not specified,
     * the function uses [[defaultScriptUrl]] instead.
     */
    static getWorkerSet(scriptUrl) {
        if (scriptUrl === undefined) {
            scriptUrl = this.defaultScriptUrl;
        }
        let workerSet = this.workerSets[scriptUrl];
        if (workerSet === undefined) {
            workerSet = new ConcurrentWorkerSet_1.ConcurrentWorkerSet({
                scriptUrl,
                workerCount: this.defaultWorkerCount
            });
            this.workerSets[scriptUrl] = workerSet;
        }
        return workerSet;
    }
    /**
     * Destroys a [[ConcurrentWorkerSet]] instance.
     *
     * @param scriptUrl The worker script URL that was used to create the [[ConcurrentWorkerSet]].
     */
    static destroyWorkerSet(scriptUrl) {
        const workerSet = this.workerSets[scriptUrl];
        if (workerSet !== undefined) {
            workerSet.destroy();
            delete this.workerSets[scriptUrl];
        }
    }
    /**
     * Destroys all managed [[ConcurrentWorkerSet]]s.
     */
    static destroy() {
        Object.keys(this.workerSets).forEach(name => {
            this.workerSets[name].destroy();
        });
        this.workerSets = {};
    }
}
/**
 * The URL containing a script to fall back (default) to when looking for worker sets
 * and tilers.
 */
ConcurrentTilerFacade.defaultScriptUrl = "./decoder.bundle.js";
/**
 * The default number of workers.
 */
ConcurrentTilerFacade.defaultWorkerCount = 1;
/**
 * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.
 */
ConcurrentTilerFacade.workerSets = {};
exports.ConcurrentTilerFacade = ConcurrentTilerFacade;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const WorkerLoader_1 = __webpack_require__(/*! ./workers/WorkerLoader */ "./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js");
const logger = harp_utils_1.LoggerManager.instance.create("ConcurrentWorkerSet");
function isLoggingMessage(message) {
    return message && typeof message.level === "number" && message.type === harp_utils_1.WORKERCHANNEL_MSG_TYPE;
}
exports.isLoggingMessage = isLoggingMessage;
/**
 * The default number of Web Workers to use if `navigator.hardwareConcurrency` is unavailable.
 */
const DEFAULT_WORKER_COUNT = 4;
/**
 * A set of concurrent Web Workers. Acts as a Communication Peer for [[WorkerService]] instances
 * running in Web Workers.
 *
 * Starts and manages a certain number of web workers and provides a means to communicate
 * with them using various communication schemes, such as:
 *  - [[addEventListener]] : receive a unidirectional messages
 *  - [[broadcastMessage]] : send unidirectional broadcast message
 *  - [[invokeRequest]] : send a request that waits for a response, with load balancing
 *  - [[postMessage]] : send a unidirectional message, with load balancing
 *
 * The request queue holds all requests before they are stuffed into the event queue, allows for
 * easy (and early) cancelling of requests. The workers now only get a single new RequestMessage
 * when they return their previous result, or if they are idle. When they are idle, they are stored
 * in m_availableWorkers.
 */
class ConcurrentWorkerSet {
    /**
     * Creates a new `ConcurrentWorkerSet`.
     *
     * Creates as many Web Workers as specified in `options.workerCount`, from the script provided
     * in `options.scriptUrl`. If `options.workerCount` is not specified, the value specified in
     * `navigator.hardwareConcurrency` is used instead.
     *
     * The worker set is implicitly started when constructed.
     */
    constructor(m_options) {
        this.m_options = m_options;
        this.m_workerChannelLogger = harp_utils_1.LoggerManager.instance.create("WorkerChannel");
        this.m_eventListeners = new Map();
        this.m_workers = new Array();
        this.m_workerListeners = new Array();
        // List of idle workers that can be given the next job. It is using a LIFO scheme to reduce
        // memory consumption in idle workers.
        this.m_availableWorkers = new Array();
        this.m_workerPromises = new Array();
        this.m_readyPromises = new Map();
        this.m_requests = new Map();
        this.m_workerRequestQueue = [];
        this.m_nextMessageId = 0;
        this.m_stopped = true;
        this.m_referenceCount = 0;
        /**
         * Handles messages received from workers. This method is protected so that the message
         * reception can be simulated through an extended class, to avoid relying on real workers.
         *
         * @param workerId The workerId of the web worker.
         * @param event The event to dispatch.
         */
        this.onWorkerMessage = (workerId, event) => {
            if (harp_datasource_protocol_1.WorkerServiceProtocol.isResponseMessage(event.data)) {
                const response = event.data;
                if (response.messageId === null) {
                    logger.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: no messageId`);
                    return;
                }
                const entry = this.m_requests.get(response.messageId);
                if (entry === undefined) {
                    logger.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: invalid messageId`);
                    return;
                }
                if (workerId >= 0 && workerId < this.m_workers.length) {
                    const worker = this.m_workers[workerId];
                    this.m_availableWorkers.push(worker);
                    // Check if any new work has been put into the queue.
                    this.checkWorkerRequestQueue();
                }
                else {
                    logger.error(`[${this.m_options.scriptUrl}]: onWorkerMessage: invalid workerId`);
                }
                entry.resolver(response.error, response.response);
            }
            else if (harp_datasource_protocol_1.WorkerServiceProtocol.isInitializedMessage(event.data)) {
                const readyPromise = this.getReadyPromise(event.data.service);
                if (++readyPromise.count === this.m_workerPromises.length) {
                    readyPromise.resolve();
                }
            }
            else if (isLoggingMessage(event.data)) {
                switch (event.data.level) {
                    case harp_utils_1.LogLevel.Trace:
                        this.m_workerChannelLogger.trace(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Debug:
                        this.m_workerChannelLogger.debug(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Log:
                        this.m_workerChannelLogger.log(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Info:
                        this.m_workerChannelLogger.info(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Warn:
                        this.m_workerChannelLogger.warn(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Error:
                        this.m_workerChannelLogger.error(...event.data.message);
                        break;
                }
            }
            else {
                this.eventHandler(event);
            }
        };
        this.start();
    }
    /**
     * Adds an external reference and increments the internal reference counter by one.
     *
     * To implement a reference-count based automatic resource cleanup, use this function with
     * [[removeReference]].
     */
    addReference() {
        this.m_referenceCount += 1;
    }
    /**
     * Decrements the internal reference counter by 1.
     *
     * When the internal reference counter reaches 0, this function calls [[dispose]] to clear the
     * resources.
     *
     * Use with [[addReference]] to implement reference-count based automatic resource cleanup.
     */
    removeReference() {
        this.m_referenceCount -= 1;
        if (this.m_referenceCount === 0) {
            this.destroy();
        }
    }
    /**
     * Starts workers.
     *
     * Use to start workers already stopped by [[stop]] or [[destroy]] calls.
     *
     * Note: The worker set is implicitly started on construction - no need to call [[start]] on
     * fresh instance.
     *
     * @param options optional, new worker set options
     */
    start(options) {
        if (options !== undefined) {
            this.m_options = options;
        }
        if (!this.m_stopped) {
            throw new Error("ConcurrentWorker set already started");
        }
        const workerCount = harp_utils_1.getOptionValue(this.m_options.workerCount, typeof navigator !== "undefined" && navigator.hardwareConcurrency !== undefined
            ? // We need to have at least one worker
                harp_utils_1.MathUtils.clamp(navigator.hardwareConcurrency - 1, 1, 4)
            : undefined, DEFAULT_WORKER_COUNT);
        // Initialize the workers. The workers now have an ID to identify specific workers and
        // handle their busy state.
        for (let workerId = 0; workerId < workerCount; ++workerId) {
            const workerPromise = WorkerLoader_1.WorkerLoader.startWorker(this.m_options.scriptUrl);
            workerPromise
                .then(worker => {
                const listener = (evt) => {
                    this.onWorkerMessage(workerId, evt);
                };
                this.m_workerListeners.push(listener);
                worker.addEventListener("message", listener);
                this.m_workers.push(worker);
                this.m_availableWorkers.push(worker);
            })
                .catch(error => {
                logger.error(`failed to load worker ${workerId}: ${error}`);
            });
            this.m_workerPromises.push(workerPromise);
        }
        this.m_stopped = false;
    }
    /**
     * Stops workers.
     *
     * Waits for all pending requests to be finished and stops all workers.
     *
     * Use [[start]] to start this worker again.
     *
     * @returns `Promise` that resolves when all workers are destroyed.
     */
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            this.m_stopped = true;
            yield this.waitForAllResponses().then(() => {
                this.terminateWorkers();
            });
        });
    }
    /**
     * Destroys all workers immediately.
     *
     * Resolves all pending request promises with a `worker destroyed` error.
     *
     * Use [[start]] to start this worker again.
     */
    destroy() {
        this.m_stopped = true;
        // respond with all pending request
        this.m_requests.forEach(entry => {
            entry.resolver(new Error("worker destroyed"));
        });
        this.m_requests.clear();
        this.terminateWorkers();
        // clean other stuff
        this.m_eventListeners.clear();
    }
    /**
     * Waits for `service` to be initialized in all workers.
     *
     * Each service that starts in a worker sends an [[isInitializedMessage]] to confirm that
     * it has started successfully. This method resolves when all workers in a set have
     * `service` initialized.
     *
     * @param serviceId The service identifier.
     */
    connect(serviceId) {
        this.ensureStarted();
        return this.getReadyPromise(serviceId).promise;
    }
    /**
     * Registers an event listener for events that originated in a web worker, for a given
     * `serviceId`. You can only set one event listener per `serviceId`.
     *
     * @param serviceId The service to listen to.
     * @param callback The callback to invoke for matching events.
     */
    addEventListener(serviceId, callback) {
        this.m_eventListeners.set(serviceId, callback);
    }
    /**
     * Removes a previously set event listener for the given `serviceId`.
     *
     * @param serviceId The service from which to remove the event listeners.
     */
    removeEventListener(serviceId) {
        this.m_eventListeners.delete(serviceId);
    }
    /**
     * Invokes a request that expects a response from a random worker.
     *
     * Sends [[RequestMessage]] and resolves when a matching [[ResponseMessage]] is received from
     * workers. Use this function when interfacing with "RPC-like" calls to services.
     *
     * @param serviceId The name of service, as registered with the [[WorkerClient]] instance.
     * @param request The request to process.
     * @param transferList An optional array of `ArrayBuffer`s to transfer to the worker context.
     * @param requestController An optional [[RequestController]] to store state of cancelling.
     *
     * @returns A `Promise` that resolves with a response from the service.
     */
    invokeRequest(serviceId, request, transferList, requestController) {
        this.ensureStarted();
        const messageId = this.m_nextMessageId++;
        let resolver;
        const promise = new Promise((resolve, reject) => {
            resolver = (error, response) => {
                this.m_requests.delete(messageId);
                if (error !== undefined) {
                    reject(new Error(error.toString()));
                }
                else {
                    resolve(response);
                }
            };
        });
        this.m_requests.set(messageId, {
            promise,
            resolver: resolver
        });
        const message = {
            service: serviceId,
            type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Request,
            messageId,
            request
        };
        this.postRequestMessage(message, transferList, requestController);
        return promise;
    }
    /**
     * Invokes a request that expects responses from all workers.
     *
     * Send [[RequestMessage]]  to all workers and resolves when all workers have sent a matching
     * [[ResponseMessage]]. Use this function to wait on request that need to happen on all workers
     * before proceeding (like synchronous worker service creation).
     *
     * @param serviceId The name of service, as registered with the [[WorkerClient]] instance.
     * @param request The request to process.
     * @param transferList An optional array of `ArrayBuffer`s to transfer to the worker context.
     *
     * @returns Array of `Promise`s that resolves with a response from each worker (unspecified
     * order).
     */
    broadcastRequest(serviceId, request, transferList) {
        this.ensureStarted();
        const promises = [];
        for (const worker of this.m_workers) {
            const messageId = this.m_nextMessageId++;
            let resolver;
            const promise = new Promise((resolve, reject) => {
                resolver = (error, response) => {
                    this.m_requests.delete(messageId);
                    if (error !== undefined) {
                        reject(new Error(error.toString()));
                    }
                    else {
                        resolve(response);
                    }
                };
            });
            promises.push(promise);
            this.m_requests.set(messageId, {
                promise,
                resolver: resolver
            });
            const message = {
                service: serviceId,
                type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Request,
                messageId,
                request
            };
            if (transferList !== undefined) {
                worker.postMessage(message, transferList);
            }
            else {
                worker.postMessage(message);
            }
        }
        return Promise.all(promises);
    }
    /**
     * Posts a message to all workers.
     *
     * @param message The message to send.
     * @param buffers Optional buffers to transfer to the workers.
     */
    broadcastMessage(message, buffers) {
        this.ensureStarted();
        if (buffers !== undefined) {
            this.m_workers.forEach(worker => worker.postMessage(message, buffers));
        }
        else {
            this.m_workers.forEach(worker => worker.postMessage(message));
        }
    }
    /**
     * The size of the request queue for debugging and profiling.
     */
    get requestQueueSize() {
        return this.m_workerRequestQueue.length;
    }
    /**
     * The number of workers for debugging and profiling.
     */
    get numWorkers() {
        return this.m_workers.length;
    }
    /**
     * The number of workers for debugging and profiling.
     */
    get numIdleWorkers() {
        return this.m_availableWorkers.length;
    }
    /**
     * Subclasses must call this function when a worker emits an event.
     *
     * @param event The event to dispatch.
     */
    eventHandler(event) {
        if (typeof event.data.type !== "string") {
            return; // not an event generated by us, ignore.
        }
        this.dispatchEvent(event.data.type, event);
    }
    /**
     * Posts a [[WorkerServiceProtocol.RequestMessage]] to an available worker. If no worker is
     * available, the request is put into a queue.
     *
     * @param message The message to send.
     * @param buffers Optional buffers to transfer to the worker.
     * @param requestController An optional [[RequestController]] to store state of cancelling.
     */
    postRequestMessage(message, buffers, requestController) {
        this.ensureStarted();
        if (this.m_workers.length === 0) {
            throw new Error("ConcurrentWorkerSet#postMessage: no workers started");
        }
        // Check if the requestController has received the abort signal, in which case the request
        // is ignored.
        if (requestController !== undefined && requestController.signal.aborted) {
            const entry = this.m_requests.get(message.messageId);
            if (entry === undefined) {
                logger.error(`[${this.m_options.scriptUrl}]: Bad RequesMessage: invalid messageId`);
                return;
            }
            const err = new Error("Aborted");
            err.name = "AbortError";
            entry.resolver(err, undefined);
            return;
        }
        if (this.m_availableWorkers.length > 0) {
            const worker = this.m_availableWorkers.pop();
            if (buffers !== undefined) {
                worker.postMessage(message, buffers);
            }
            else {
                worker.postMessage(message);
            }
        }
        else {
            // We need a priority to keep sorting stable, so we have to add a RequestController.
            if (requestController === undefined) {
                requestController = new harp_datasource_protocol_1.RequestController(0);
            }
            if (requestController.priority === 0) {
                // If the requests do not get a priority, they should keep their sorting order.
                requestController.priority = -this.m_nextMessageId;
            }
            this.m_workerRequestQueue.unshift({
                message,
                buffers,
                requestController
            });
        }
    }
    ensureStarted() {
        if (this.m_stopped) {
            throw new Error("ConcurrentWorkerSet stopped");
        }
    }
    waitForAllResponses() {
        return __awaiter(this, void 0, void 0, function* () {
            const promises = new Array();
            this.m_requests.forEach(entry => {
                promises.push(entry.promise);
            });
            yield Promise.all(promises);
        });
    }
    dispatchEvent(id, message) {
        const callback = this.m_eventListeners.get(id);
        if (callback === undefined) {
            return;
        } // unknown event, ignore.
        callback(message);
    }
    terminateWorkers() {
        // terminate all workers
        this.m_workerPromises.forEach(workerPromise => {
            workerPromise
                .then(worker => {
                const workerId = this.m_workers.indexOf(worker);
                if (workerId >= 0) {
                    const listener = this.m_workerListeners[workerId];
                    worker.removeEventListener("message", listener);
                }
                else {
                    logger.error(
                    // tslint:disable-next-line: max-line-length
                    `[${this.m_options.scriptUrl}]: ConcurrentWorkerSet#terminateWorkers: invalid workerId`);
                }
                worker.terminate();
            })
                .catch(() => {
                // we ignore exception here, as it's already logged in #start and terminate is
                // noop if worker didn't start at all
            });
        });
        this.m_workers = [];
        this.m_workerListeners = [];
        this.m_workerPromises = [];
        this.m_availableWorkers = [];
        this.m_readyPromises.clear();
    }
    getReadyPromise(id) {
        const readyPromise = this.m_readyPromises.get(id);
        if (readyPromise !== undefined) {
            return readyPromise;
        }
        const newPromise = {
            count: 0,
            promise: undefined,
            resolve: () => {
                /* placeholder */
            },
            reject: (error) => {
                newPromise.error = error;
            },
            error: undefined
        };
        newPromise.promise = new Promise((resolve, reject) => {
            const that = newPromise;
            if (that.error !== undefined) {
                reject(that.error);
            }
            else if (that.count === this.m_workerPromises.length) {
                resolve();
            }
            that.resolve = resolve;
            that.reject = reject;
        });
        this.m_readyPromises.set(id, newPromise);
        return newPromise;
    }
    /**
     * Check the worker request queue, if there are any queued up decoding jobs and idle workers,
     * they will be executed with postRequestMessage. The requests in the queue are sorted before
     * the request with the highest priority is selected for processing.
     */
    checkWorkerRequestQueue() {
        if (this.m_workerRequestQueue.length === 0 || this.m_availableWorkers.length === 0) {
            return;
        }
        this.m_workerRequestQueue.sort((a, b) => {
            return a.requestController.priority - b.requestController.priority;
        });
        // Get the request with the highest priority and send it (again).
        while (this.m_availableWorkers.length > 0 && this.m_workerRequestQueue.length > 0) {
            const request = this.m_workerRequestQueue.pop();
            this.postRequestMessage(request.message, request.buffers, request.requestController);
        }
    }
}
exports.ConcurrentWorkerSet = ConcurrentWorkerSet;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/CopyrightElementHandler.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/CopyrightElementHandler.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const CopyrightInfo_1 = __webpack_require__(/*! ./CopyrightInfo */ "./node_modules/@here/harp-mapview/lib/CopyrightInfo.js");
const MapView_1 = __webpack_require__(/*! ./MapView */ "./node_modules/@here/harp-mapview/lib/MapView.js");
/**
 * Helper class that maintains up-to-date [[MapView]] copyright information in DOM element.
 *
 * @example
 *
 *     // HTML snippet
 *     <div id="copyrightNotice" style="position:absolute; right:0; bottom:0; z-index:100"></div>
 *
 *     // Javascript
 *     const mapView = new MapView({ ... });
 *     CopyrightElementHandler.attach("copyrightNotice", mapView);
 */
class CopyrightElementHandler {
    /**
     * Creates a new `CopyrightElementHandler` that updates the DOM element with the copyright info
     * of the given `mapView`.
     *
     * Note: Generally, the static [[install]] method can be used to create and attach a new
     * `CopyrightElementHandler` to a [[MapView]]
     *
     * @param elementId HTML DOM element or a HTML DOM element id
     * @param mapView optional, [[attach]] to this [[MapView]] instance
     */
    constructor(element, mapView) {
        this.m_defaults = new Map();
        this.m_mapViews = [];
        /**
         * Update copyright info text in controlled HTML element.
         */
        this.update = () => {
            const mergedCopyrightInfo = this.m_mapViews
                .map(mapView => mapView.copyrightInfo)
                .reduce(CopyrightInfo_1.CopyrightInfo.mergeArrays, this.staticInfo || []);
            // Conditionally hiding of element with copyright information.
            // If nothing to show we schould to avoid empty white rectangle in right bottom corner.
            if (mergedCopyrightInfo.length === 0) {
                this.m_element.style.display = "none";
                return;
            }
            else {
                this.m_element.style.display = "block";
            }
            if (this.m_defaults.size !== 0) {
                for (const sourceInfo of mergedCopyrightInfo) {
                    const defaults = this.m_defaults.get(sourceInfo.id);
                    if (defaults !== undefined) {
                        sourceInfo.year = harp_utils_1.getOptionValue(sourceInfo.year, defaults.year);
                        sourceInfo.label = harp_utils_1.getOptionValue(sourceInfo.label, defaults.label);
                        sourceInfo.link = harp_utils_1.getOptionValue(sourceInfo.link, defaults.link);
                    }
                }
            }
            const deduped = CopyrightInfo_1.CopyrightInfo.mergeArrays(mergedCopyrightInfo);
            this.m_element.innerHTML = CopyrightInfo_1.CopyrightInfo.formatAsHtml(deduped);
        };
        if (typeof element === "string") {
            this.m_element = document.getElementById(element);
            if (!this.m_element) {
                throw new Error(`CopyrightElementHandler: unable to find DOM element ${element}`);
            }
        }
        else {
            this.m_element = element;
        }
        if (mapView !== undefined) {
            this.attach(mapView);
        }
    }
    /**
     * Install [[CopyrightElementHandler]] on DOM element and - optionally - attach to a [[MapView]]
     * instance.
     *
     * @param element HTML DOM element or a HTML DOM element id
     * @param mapView, optional, [[attach]] to this [[MapView]]
     */
    static install(element, mapView) {
        return new CopyrightElementHandler(element, mapView);
    }
    /**
     * Destroys this object by removing all event listeners from the attached [[MapView]]s.
     */
    destroy() {
        for (const mapView of this.m_mapViews) {
            mapView.removeEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);
        }
    }
    /**
     * Attaches this [[CopyrightInfo]] updates from [[MapView]] instance.
     */
    attach(mapView) {
        this.m_mapViews.push(mapView);
        mapView.addEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);
        this.update();
        return this;
    }
    /**
     * Stop following [[CopyrightInfo]] updates from [[MapView]] instance.
     */
    detach(mapView) {
        mapView.removeEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);
        this.m_mapViews = this.m_mapViews.filter(item => item !== mapView);
        this.update();
        return this;
    }
    /**
     * Set [[CopyrightInfo]] defaults to be used in case [[DataSource]] does not provide deatailed
     * copyright information.
     *
     * The defaults will applied to all undefined `year`, `label` and `link` values in the copyright
     * information retrieved from [[MapView]].
     */
    setDefaults(defaults) {
        this.m_defaults.clear();
        if (defaults !== undefined) {
            for (const item of defaults) {
                this.m_defaults.set(item.id, item);
            }
        }
        return this;
    }
    /**
     * Sets the [[staticInfo]] property.
     *
     * A `CopyrightElementHandler` always displays a deduplicated sum of static copyright info and
     * copyright information obtained from attached [[MapView]]s.
     *
     * This information is used when [[DataSource]] instances of given [[MapView]] do not provide
     * copyright information.
     */
    setStaticCopyightInfo(staticInfo) {
        this.staticInfo = staticInfo;
        return this;
    }
}
exports.CopyrightElementHandler = CopyrightElementHandler;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/CopyrightInfo.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/CopyrightInfo.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
var CopyrightInfo;
(function (CopyrightInfo) {
    /**
     * Merge [[CopyrightInfo]] arrays, removing duplicates.
     *
     * `id` and `label` are considered keys in deduplication algorithm.
     *
     * @param sources non-duplicate elements from this array are added to `target`
     * @returns merge of all copyright infos in `sources`
     */
    function mergeArrays(a, b) {
        const result = [];
        for (const source of [a, b]) {
            if (source === undefined) {
                continue;
            }
            for (const sourceInfo of source) {
                const existingInfo = result.find(findItem => findItem.id === sourceInfo.id ||
                    (findItem.label !== undefined && findItem.label === sourceInfo.label));
                if (existingInfo === undefined) {
                    result.push(Object.assign({}, sourceInfo));
                }
                else {
                    existingInfo.year = harp_utils_1.MathUtils.max2(sourceInfo.year, existingInfo.year);
                    existingInfo.label = harp_utils_1.getOptionValue(sourceInfo.label, existingInfo.label);
                    existingInfo.link = harp_utils_1.getOptionValue(sourceInfo.link, existingInfo.link);
                }
            }
        }
        return result;
    }
    CopyrightInfo.mergeArrays = mergeArrays;
    /**
     * Format copyright information to a HTML string that can be displayed in the UI.
     *
     * * Empty list returns empty string.
     * * Entries with empty (but defined) labels are skipped.
     */
    function formatAsHtml(copyrightInfo) {
        if (copyrightInfo.length === 0) {
            return "";
        }
        const filtered = copyrightInfo.filter(entry => entry.label !== "");
        if (filtered.length === 0) {
            return "";
        }
        return ("© " +
            filtered
                .map(entry => {
                const label = entry.label !== undefined ? entry.label : entry.id;
                const text = entry.year !== undefined ? `${entry.year} ${label}` : label;
                return entry.link ? `<a href="${entry.link}">${text}</a>` : `${text}`;
            })
                .join(", "));
    }
    CopyrightInfo.formatAsHtml = formatAsHtml;
})(CopyrightInfo = exports.CopyrightInfo || (exports.CopyrightInfo = {}));


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DataSource.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DataSource.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const UPDATE_EVENT = { type: "update" };
/**
 * Derive a class from `DataSource` to contribute data and geometries to the [[MapView]].
 */
class DataSource extends THREE.EventDispatcher {
    /**
     * Constructs a new `DataSource`.
     *
     * @param uniqueName A unique name that represents this `DataSource`.
     * @param styleSetName The name of the [[StyleSet]] to refer to in a [[Theme]], to decode vector
     * tiles.
     * @param minZoomLevel Minimum zoom level this `DataSource` can be displayed in.
     * @param maxZoomLevel Maximum zoom level this `DataSource` can be displayed in.
     * @param storageLevelOffset Storage level offset applied to this `DataSource`.
     */
    constructor(uniqueName, styleSetName, minZoomLevel, maxZoomLevel, storageLevelOffset) {
        super();
        /**
         * Set to `true` if this `DataSource` is enabled; `false` otherwise.
         */
        this.enabled = true;
        /**
         * Set to `true` if the [[MapView]] can cache tiles produced by this `DataSource`.
         */
        this.cacheable = false;
        /**
         * If `true` or `undefined`, a geometry for every tile is generated. The background has the size
         * of the covered tile area. It is required to clear the area of a tile. It is also used to
         * identify the tile during picking operations. If no tile background is generated, a tile
         * cannot be identified during picking if no geometry is defined at the picking location. To be
         * able to pick the tile with the help of the tile background, tile background does not have to
         * be visible (set `tileBackgroundIsVisible` to `false`).
         */
        this.addTileBackground = true;
        /**
         * If defined, this option defines the color of the tile background. If it is `undefined`, the
         * [[MapView.clearColor]] defined in the [[Theme]] is used.
         */
        this.tileBackgroundColor = undefined;
        /**
         * If set to `true`, and if `addTileBackground` is true, the background is actually rendered. If
         * set to `false` or `undefined`, the background is only used for picking, but is not rendered,
         * but only used for picking.
         */
        this.tileBackgroundIsVisible = false;
        /**
         * Minimum zoom level this `DataSource` can be displayed in.
         */
        this.m_minZoomLevel = 1;
        /**
         * Maximum zoom level this `DataSource` can be displayed in.
         */
        this.m_maxZoomLevel = 20;
        /**
         * Storage level offset applied to this `DataSource`.
         */
        this.m_storageLevelOffset = 0;
        if (uniqueName === undefined || uniqueName.length === 0) {
            uniqueName = `anonymous-datasource#${++DataSource.uniqueNameCounter}`;
        }
        this.name = uniqueName;
        this.styleSetName = styleSetName;
        if (minZoomLevel !== undefined) {
            this.m_minZoomLevel = minZoomLevel;
        }
        if (maxZoomLevel !== undefined) {
            this.m_maxZoomLevel = maxZoomLevel;
        }
        if (storageLevelOffset !== undefined) {
            this.m_storageLevelOffset = storageLevelOffset;
        }
    }
    /**
     * Returns the name of the [[StyleSet]] to use for the decoding.
     */
    get styleSetName() {
        return this.m_styleSetName;
    }
    /**
     * Sets the name of the [[StyleSet]] to use for the decoding. If this [[DataSource]] is already
     * attached to a [[MapView]], this setter then looks for a [[StyleSet]] with this name and
     * applies it.
     */
    set styleSetName(styleSetName) {
        this.m_styleSetName = styleSetName;
        if (this.m_mapView !== undefined &&
            styleSetName !== undefined &&
            this.m_mapView.theme.styles !== undefined) {
            this.setStyleSet(this.m_mapView.theme.styles[styleSetName]);
        }
    }
    /**
     * Destroys this `DataSource`.
     */
    dispose() {
        // to be overloaded by subclasses
    }
    /**
     * Returns `true` if this `DataSource` is ready and the [[MapView]] can invoke `getTile()` to
     * start requesting data.
     */
    ready() {
        return true;
    }
    /**
     * The [[MapView]] that is holding this `DataSource`.
     */
    get mapView() {
        if (this.m_mapView === undefined) {
            throw new Error("This DataSource was not added to MapView");
        }
        return this.m_mapView;
    }
    /**
     * The [[Projection]] used by the [[MapView]] that is holding this `DataSource`.
     *
     * An `Error` is thrown if you call this method before this `DataSource` has been added
     * to a [[MapView]].
     */
    get projection() {
        return this.mapView.projection;
    }
    /**
     * This method is called when the `DataSource` is added to a [[MapView]]. Reimplement this
     * method to provide any custom initialization, such as, to establish a network connection,
     * or to initialize complex data structures.
     */
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            // to be overloaded by subclasses
        });
    }
    /**
     * This method is called when this `DataSource` is added to a [[MapView]].
     *
     * Reimplementations of this method must invoke the definition of the super class.
     *
     * @param mapView The instance of the [[MapView]].
     */
    attach(mapView) {
        this.m_mapView = mapView;
    }
    /**
     * This method is called when this `DataSource` is removed from a [[MapView]].
     *
     * Reimplementations of this method must invoke the definition of the super class.
     *
     * @param mapView The instance of the [[MapView]].
     */
    detach(mapView) {
        harp_utils_1.assert(this.m_mapView === mapView);
        this.m_mapView = undefined;
    }
    /**
     * Invoked by [[MapView]] to notify when the [[Theme]] has been changed.
     *
     * If `DataSource` depends on a theme, it must update its tiles' geometry.
     *
     * @param styleSet The new theme that [[MapView]] uses.
     * @param languages An optional list of languages for the `DataSource`.
     */
    // tslint:disable-next-line:no-unused-variable
    setStyleSet(styleSet, languages) {
        // to be overwritten by subclasses
    }
    /**
     * Used to configure the languages used by the `DataSource` according to priority;
     * the first language in the array has the highest priority.
     *
     * @param languages An array of ISO 639-1 language codes.
     */
    setLanguages(languages) {
        // to be overloaded by subclasses
    }
    /**
     * This method is called by [[MapView]] before the tile needs to be updated, for example after
     * a theme change.
     *
     * @param tile The [[Tile]] to update.
     */
    // tslint:disable-next-line:no-unused-variable
    updateTile(tile) {
        // to be overloaded by subclasses
    }
    /**
     * This method is called by the [[MapView]] to determine if the content of the surrounding
     * tiles must be preloaded.
     *
     * @returns `true` if the [[MapView]] should try to preload tiles surrounding the visible
     * tiles; `false` otherwise. The default is `false`.
     */
    shouldPreloadTiles() {
        return false;
    }
    /**
     * The minimum zoom level to use for display.
     *
     * @returns The minimum zoom level to use for display.
     */
    get minZoomLevel() {
        return this.m_minZoomLevel;
    }
    set minZoomLevel(level) {
        this.m_minZoomLevel = level;
    }
    /**
     * The maximum zoom level to use for display.
     */
    get maxZoomLevel() {
        return this.m_maxZoomLevel;
    }
    set maxZoomLevel(level) {
        this.m_maxZoomLevel = level;
    }
    /**
     * The difference between storage level and display level of tile.
     *
     * Storage level offset is a value applied (added) to current zoom level giving
     * a final tile level being displayed. This way we may differentate current
     * zoom level from the storage level that is displayed, giving fine grained
     * control over the tiles being decoded an displayed.
     */
    get storageLevelOffset() {
        return this.m_storageLevelOffset;
    }
    /**
     * Setup the relative offset between storage level and display level of tile.
     *
     * @param levelOffset Difference between zoom level and display level.
     */
    set storageLevelOffset(levelOffset) {
        this.m_storageLevelOffset = levelOffset;
    }
    /**
     * Computes the zoom level to use for display.
     *
     * @param zoomLevel The zoom level of the [[MapView]].
     * @returns The zoom level to use for display.
     */
    getDisplayZoomLevel(zoomLevel) {
        return THREE.Math.clamp(zoomLevel + this.m_storageLevelOffset, this.m_minZoomLevel, this.m_maxZoomLevel);
    }
    /**
     * Returns `true` if [[MapView]] should render the tile with given [[TileKey]] and zoom level.
     *
     * @param zoomLevel The zoom level of the [[MapView]].
     * @param tileKey The unique identifier for a map tile.
     * @returns `true` if the geometries created for the given [[TileKey]] should be rendered.
     */
    shouldRender(zoomLevel, tileKey) {
        return tileKey.level === zoomLevel;
    }
    /**
     * Returns `true` if [[MapView]] should render the text elements with the given [[TileKey]] and
     * zoom level.
     *
     * This is an additional check for the tiles that are already selected for rendering so the
     * default implementation returns `true`.
     *
     * @param zoomLevel The zoom level.
     * @param tileKey The unique identifier for a map tile.
     * @returns `true` if the text elements created for the given [[TileKey]] should be rendered.
     */
    // tslint:disable-next-line:no-unused-variable
    shouldRenderText(zoomLevel, tileKey) {
        return true;
    }
    /**
     * Sends a request to the [[MapView]] to redraw the scene.
     */
    requestUpdate() {
        this.dispatchEvent(UPDATE_EVENT);
    }
}
/**
 * A counter to generate unique names for each `DataSource`, if no name is provided in the
 * constructor.
 */
DataSource.uniqueNameCounter = 0;
exports.DataSource = DataSource;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DebugContext.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DebugContext.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const isNode = typeof window === "undefined";
/**
 * A `DebugOption` is a pair that consists of an option value and an array of change listeners.
 * Listeners are called up when setting the option's value.
 */
class DebugOption extends THREE.EventDispatcher {
    /**
     * Constructs the `DebugOption`.
     *
     * @param value The value of the option.
     */
    constructor(value) {
        super();
        this.value = value;
    }
    /**
     * Updates the value of a given option.
     *
     * @param value The new value for the option.
     * @param name The name of the option to set.
     */
    set(value, name) {
        this.value = value;
        this.dispatchEvent({ type: DebugOption.SET_EVENT_TYPE, name, value });
    }
}
DebugOption.SET_EVENT_TYPE = "set";
/**
 * Maintains a map of [[DebugOption]]s. You can add listeners to debug options by passing their
 * names.
 */
class DebugContext {
    /**
     * Builds a `DebugContext`.
     */
    constructor() {
        this.m_optionsMap = new Map();
        // If we have a `window` object, we store the context in it to make it available in the
        // console.
        if (!isNode && typeof window !== "undefined" && window) {
            const debugInfo = window;
            debugInfo.__debugContext = this;
        }
    }
    /**
     * Sets the value of an option. Calls change listeners of that option, even if the value has
     * not been changed. The change listeners provided here are not called during this set
     * operation.
     *
     * @param name Name of the option.
     * @param value Value of the option.
     */
    setValue(name, value) {
        let opt = this.m_optionsMap.get(name);
        if (!opt) {
            opt = new DebugOption(value);
            this.m_optionsMap.set(name, opt);
        }
        else {
            opt.set(value, name);
        }
    }
    /**
     * Gets the option value.
     *
     * @param name Name of option.
     */
    getValue(name) {
        const opt = this.m_optionsMap.get(name);
        return opt ? opt.value : undefined;
    }
    /**
     * Determines if the option is registered.
     *
     * @param name Name of option.
     */
    hasOption(name) {
        return this.m_optionsMap.get(name) !== undefined;
    }
    /**
     * Adds a listener to a debug option.
     *
     * @param name Name of the option that requires a listener.
     * @param listener The listener function to add.
     */
    addEventListener(name, listener) {
        const opt = this.m_optionsMap.get(name);
        if (opt) {
            opt.addEventListener(DebugOption.SET_EVENT_TYPE, listener);
        }
        else {
            throw Error("Unknown option: " + name);
        }
    }
    /**
     * Checks for a listener in a debug option.
     *
     * @param name Name of the option to check for.
     * @param listener The listener function to check for.
     */
    hasEventListener(name, listener) {
        const opt = this.m_optionsMap.get(name);
        if (opt) {
            return opt.hasEventListener(DebugOption.SET_EVENT_TYPE, listener);
        }
        else {
            throw Error("Unknown option: " + name);
        }
    }
    /**
     * Removes a listener from a debug option.
     *
     * @param name Name of the option from which to remove a listener.
     * @param listener The listener function to remove.
     */
    removeEventListener(name, listener) {
        const opt = this.m_optionsMap.get(name);
        if (opt) {
            opt.removeEventListener(DebugOption.SET_EVENT_TYPE, listener);
        }
        else {
            throw Error("Unknown option: " + name);
        }
    }
    /**
     * Provides access to the options map. This method is useful for creating an automatic
     * browser GUI.
     */
    get options() {
        return this.m_optionsMap;
    }
    /**
     * Clears away all debug options. Currently, `THREE.EventDispatcher` does not provide an API
     * to remove all event listeners.
     */
    clear() {
        this.m_optionsMap.forEach(option => {
            option.set(undefined, "");
        });
    }
}
exports.DebugContext = DebugContext;
exports.debugContext = new DebugContext();


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const MapViewPoints_1 = __webpack_require__(/*! ./MapViewPoints */ "./node_modules/@here/harp-mapview/lib/MapViewPoints.js");
const ThemeHelpers_1 = __webpack_require__(/*! ./ThemeHelpers */ "./node_modules/@here/harp-mapview/lib/ThemeHelpers.js");
const logger = harp_utils_1.LoggerManager.instance.create("DecodedTileHelpers");
const DEFAULT_SKIP_PROPERTIES = [
    ...harp_datasource_protocol_1.TEXTURE_PROPERTY_KEYS,
    "mapProperties",
    "normalMapProperties",
    "displacementMapProperties",
    "roughnessMapProperties",
    "emissiveMapProperties",
    "alphaMapProperties",
    "metalnessMapProperties",
    "bumpMapProperties"
];
/**
 * Create a material, depending on the rendering technique provided in the options.
 *
 * @param options The material options the subsequent functions need.
 * @param materialUpdateCallback Optional callback when the material gets updated,
 *                               e.g. after texture loading.
 *
 * @returns new material instance that matches `technique.name`
 */
function createMaterial(options, textureReadyCallback) {
    const technique = options.technique;
    const Constructor = getMaterialConstructor(technique);
    const settings = {};
    if (Constructor === undefined) {
        return undefined;
    }
    if (Constructor.prototype instanceof THREE.RawShaderMaterial &&
        Constructor !== harp_materials_1.HighPrecisionLineMaterial) {
        settings.fog = options.fog;
    }
    const material = new Constructor(settings);
    if (technique.id !== undefined) {
        material.name = technique.id;
    }
    if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
        material.flatShading = true;
    }
    material.depthTest = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && technique.depthTest !== false;
    if (harp_datasource_protocol_1.isStandardTechnique(technique) ||
        harp_datasource_protocol_1.isTerrainTechnique(technique) ||
        harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
        harp_datasource_protocol_1.TEXTURE_PROPERTY_KEYS.forEach((texturePropertyName) => {
            const textureProperty = technique[texturePropertyName];
            if (textureProperty === undefined) {
                return;
            }
            const onLoad = (texture) => {
                const properties = technique[texturePropertyName + "Properties"];
                if (properties !== undefined) {
                    if (properties.wrapS !== undefined) {
                        texture.wrapS = ThemeHelpers_1.toWrappingMode(properties.wrapS);
                    }
                    if (properties.wrapT !== undefined) {
                        texture.wrapT = ThemeHelpers_1.toWrappingMode(properties.wrapT);
                    }
                    if (properties.magFilter !== undefined) {
                        texture.magFilter = ThemeHelpers_1.toTextureFilter(properties.magFilter);
                    }
                    if (properties.minFilter !== undefined) {
                        texture.minFilter = ThemeHelpers_1.toTextureFilter(properties.minFilter);
                    }
                    if (properties.flipY !== undefined) {
                        texture.flipY = properties.flipY;
                    }
                    if (properties.repeatU !== undefined) {
                        texture.repeat.x = properties.repeatU;
                    }
                    if (properties.repeatV !== undefined) {
                        texture.repeat.y = properties.repeatV;
                    }
                }
                material[texturePropertyName] = texture;
                texture.needsUpdate = true;
                material.needsUpdate = true;
                if (textureReadyCallback) {
                    textureReadyCallback(texture);
                }
            };
            const onError = (error) => {
                logger.error("#createMaterial: Failed to load texture: ", error);
            };
            let textureUrl;
            if (typeof textureProperty === "string") {
                textureUrl = textureProperty;
            }
            else if (harp_datasource_protocol_1.isTextureBuffer(textureProperty)) {
                if (textureProperty.type === "image/raw") {
                    const properties = textureProperty.dataTextureProperties;
                    if (properties !== undefined) {
                        const textureDataType = properties.type
                            ? ThemeHelpers_1.toTextureDataType(properties.type)
                            : undefined;
                        const textureBuffer = getTextureBuffer(textureProperty.buffer, textureDataType);
                        const texture = new THREE.DataTexture(textureBuffer, properties.width, properties.height, properties.format ? ThemeHelpers_1.toPixelFormat(properties.format) : undefined, textureDataType);
                        onLoad(texture);
                    }
                    else {
                        onError("no data texture properties provided.");
                    }
                }
                else {
                    const textureBlob = new Blob([textureProperty.buffer], {
                        type: textureProperty.type
                    });
                    textureUrl = URL.createObjectURL(textureBlob);
                }
            }
            if (textureUrl) {
                new THREE.TextureLoader().load(textureUrl, onLoad, undefined, // onProgress
                onError);
            }
        });
    }
    if (harp_datasource_protocol_1.isShaderTechnique(technique)) {
        // special case for ShaderTechnique.
        // The shader technique takes the argument from its `params' member.
        const params = technique.params;
        Object.getOwnPropertyNames(params).forEach(property => {
            const prop = property;
            if (prop === "name") {
                // skip reserved property names
                return;
            }
            const m = material;
            if (m[prop] instanceof THREE.Color) {
                m[prop].set(params[prop]);
            }
            else {
                m[prop] = params[prop];
            }
        });
    }
    else {
        applyTechniqueToMaterial(technique, material, options.level, options.skipExtraProps);
    }
    return material;
}
exports.createMaterial = createMaterial;
/**
 * Returns a [[THREE.BufferAttribute]] created from a provided [[BufferAttribute]] object.
 *
 * @param attribute BufferAttribute a WebGL compliant buffer
 */
function getBufferAttribute(attribute) {
    switch (attribute.type) {
        case "float":
            return new THREE.BufferAttribute(new Float32Array(attribute.buffer), attribute.itemCount);
        case "uint16":
            return new THREE.BufferAttribute(new Uint16Array(attribute.buffer), attribute.itemCount);
        case "uint32":
            return new THREE.BufferAttribute(new Uint32Array(attribute.buffer), attribute.itemCount);
        default:
            throw new Error(`unsupported buffer of type ${attribute.type}`);
    } // switch
}
exports.getBufferAttribute = getBufferAttribute;
/**
 * Gets the default `three.js` object constructor associated with the given technique.
 *
 * @param technique The technique.
 */
function getObjectConstructor(technique) {
    if (technique.name === undefined) {
        return undefined;
    }
    switch (technique.name) {
        case "extruded-line":
        case "standard":
        case "terrain":
        case "extruded-polygon":
        case "fill":
        case "solid-line":
        case "dashed-line":
            return THREE.Mesh;
        case "circles":
            return MapViewPoints_1.Circles;
        case "squares":
            return MapViewPoints_1.Squares;
        case "line":
            return THREE.LineSegments;
        case "segments":
            return THREE.LineSegments;
        case "shader": {
            if (!harp_datasource_protocol_1.isShaderTechnique(technique)) {
                throw new Error("Invalid technique");
            }
            switch (technique.primitive) {
                case "line":
                    return THREE.Line;
                case "segments":
                    return THREE.LineSegments;
                case "point":
                    return THREE.Points;
                case "mesh":
                    return THREE.Mesh;
                default:
                    return undefined;
            }
        }
        case "text":
        case "labeled-icon":
        case "line-marker":
            return undefined;
    }
}
exports.getObjectConstructor = getObjectConstructor;
/**
 * Non material properties of [[BaseTechnique]]
 */
exports.BASE_TECHNIQUE_NON_MATERIAL_PROPS = [
    "name",
    "id",
    "renderOrder",
    "renderOrderBiasProperty",
    "renderOrderBiasGroup",
    "renderOrderBiasRange",
    "transient"
];
/**
 * Returns a [[MaterialConstructor]] basing on provided technique object.
 *
 * @param technique [[Technique]] object which the material will be based on.
 */
function getMaterialConstructor(technique) {
    if (technique.name === undefined) {
        return undefined;
    }
    switch (technique.name) {
        case "extruded-line":
            if (!harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {
                throw new Error("Invalid extruded-line technique");
            }
            return technique.shading === "standard"
                ? harp_materials_1.MapMeshStandardMaterial
                : harp_materials_1.MapMeshBasicMaterial;
        case "standard":
        case "terrain":
        case "extruded-polygon":
            return harp_materials_1.MapMeshStandardMaterial;
        case "solid-line":
            return harp_materials_1.SolidLineMaterial;
        case "dashed-line":
            return harp_materials_1.DashedLineMaterial;
        case "fill":
            return harp_materials_1.MapMeshBasicMaterial;
        case "squares":
            return THREE.PointsMaterial;
        case "circles":
            return harp_materials_1.CirclePointsMaterial;
        case "line":
        case "segments":
            return THREE.LineBasicMaterial;
        case "shader":
            return THREE.ShaderMaterial;
        case "text":
        case "labeled-icon":
        case "line-marker":
            return undefined;
    }
}
exports.getMaterialConstructor = getMaterialConstructor;
/**
 * Apply generic technique parameters to material.
 *
 * Skips non-material [[Technique]] props:
 *  * [[BaseTechnique]] props,
 *  * `name` which is used as discriminator for technique types,
 *  * props starting with `_`
 *  * props found `skipExtraProps`
 *
 * `THREE.Color` properties are supported.
 *
 * @param technique technique from where params are copied
 * @param material target material
 * @param level optional, tile zoom level for zoom-level dependent props
 * @param skipExtraProps optional, skipped props
 */
function applyTechniqueToMaterial(technique, material, level, skipExtraProps) {
    Object.getOwnPropertyNames(technique).forEach(propertyName => {
        if (propertyName.startsWith("_") ||
            exports.BASE_TECHNIQUE_NON_MATERIAL_PROPS.indexOf(propertyName) !== -1 ||
            DEFAULT_SKIP_PROPERTIES.indexOf(propertyName) !== -1 ||
            (skipExtraProps !== undefined && skipExtraProps.indexOf(propertyName) !== -1)) {
            return;
        }
        const prop = propertyName;
        const m = material;
        let value = technique[prop];
        if (typeof m[prop] === "undefined") {
            return;
        }
        if (level !== undefined && harp_datasource_protocol_1.isInterpolatedProperty(value)) {
            value = harp_datasource_protocol_1.getPropertyValue(value, level);
        }
        if (m[prop] instanceof THREE.Color) {
            m[prop].set(value);
        }
        else {
            m[prop] = value;
        }
    });
}
exports.applyTechniqueToMaterial = applyTechniqueToMaterial;
function getTextureBuffer(buffer, textureDataType) {
    if (textureDataType === undefined) {
        return new Uint8Array(buffer);
    }
    switch (textureDataType) {
        case THREE.UnsignedByteType:
            return new Uint8Array(buffer);
        case THREE.ByteType:
            return new Int8Array(buffer);
        case THREE.ShortType:
            return new Int16Array(buffer);
        case THREE.UnsignedShortType:
            return new Uint16Array(buffer);
        case THREE.IntType:
            return new Int32Array(buffer);
        case THREE.UnsignedIntType:
            return new Uint32Array(buffer);
        case THREE.FloatType:
            return new Float32Array(buffer);
        case THREE.HalfFloatType:
            return new Uint16Array(buffer);
    }
    throw new Error("Unsupported texture data type");
}


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DepthPrePass.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DepthPrePass.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Bitmask used for the depth pre-pass to prevent multiple fragments in the same screen position
 * from rendering color.
 */
exports.DEPTH_PRE_PASS_STENCIL_MASK = 0x01;
/**
 * Check if technique requires (and not disables) use of depth prepass.
 *
 * Depth prepass is enabled if correct opacity is specified (in range `(0,1)`) _and_ not explicitly
 * disabled by `enableDepthPrePass` option.
 *
 * @param technique [[BaseStandardTechnique]] instance to be checked
 */
function isRenderDepthPrePassEnabled(technique) {
    return (technique.enableDepthPrePass !== false &&
        technique.opacity !== undefined &&
        technique.opacity > 0 &&
        technique.opacity < 1.0);
}
exports.isRenderDepthPrePassEnabled = isRenderDepthPrePassEnabled;
/**
 * Creates material for depth prepass.
 *
 * Creates material that writes only to the z-buffer. Updates the original material instance, to
 * support depth prepass.
 *
 * @param baseMaterial The base material of mesh that is updated to work with depth prepass
 *     and then used. This parameter is a template for depth prepass material that is returned.
 * @returns depth prepass material, which is a clone of `baseMaterial` with the adapted settings.
 */
function createDepthPrePassMaterial(baseMaterial) {
    baseMaterial.depthWrite = false;
    baseMaterial.depthFunc = THREE.EqualDepth;
    baseMaterial.colorWrite = true;
    baseMaterial.transparent = true;
    const depthPassMaterial = baseMaterial.clone();
    depthPassMaterial.depthWrite = true;
    depthPassMaterial.depthTest = true;
    depthPassMaterial.depthFunc = THREE.LessDepth;
    depthPassMaterial.colorWrite = false;
    depthPassMaterial.transparent = false;
    depthPassMaterial.opacity = 1.0;
    return depthPassMaterial;
}
exports.createDepthPrePassMaterial = createDepthPrePassMaterial;
// tslint:disable:max-line-length
/**
 * Clones a given mesh to render it in the depth prepass with another material. Both the original
 * and depth prepass meshes, when rendered in the correct order, create the proper depth prepass
 * effect. The original mesh material is slightly modified by [[createDepthPrePassMaterial]] to
 * support the depth prepass. This method is usable only if the material of this mesh has an
 * opacity value in the range `(0,1)`.
 *
 * About render order: the DepthPrePass object that is created has the same `renderOrder` as
 * the original mesh. The proper sort orders of both the depth and the color pass objects are
 * guaranteed by ThreeJS's handling of transparent objects, which renders them after opaque
 * objects:
 *   - since the depth prepass object is never transparent, it is rendered first
 *   - since the color pass object is transparent, it is rendered second
 *
 * @see [Material.transparent in ThreeJS's doc](https://threejs.org/docs/#api/harp-materials/Material.transparent).
 *
 * @param mesh original mesh
 * @returns `Mesh` depth pre pass
 */
// tslint:enable:max-line-length
function createDepthPrePassMesh(mesh) {
    const originalGeometry = mesh.geometry;
    if (!(originalGeometry instanceof THREE.BufferGeometry)) {
        throw new Error("#createDepthPassMesh only BufferGeometry is supported");
    }
    const positionAttribute = originalGeometry.getAttribute("position");
    if (!positionAttribute) {
        throw new Error("#createDepthPassMesh position attribute not found");
    }
    const depthPassGeometry = new THREE.BufferGeometry();
    depthPassGeometry.addAttribute("position", positionAttribute);
    const uvAttribute = originalGeometry.getAttribute("uv");
    if (uvAttribute) {
        depthPassGeometry.addAttribute("uv", uvAttribute);
    }
    const extrusionAxisAttribute = originalGeometry.getAttribute("extrusionAxis");
    if (extrusionAxisAttribute) {
        depthPassGeometry.addAttribute("extrusionAxis", extrusionAxisAttribute);
    }
    if (originalGeometry.index) {
        depthPassGeometry.setIndex(originalGeometry.index);
    }
    for (const group of originalGeometry.groups) {
        const { start, count, materialIndex } = group;
        depthPassGeometry.addGroup(start, count, materialIndex);
    }
    const depthPassMaterial = mesh.material instanceof Array
        ? mesh.material.map(createDepthPrePassMaterial)
        : createDepthPrePassMaterial(mesh.material);
    const depthPassMesh = new THREE.Mesh(depthPassGeometry, depthPassMaterial);
    depthPassMesh.renderOrder = mesh.renderOrder;
    return depthPassMesh;
}
exports.createDepthPrePassMesh = createDepthPrePassMesh;
/**
 * Sets up all the needed stencil logic needed for the depth pre-pass.
 *
 * This logic is in place to avoid z-fighting artifacts that can appear in geometries that have
 * coplanar triangles inside the same mesh.
 *
 * @param depthMesh Mesh created by `createDepthPrePassMesh`.
 * @param colorMesh Original mesh.
 */
function setDepthPrePassStencil(depthMesh, colorMesh) {
    // Set up depth mesh stencil logic.
    // Set the depth pre-pass stencil bit for all processed fragments. We use `gl.ALWAYS` and not
    // `gl.NOTEQUAL` to force all fragments to pass the stencil test and write the correct depth
    // value.
    depthMesh.onBeforeRender = harp_utils_1.chainCallbacks(depthMesh.onBeforeRender, (renderer, scene, camera, geometry, material, group) => {
        const gl = renderer.context;
        renderer.state.buffers.stencil.setTest(true);
        renderer.state.buffers.stencil.setMask(exports.DEPTH_PRE_PASS_STENCIL_MASK);
        renderer.state.buffers.stencil.setOp(gl.KEEP, gl.KEEP, gl.REPLACE);
        renderer.state.buffers.stencil.setFunc(gl.ALWAYS, 0xff, exports.DEPTH_PRE_PASS_STENCIL_MASK);
    });
    // Set up color mesh stencil logic.
    // Only write color for pixels with the depth pre-pass stencil bit set. Also, once a pixel is
    // rendered, set the stencil bit to 0 to prevent subsequent pixels in the same clip position
    // from rendering color again.
    colorMesh.onBeforeRender = harp_utils_1.chainCallbacks(colorMesh.onBeforeRender, (renderer, scene, camera, geometry, material, group) => {
        const gl = renderer.context;
        renderer.state.buffers.stencil.setTest(true);
        renderer.state.buffers.stencil.setMask(exports.DEPTH_PRE_PASS_STENCIL_MASK);
        renderer.state.buffers.stencil.setOp(gl.KEEP, gl.KEEP, gl.ZERO);
        renderer.state.buffers.stencil.setFunc(gl.EQUAL, 0xff, exports.DEPTH_PRE_PASS_STENCIL_MASK);
    });
    // Disable stencil test after rendering each mesh.
    depthMesh.onAfterRender = renderer => {
        renderer.state.buffers.stencil.setTest(false);
        renderer.state.buffers.stencil.setMask(0xff);
    };
    colorMesh.onAfterRender = renderer => {
        renderer.state.buffers.stencil.setTest(false);
        renderer.state.buffers.stencil.setMask(0xff);
    };
}
exports.setDepthPrePassStencil = setDepthPrePassStencil;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Status of the elevation range calculation.
 */
var CalculationStatus;
(function (CalculationStatus) {
    // Calculated approximately. A more precise result may be available later.
    CalculationStatus[CalculationStatus["PendingApproximate"] = 0] = "PendingApproximate";
    // Calculation completed. The result is final, won't improve upon retrying.
    CalculationStatus[CalculationStatus["FinalPrecise"] = 1] = "FinalPrecise";
})(CalculationStatus = exports.CalculationStatus || (exports.CalculationStatus = {}));


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapTileCuller.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapTileCuller.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Second step tile culling: Do additional check for intersection of box and frustum by checking if
 * the frustum is outside any plane of the tiles `bbox` (oriented, not AABB). It's in the inverse of
 * the standard frustum test, which excludes many cases where the large terrain tiles straddle the
 * planes of the frustum.
 *
 * @see http://www.iquilezles.org/www/articles/frustumcorrect/frustumcorrect.htm
 */
class MapTileCuller {
    /**
     * Constructs a `MapTileCuller`.
     *
     * @param m_camera A `THREE.Camera`.
     */
    constructor(m_camera) {
        this.m_camera = m_camera;
        this.m_globalFrustumMin = new THREE.Vector3();
        this.m_globalFrustumMax = new THREE.Vector3();
        this.m_frustumCorners = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
    }
    /**
     * Sets up culling and computes frustum corners. You mus call this function before the culling
     * starts.
     */
    setup() {
        const frustumCorners = this.getFrustumCorners();
        const matrix = this.m_camera.matrixWorld;
        this.m_globalFrustumMin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this.m_globalFrustumMax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        for (const frustumCorner of frustumCorners) {
            frustumCorner.applyMatrix4(matrix);
            this.m_globalFrustumMin.x = Math.min(this.m_globalFrustumMin.x, frustumCorner.x);
            this.m_globalFrustumMin.y = Math.min(this.m_globalFrustumMin.y, frustumCorner.y);
            this.m_globalFrustumMin.z = Math.min(this.m_globalFrustumMin.z, frustumCorner.z);
            this.m_globalFrustumMax.x = Math.max(this.m_globalFrustumMax.x, frustumCorner.x);
            this.m_globalFrustumMax.y = Math.max(this.m_globalFrustumMax.y, frustumCorner.y);
            this.m_globalFrustumMax.z = Math.max(this.m_globalFrustumMax.z, frustumCorner.z);
        }
    }
    /**
     * Checks if the tile's bounding box intersects with the current view's frustum.
     *
     * @param tileBounds The bounding box for the tile.
     */
    frustumIntersectsTileBox(tileBounds) {
        const globalFrustumMin = this.m_globalFrustumMin;
        const globalFrustumMax = this.m_globalFrustumMax;
        if (globalFrustumMax.x < tileBounds.min.x ||
            globalFrustumMax.y < tileBounds.min.y ||
            globalFrustumMax.z < tileBounds.min.z ||
            globalFrustumMin.x > tileBounds.max.x ||
            globalFrustumMin.y > tileBounds.max.y ||
            globalFrustumMin.z > tileBounds.max.z) {
            return false;
        }
        return true;
    }
    /**
     * Returns the eight corners of the frustum.
     */
    getFrustumCorners() {
        const frustumCorners = this.m_frustumCorners;
        const invProjMatrix = this.m_camera.projectionMatrixInverse;
        let cornerIndex = 0;
        function addPoint(x, y, z) {
            frustumCorners[cornerIndex++].set(x, y, z).applyMatrix4(invProjMatrix);
        }
        const w = 1;
        const h = 1;
        const n = -1;
        const f = 1;
        // near
        addPoint(-w, -h, n);
        addPoint(w, -h, n);
        addPoint(-w, h, n);
        addPoint(w, h, n);
        // far
        addPoint(-w, -h, f);
        addPoint(w, -h, f);
        addPoint(-w, h, f);
        addPoint(w, h, f);
        return frustumCorners;
    }
}
exports.MapTileCuller = MapTileCuller;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapView.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapView.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const AnimatedExtrusionHandler_1 = __webpack_require__(/*! ./AnimatedExtrusionHandler */ "./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js");
const CameraMovementDetector_1 = __webpack_require__(/*! ./CameraMovementDetector */ "./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js");
const composing_1 = __webpack_require__(/*! ./composing */ "./node_modules/@here/harp-mapview/lib/composing/index.js");
const ConcurrentDecoderFacade_1 = __webpack_require__(/*! ./ConcurrentDecoderFacade */ "./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js");
const CopyrightInfo_1 = __webpack_require__(/*! ./CopyrightInfo */ "./node_modules/@here/harp-mapview/lib/CopyrightInfo.js");
const TileGeometryManager_1 = __webpack_require__(/*! ./geometry/TileGeometryManager */ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryManager.js");
const MapViewImageCache_1 = __webpack_require__(/*! ./image/MapViewImageCache */ "./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js");
const MapViewFog_1 = __webpack_require__(/*! ./MapViewFog */ "./node_modules/@here/harp-mapview/lib/MapViewFog.js");
const PickHandler_1 = __webpack_require__(/*! ./PickHandler */ "./node_modules/@here/harp-mapview/lib/PickHandler.js");
const PoiManager_1 = __webpack_require__(/*! ./poi/PoiManager */ "./node_modules/@here/harp-mapview/lib/poi/PoiManager.js");
const PoiTableManager_1 = __webpack_require__(/*! ./poi/PoiTableManager */ "./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js");
const ScreenCollisions_1 = __webpack_require__(/*! ./ScreenCollisions */ "./node_modules/@here/harp-mapview/lib/ScreenCollisions.js");
const ScreenProjector_1 = __webpack_require__(/*! ./ScreenProjector */ "./node_modules/@here/harp-mapview/lib/ScreenProjector.js");
const SkyBackground_1 = __webpack_require__(/*! ./SkyBackground */ "./node_modules/@here/harp-mapview/lib/SkyBackground.js");
const Statistics_1 = __webpack_require__(/*! ./Statistics */ "./node_modules/@here/harp-mapview/lib/Statistics.js");
const TextElementsRenderer_1 = __webpack_require__(/*! ./text/TextElementsRenderer */ "./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js");
const TextStyleCache_1 = __webpack_require__(/*! ./text/TextStyleCache */ "./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js");
const ThemeHelpers_1 = __webpack_require__(/*! ./ThemeHelpers */ "./node_modules/@here/harp-mapview/lib/ThemeHelpers.js");
const ThemeLoader_1 = __webpack_require__(/*! ./ThemeLoader */ "./node_modules/@here/harp-mapview/lib/ThemeLoader.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-mapview/lib/Utils.js");
const VisibleTileSet_1 = __webpack_require__(/*! ./VisibleTileSet */ "./node_modules/@here/harp-mapview/lib/VisibleTileSet.js");
// cache value, because access to process.env.NODE_ENV is SLOW!
const isProduction = "development" === "production";
var MapViewEventNames;
(function (MapViewEventNames) {
    /** Called before this `MapView` starts to render a new frame. */
    MapViewEventNames["Update"] = "update";
    /** Called when the WebGL canvas is resized. */
    MapViewEventNames["Resize"] = "resize";
    /** Called when the frame is about to be rendered. */
    MapViewEventNames["Render"] = "render";
    /** Called after a frame has been rendered. */
    MapViewEventNames["AfterRender"] = "didrender";
    /** Called after the first frame has been rendered. */
    MapViewEventNames["FirstFrame"] = "first-render";
    /** Called when the first view has all the necessary tiles loaded and rendered. */
    MapViewEventNames["FrameComplete"] = "frame-complete";
    /** Called when the theme has been loaded with the internal [[ThemeLoader]]. */
    MapViewEventNames["ThemeLoaded"] = "theme-loaded";
    /** Called when the animation mode has started. */
    MapViewEventNames["AnimationStarted"] = "animation-started";
    /** Called when the animation mode has stopped. */
    MapViewEventNames["AnimationFinished"] = "animation-finished";
    /** Called when a camera interaction has been detected. */
    MapViewEventNames["MovementStarted"] = "movement-started";
    /** Called when a camera interaction has been stopped. */
    MapViewEventNames["MovementFinished"] = "movement-finished";
    /** Called when a data source has been connected or failed to connect. */
    MapViewEventNames["DataSourceConnect"] = "datasource-connect";
    /** Emitted when copyright info of rendered map has been changed. */
    MapViewEventNames["CopyrightChanged"] = "copyright-changed";
    /** Called when the WebGL context is lost. */
    MapViewEventNames["ContextLost"] = "webglcontext-lost";
    /** Called when the WebGL context is restored. */
    MapViewEventNames["ContextRestored"] = "webglcontext-restored";
})(MapViewEventNames = exports.MapViewEventNames || (exports.MapViewEventNames = {}));
const logger = harp_utils_1.LoggerManager.instance.create("MapView");
const DEFAULT_FONT_CATALOG = "./resources/fonts/Default_FontCatalog.json";
const DEFAULT_CLEAR_COLOR = 0xefe9e1;
const EYE_INVERSE = new THREE.Vector3(0, 0, -1);
const DEFAULT_FOV_CALCULATION = { type: "dynamic", fov: 40 };
const MAX_FIELD_OF_VIEW = 140;
const MIN_FIELD_OF_VIEW = 10;
const DEFAULT_MIN_ZOOM_LEVEL = 1;
/**
 * Default maximum zoom level.
 */
const DEFAULT_MAX_ZOOM_LEVEL = 20;
/**
 * Default minimum camera height.
 */
const DEFAULT_MIN_CAMERA_HEIGHT = 20;
/**
 * Amount of framerate values to pick average from
 */
const FRAME_RATE_RING_SIZE = 12;
/**
 * Default starting value for FPS computation.
 */
const FALLBACK_FRAME_RATE = 30;
// Event type: cast needed to workaround wrong THREE.js typings.
const RENDER_EVENT = { type: MapViewEventNames.Render };
const DID_RENDER_EVENT = { type: MapViewEventNames.AfterRender };
const FIRST_FRAME_EVENT = { type: MapViewEventNames.FirstFrame };
const FRAME_COMPLETE_EVENT = { type: MapViewEventNames.FrameComplete };
const THEME_LOADED_EVENT = { type: MapViewEventNames.ThemeLoaded };
const ANIMATION_STARTED_EVENT = { type: MapViewEventNames.AnimationStarted };
const ANIMATION_FINISHED_EVENT = { type: MapViewEventNames.AnimationFinished };
const MOVEMENT_STARTED_EVENT = { type: MapViewEventNames.MovementStarted };
const MOVEMENT_FINISHED_EVENT = { type: MapViewEventNames.MovementFinished };
const CONTEXT_LOST_EVENT = { type: MapViewEventNames.ContextLost };
const CONTEXT_RESTORED_EVENT = { type: MapViewEventNames.ContextRestored };
const COPYRIGHT_CHANGED_EVENT = { type: MapViewEventNames.CopyrightChanged };
const tmpVector = new THREE.Vector2();
/**
 * Default settings used by [[MapView]] collected in one place.
 */
exports.MapViewDefaults = {
    projection: harp_geoutils_1.mercatorProjection,
    maxVisibleDataSourceTiles: 120,
    extendedFrustumCulling: true,
    tileCacheSize: 20,
    resourceComputationType: VisibleTileSet_1.ResourceComputationType.EstimationInMb,
    quadTreeSearchDistanceUp: 3,
    quadTreeSearchDistanceDown: 2,
    pixelRatio: typeof window !== "undefined" && window.devicePixelRatio !== undefined
        ? window.devicePixelRatio
        : 1.0
};
/**
 * The core class of the library to call in order to create a map visualization. It needs to be
 * linked to datasources.
 */
class MapView extends THREE.EventDispatcher {
    /**
     * Constructs a new `MapView` with the given options or canvas element.
     *
     * @param options The `MapView` options or the HTML canvas element used to display the map.
     */
    constructor(options) {
        super();
        /**
         * The string of the default font catalog to use for labelling.
         */
        this.defaultFontCatalog = DEFAULT_FONT_CATALOG;
        this.dumpNext = false;
        /**
         * Allows discarding the text rendering after the map rendering.
         */
        this.renderLabels = true;
        this.m_screenCollisions = new ScreenCollisions_1.ScreenCollisions();
        this.m_visibleTileSetLock = false;
        this.m_zoomLevel = DEFAULT_MIN_ZOOM_LEVEL;
        this.m_minZoomLevel = DEFAULT_MIN_ZOOM_LEVEL;
        this.m_maxZoomLevel = DEFAULT_MAX_ZOOM_LEVEL;
        this.m_minCameraHeight = DEFAULT_MIN_CAMERA_HEIGHT;
        this.m_screenCamera = new THREE.OrthographicCamera(-1, 1, 1, -1);
        /**
         * Relative to eye camera.
         *
         * This camera is internal camera used to improve precision
         * when rendering geometries.
         */
        this.m_rteCamera = new THREE.PerspectiveCamera();
        this.m_tempVector3 = new THREE.Vector3();
        this.m_scene = new THREE.Scene();
        this.m_fog = new MapViewFog_1.MapViewFog(this.m_scene);
        this.m_mapTilesRoot = new THREE.Object3D();
        this.m_mapAnchors = new THREE.Object3D();
        this.m_animationCount = 0;
        this.m_drawing = false;
        this.m_updatePending = false;
        this.m_frameNumber = 0;
        this.m_maxFps = 0;
        this.m_detectedFps = FALLBACK_FRAME_RATE;
        this.m_textRenderStyleCache = new TextStyleCache_1.TextRenderStyleCache();
        this.m_textLayoutStyleCache = new TextStyleCache_1.TextLayoutStyleCache();
        this.m_overlayTextElements = [];
        this.m_forceCameraAspect = undefined;
        //
        // sources
        //
        this.m_tileDataSources = [];
        this.m_connectedDataSources = new Set();
        // gestures
        this.m_raycaster = new THREE.Raycaster();
        this.m_plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));
        this.m_sphere = new THREE.Sphere(undefined, harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS);
        this.m_theme = { styles: {} };
        this.m_firstFrameRendered = false;
        this.m_firstFrameComplete = false;
        this.m_frameTimeIndex = 0;
        this.m_frameTimeRing = [];
        this.m_imageCache = new MapViewImageCache_1.MapViewImageCache(this);
        this.m_poiManager = new PoiManager_1.PoiManager(this);
        this.m_poiTableManager = new PoiTableManager_1.PoiTableManager(this);
        this.m_lastTileIds = "";
        this.m_copyrightInfo = [];
        /**
         * Default handler for webglcontextlost event
         */
        this.onWebGLContextLost = (event) => {
            this.dispatchEvent(CONTEXT_LOST_EVENT);
            logger.log("WebGL context lost", event);
        };
        /**
         * Default handler for webglcontextrestored event
         */
        this.onWebGLContextRestored = (event) => {
            this.dispatchEvent(CONTEXT_RESTORED_EVENT);
            if (this.m_theme !== undefined && this.m_theme.clearColor !== undefined) {
                this.m_renderer.setClearColor(new THREE.Color(this.m_theme.clearColor));
            }
            else {
                this.m_renderer.setClearColor(DEFAULT_CLEAR_COLOR);
            }
            this.update();
            logger.log("WebGL context restored", event);
        };
        // make a copy to avoid unwanted changes to the original options.
        this.m_options = Object.assign({}, options);
        if (this.m_options.minZoomLevel !== undefined) {
            this.m_minZoomLevel = this.m_options.minZoomLevel;
        }
        if (this.m_options.maxZoomLevel !== undefined) {
            this.m_maxZoomLevel = this.m_options.maxZoomLevel;
        }
        if (this.m_options.minCameraHeight !== undefined) {
            this.m_minCameraHeight = this.m_options.minCameraHeight;
        }
        if (this.m_options.fontCatalog !== undefined) {
            this.defaultFontCatalog = this.m_options.fontCatalog;
        }
        if (this.m_options.decoderUrl !== undefined) {
            ConcurrentDecoderFacade_1.ConcurrentDecoderFacade.defaultScriptUrl = this.m_options.decoderUrl;
        }
        if (this.m_options.decoderCount !== undefined) {
            ConcurrentDecoderFacade_1.ConcurrentDecoderFacade.defaultWorkerCount = this.m_options.decoderCount;
        }
        this.m_visibleTileSetOptions = Object.assign({}, exports.MapViewDefaults);
        if (options.projection !== undefined) {
            this.m_visibleTileSetOptions.projection = options.projection;
        }
        if (options.extendedFrustumCulling !== undefined) {
            this.m_visibleTileSetOptions.extendedFrustumCulling = options.extendedFrustumCulling;
        }
        if (options.maxVisibleDataSourceTiles !== undefined) {
            this.m_visibleTileSetOptions.maxVisibleDataSourceTiles =
                options.maxVisibleDataSourceTiles;
        }
        if (options.tileCacheSize !== undefined) {
            this.m_visibleTileSetOptions.tileCacheSize = options.tileCacheSize;
        }
        if (options.resourceComputationType !== undefined) {
            this.m_visibleTileSetOptions.resourceComputationType = options.resourceComputationType;
        }
        if (options.quadTreeSearchDistanceUp !== undefined) {
            this.m_visibleTileSetOptions.quadTreeSearchDistanceUp =
                options.quadTreeSearchDistanceUp;
        }
        if (options.quadTreeSearchDistanceDown !== undefined) {
            this.m_visibleTileSetOptions.quadTreeSearchDistanceDown =
                options.quadTreeSearchDistanceDown;
        }
        this.m_pixelRatio = options.pixelRatio;
        if (options.maxFps !== undefined) {
            this.m_maxFps = Math.max(0, options.maxFps);
        }
        this.m_options.enableStatistics = this.m_options.enableStatistics === true;
        this.m_languages = this.m_options.languages;
        if (!isProduction &&
            this.m_options.collisionDebugCanvas !== undefined &&
            this.m_options.collisionDebugCanvas !== null) {
            this.m_collisionDebugCanvas = this.m_options.collisionDebugCanvas;
            this.m_screenCollisions = new ScreenCollisions_1.ScreenCollisionsDebug(this.m_collisionDebugCanvas);
        }
        this.handleRequestAnimationFrame = this.renderFunc.bind(this);
        this.handlePostponedAnimationFrame = this.postponedAnimationFrame.bind(this);
        this.m_pickHandler = new PickHandler_1.PickHandler(this, this.m_rteCamera, this.m_options.enableRoadPicking === true);
        // Initialization of the stats
        this.setupStats(this.m_options.enableStatistics);
        // Initialization of the renderer
        this.m_renderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            antialias: this.m_options.enableNativeWebglAntialias !== false,
            alpha: this.m_options.alpha,
            preserveDrawingBuffer: this.m_options.preserveDrawingBuffer === true
        });
        this.m_renderer.autoClear = false;
        // This is detailed at https://threejs.org/docs/#api/renderers/WebGLRenderer.info
        // When using several WebGLRenderer#render calls per frame, it is the only way to get
        // correct rendering data from ThreeJS.
        this.m_renderer.info.autoReset = false;
        this.setupRenderer();
        this.m_options.fovCalculation =
            this.m_options.fovCalculation === undefined
                ? DEFAULT_FOV_CALCULATION
                : this.m_options.fovCalculation;
        this.m_options.fovCalculation.fov = harp_geoutils_1.MathUtils.clamp(this.m_options.fovCalculation.fov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);
        // Initialization of mCamera and mVisibleTiles
        const { width, height } = this.getCanvasClientSize();
        const aspect = width / height;
        this.m_camera = new THREE.PerspectiveCamera(this.m_options.fovCalculation.fov, aspect, 0.1, 4000000);
        this.m_camera.up.set(0, 0, 1);
        this.m_lookAtDistance = 0;
        this.m_focalLength = 0;
        this.m_scene.add(this.m_camera); // ensure the camera is added to the scene.
        this.m_screenProjector = new ScreenProjector_1.ScreenProjector(this.m_camera);
        this.setupCamera();
        this.m_movementDetector = new CameraMovementDetector_1.CameraMovementDetector(this.m_options.movementThrottleTimeout, () => this.movementStarted(), () => this.movementFinished());
        const mapPassAntialiasSettings = this.m_options.customAntialiasSettings;
        this.mapRenderingManager = new composing_1.MapRenderingManager(width, height, this.m_options.dynamicPixelRatio, mapPassAntialiasSettings);
        this.m_tileGeometryManager = new TileGeometryManager_1.SimpleTileGeometryManager(this);
        this.m_visibleTiles = new VisibleTileSet_1.VisibleTileSet(this.m_camera, this.m_tileGeometryManager, this.m_visibleTileSetOptions);
        this.m_animatedExtrusionHandler = new AnimatedExtrusionHandler_1.AnimatedExtrusionHandler(this);
        this.initTheme();
        this.drawFrame();
        this.canvas.addEventListener("webglcontextlost", this.onWebGLContextLost);
        this.canvas.addEventListener("webglcontextrestored", this.onWebGLContextRestored);
    }
    /**
     * @hidden
     * The [[TextElementsRenderer]] select the visible [[TextElement]]s and renders them.
     */
    get textElementsRenderer() {
        return this.m_textElementsRenderer;
    }
    /**
     * @hidden
     * The [[TextRenderStyleCache]] used for this instance of `MapView`.
     */
    get textRenderStyleCache() {
        return this.m_textRenderStyleCache;
    }
    /**
     * @hidden
     * The [[TextLayoutStyleCache]] used for this instance of `MapView`.
     */
    get textLayoutStyleCache() {
        return this.m_textLayoutStyleCache;
    }
    /**
     * @hidden
     * The [[CameraMovementDetector]] detects camera movements. Made available for performance
     * measurements.
     */
    get cameraMovementDetector() {
        return this.m_movementDetector;
    }
    /**
     * The [[AnimatedExtrusionHandler]] controlls animated extrussion effect
     * of the extruded objects in the [[Tile]]
     */
    get animatedExtrusionHandler() {
        return this.m_animatedExtrusionHandler;
    }
    /**
     * Disposes this `MapView`.
     *
     * This function cleans the resources that are managed manually including those that exist in
     * shared caches.
     *
     * Note: This function does not try to clean objects that can be disposed off easily by
     * TypeScript's garbage collecting mechanism. Consequently, if you need to perform a full
     * cleanup, you must ensure that all references to this `MapView` are removed.
     */
    dispose() {
        if (this.m_animationFrameHandle !== undefined) {
            cancelAnimationFrame(this.m_animationFrameHandle);
            this.m_animationFrameHandle = undefined;
        }
        this.canvas.removeEventListener("webglcontextlost", this.onWebGLContextLost);
        this.canvas.removeEventListener("webglcontextrestored", this.onWebGLContextRestored);
        for (const dataSource of this.m_tileDataSources) {
            dataSource.dispose();
        }
        this.m_visibleTiles.clearTileCache();
        this.m_renderer.dispose();
        this.m_imageCache.clear();
        this.m_movementDetector.dispose();
    }
    /**
     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of
     * tiles.
     */
    get resourceComputationType() {
        return this.m_visibleTiles.resourceComputationType;
    }
    set resourceComputationType(value) {
        this.m_visibleTiles.resourceComputationType = value;
    }
    /**
     * Returns the cache size.
     */
    getCacheSize() {
        return this.m_visibleTiles.getDataSourceCacheSize();
    }
    /**
     * Sets the cache size in number of tiles.
     *
     * @param size The cache size in tiles.
     * @param numVisibleTiles The number of tiles visible, which is size/2 by default.
     */
    setCacheSize(size, numVisibleTiles) {
        this.m_visibleTiles.setDataSourceCacheSize(size);
        numVisibleTiles = numVisibleTiles !== undefined ? numVisibleTiles : size / 2;
        this.m_visibleTiles.setNumberOfVisibleTiles(Math.floor(numVisibleTiles));
        this.updateImages();
        this.updateLighting();
        this.updateTextRenderer();
        this.updateSkyBackground();
        this.update();
    }
    /**
     * Specfies whether extended frustum culling is enabled or disabled.
     */
    get extendedFrustumCulling() {
        return this.m_options.extendedFrustumCulling !== undefined
            ? this.m_visibleTileSetOptions.extendedFrustumCulling
            : true;
    }
    /**
     * Enable of disable extended frustum culling.
     */
    set extendedFrustumCulling(value) {
        this.m_visibleTileSetOptions.extendedFrustumCulling = value;
    }
    /**
     * Returns the status of frustum culling after each update.
     */
    get lockVisibleTileSet() {
        return this.m_visibleTileSetLock;
    }
    /**
     * Enable of disable frustum culling after each update.
     */
    set lockVisibleTileSet(value) {
        this.m_visibleTileSetLock = value;
    }
    /**
     * Gets the optional camera used to render the scene.
     */
    get pointOfView() {
        return this.m_pointOfView;
    }
    /**
     * Sets the optional camera used to render the scene.
     */
    set pointOfView(pointOfView) {
        this.m_pointOfView = pointOfView;
        this.update();
    }
    /**
     * Loads a posteffects file.
     *
     * @param postEffectsFile File URL describing the post effects.
     */
    loadPostEffects(postEffectsFile) {
        fetch(postEffectsFile)
            .then(response => response.json())
            .then((postEffects) => {
            this.m_postEffects = postEffects;
            this.setPostEffects();
        });
    }
    /**
     * The abstraction of the [[MapRenderingManager]] API for posteffects.
     */
    get postEffects() {
        return this.m_postEffects;
    }
    set postEffects(postEffects) {
        this.m_postEffects = postEffects;
        this.setPostEffects();
    }
    /**
     * Gets the current `Theme` used by this `MapView` to style map elements.
     */
    get theme() {
        return this.m_theme;
    }
    /**
     * Changes the `Theme` used by this `MapView` to style map elements.
     */
    set theme(theme) {
        // Fog and sky.
        this.m_theme.fog = theme.fog;
        this.m_theme.sky = theme.sky;
        this.updateSkyBackground();
        this.m_fog.reset(this.m_theme);
        this.m_theme.lights = theme.lights;
        this.updateLighting();
        // Clear color.
        this.m_theme.clearColor = theme.clearColor;
        this.renderer.setClearColor(new THREE.Color(theme.clearColor));
        // Images.
        this.m_theme.images = theme.images;
        this.m_theme.imageTextures = theme.imageTextures;
        this.updateImages();
        // POI tables.
        this.m_theme.poiTables = theme.poiTables;
        this.loadPoiTables();
        // Text.
        this.m_theme.textStyles = theme.textStyles;
        this.m_theme.defaultTextStyle = theme.defaultTextStyle;
        this.m_theme.fontCatalogs = theme.fontCatalogs;
        this.m_textRenderStyleCache.clear();
        this.m_textLayoutStyleCache.clear();
        this.updateTextRenderer();
        if (this.m_theme.styles === undefined) {
            this.m_theme.styles = {};
        }
        if (theme.styles !== undefined) {
            for (const styleSetName in theme.styles) {
                if (theme.styles[styleSetName] !== undefined) {
                    const styleSet = theme.styles[styleSetName];
                    this.getDataSourcesByStyleSetName(styleSetName).forEach(ds => ds.setStyleSet(styleSet));
                    this.m_theme.styles[styleSetName] = styleSet;
                }
            }
        }
        this.update();
    }
    /**
     * Gets the value of the forced custom camera aspect.
     * Every time a frame is rendered, `MapView` resets the camera aspect.
     *
     * You can disable this behavior by setting the value to `undefined`.
     */
    get forceCameraAspect() {
        return this.m_forceCameraAspect;
    }
    /**
     * Sets the custom forced camera aspect ratio to use while rendering.
     */
    set forceCameraAspect(aspect) {
        this.m_forceCameraAspect = aspect;
    }
    /**
     * Maximum FPS. If defined (and > 0) it is the maximum FPS that is used.
     */
    set maxFps(fps) {
        this.m_maxFps = Math.max(0, fps);
    }
    get maxFps() {
        return Math.max(0, this.m_maxFps);
    }
    /**
     * Lists the ISO 639-1 language codes for DataSources to use.
     */
    get languages() {
        return this.m_languages;
    }
    /**
     * Sets the list of ISO 639-1 language codes for DataSources to use.
     */
    set languages(languages) {
        this.m_languages = languages;
        this.m_tileDataSources.forEach((dataSource) => {
            dataSource.setLanguages(this.m_languages);
        });
        this.clearTileCache();
        this.update();
    }
    get copyrightInfo() {
        return this.m_copyrightInfo;
    }
    /**
     * @hidden
     * Return if all fading animations (for debugging and performance measurement) should be
     * disabled.
     */
    get fadingDisabled() {
        return this.m_options.disableFading === true;
    }
    /**
     * @hidden
     * Return current frame number.
     */
    get frameNumber() {
        return this.m_frameNumber;
    }
    addEventListener(type, listener) {
        super.addEventListener(type, listener);
    }
    removeEventListener(type, listener) {
        super.removeEventListener(type, listener);
    }
    /**
     * The HTML canvas element used by this `MapView`.
     */
    get canvas() {
        return this.m_options.canvas;
    }
    /**
     * The HTML canvas element used by this `MapView`.
     */
    get collisionDebugCanvas() {
        return this.m_collisionDebugCanvas;
    }
    /**
     * The THREE.js scene used by this `MapView`.
     */
    get scene() {
        return this.m_scene;
    }
    /**
     * The THREE.js camera used by this `MapView` to render the main scene.
     */
    get camera() {
        return this.m_camera;
    }
    /**
     * The THREE.js `WebGLRenderer` used by this scene.
     */
    get renderer() {
        return this.m_renderer;
    }
    /**
     * The color used to clear the view.
     */
    get clearColor() {
        const rendererClearColor = this.m_renderer.getClearColor();
        return rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;
    }
    /**
     * The color used to clear the view.
     */
    set clearColor(color) {
        this.m_renderer.setClearColor(color);
    }
    /**
     * The projection used to project geo coordinates to world coordinates.
     */
    get projection() {
        return this.m_visibleTileSetOptions.projection;
    }
    /**
     * Changes the projection at run time.
     *
     * TODO: There seems to be some issue with the sphere projection, when changing from this
     * projection to a planar projection, the map is rotated. This needs to be fixed.
     */
    set projection(projection) {
        // The geo center must be reset when changing the projection, because the
        // camera's position is based on the projected geo center.
        const geoCenter = this.geoCenter;
        this.m_visibleTileSetOptions.projection = projection;
        this.clearTileCache();
        // We reset the theme, this has the affect of ensuring all caches are cleared.
        this.theme = this.theme;
        this.geoCenter = geoCenter;
        // Necessary for the sphereProjection, however this also resets the camera position, so it
        // should be fixed.
        //this.setupCamera();
    }
    /**
     * The distance (in pixels) between the screen and the camera.
     */
    get focalLength() {
        return this.m_focalLength;
    }
    /**
     * The position in geo coordinates of the center of the scene.
     */
    get geoCenter() {
        return this.projection.unprojectPoint(this.m_camera.position).normalized();
    }
    /**
     * The position in geo coordinates of the center of the scene.
     * Longitude values outside of -180 and +180 are acceptable.
     */
    set geoCenter(geoCenter) {
        if (geoCenter.altitude !== undefined) {
            this.projection.projectPoint(geoCenter, this.m_camera.position);
        }
        else {
            // Preserve the current altitude
            const altitude = this.geoCenter.altitude;
            this.projection.projectPoint(new harp_geoutils_1.GeoCoordinates(geoCenter.latitude, geoCenter.longitude, altitude), this.m_camera.position);
        }
        this.update();
    }
    /**
     * The node in this MapView's scene containing the user [[MapAnchor]]s.
     * All (first level) children of this node will be positioned in world space according to the
     * [[MapAnchor.geoPosition]].
     * Deeper level children can be used to position custom objects relative to the anchor node.
     */
    get mapAnchors() {
        return this.m_mapAnchors;
    }
    /**
     * The position in world coordinates of the center of the scene.
     */
    get worldCenter() {
        return this.m_camera.position;
    }
    /**
     * The root object of the scene. Contains all `rootObjects` of the [[Tile]]s.
     */
    get worldRootObject() {
        return this.m_mapTilesRoot;
    }
    /**
     * Get the [[PickHandler]] for this `mapView`.
     */
    get pickHandler() {
        return this.m_pickHandler;
    }
    /**
     * Get the [[ImageCache]] that belongs to this `MapView`.
     */
    get imageCache() {
        return this.m_imageCache;
    }
    /**
     * @hidden
     * Get the [[PoiManager]] that belongs to this `MapView`.
     */
    get poiManager() {
        return this.m_poiManager;
    }
    /**
     * @hidden
     * Get the array of [[PoiTableManager]] that belongs to this `MapView`.
     */
    get poiTableManager() {
        return this.m_poiTableManager;
    }
    /**
     * The minimum camera height in meters.
     */
    get minCameraHeight() {
        return this.m_minCameraHeight;
    }
    /**
     * The minimum zoom level.
     */
    get minZoomLevel() {
        return this.m_minZoomLevel;
    }
    /**
     * The minimum zoom level.
     */
    set minZoomLevel(zoomLevel) {
        this.m_minZoomLevel = zoomLevel;
        this.update();
    }
    /**
     * The maximum zoom level. Default is 14.
     */
    get maxZoomLevel() {
        return this.m_maxZoomLevel;
    }
    /**
     * The maximum zoom level.
     */
    set maxZoomLevel(zoomLevel) {
        this.m_maxZoomLevel = zoomLevel;
        this.update();
    }
    /**
     * Returns the zoom level for the given camera setup.
     */
    get zoomLevel() {
        return this.m_zoomLevel;
    }
    /**
     * Returns the storage level for the given camera setup.
     * Actual storage level of the rendered data also depends on [[DataSource.storageLevelOffset]].
     */
    get storageLevel() {
        return THREE.Math.clamp(Math.floor(this.m_zoomLevel), this.m_minZoomLevel, this.m_maxZoomLevel);
    }
    /**
     * Returns height of the viewport in pixels.
     */
    get viewportHeight() {
        return this.canvas.height;
    }
    /**
     * Returns `true` if the native WebGL antialiasing is enabled.
     */
    get nativeWebglAntialiasEnabled() {
        return this.m_options.enableNativeWebglAntialias !== false;
    }
    /**
     * Returns [[DataSource]]s displayed by this `MapView`.
     */
    get dataSources() {
        return this.m_tileDataSources;
    }
    /**
     * Set's the way in which the fov is calculated on the map view. Note, for
     * this to take visual effect, the map should be rendered after calling this
     * function.
     * @param fovCalculation How the FOV is calculated.
     */
    setFovCalculation(fovCalculation) {
        this.m_options.fovCalculation = fovCalculation;
        this.calculateFocalLength(this.m_renderer.getSize(tmpVector).height);
        this.updateCameras();
    }
    /**
     * Returns the unique [[DataSource]] matching the given name.
     */
    getDataSourceByName(dataSourceName) {
        return this.m_tileDataSources.find(ds => ds.name === dataSourceName);
    }
    /**
     * Returns the array of [[DataSource]]s referring to the same [[StyleSet]].
     */
    getDataSourcesByStyleSetName(styleSetName) {
        return this.m_tileDataSources.filter(ds => ds.styleSetName === styleSetName);
    }
    /**
     * Adds a new [[DataSource]] to this `MapView`. `MapView` needs at least one [[DataSource]] to
     * display something.
     *
     * @param dataSource The data source.
     */
    addDataSource(dataSource) {
        const twinDataSource = this.getDataSourceByName(dataSource.name);
        if (twinDataSource !== undefined) {
            throw new Error(`A DataSource with the name "${dataSource.name}" already exists in this MapView.`);
        }
        dataSource.attach(this);
        this.m_tileDataSources.push(dataSource);
        return dataSource
            .connect()
            .then(() => {
            return new Promise(resolve => {
                if (this.theme !== undefined) {
                    resolve();
                    return;
                }
                const resolveOnce = () => {
                    this.removeEventListener(MapViewEventNames.ThemeLoaded, resolveOnce);
                    resolve();
                };
                this.addEventListener(MapViewEventNames.ThemeLoaded, resolveOnce);
            });
        })
            .then(() => {
            const alreadyRemoved = this.m_tileDataSources.indexOf(dataSource) === -1;
            if (alreadyRemoved) {
                return;
            }
            dataSource.addEventListener(MapViewEventNames.Update, () => {
                this.update();
            });
            if (this.m_theme.styles !== undefined && dataSource.styleSetName !== undefined) {
                const styleSet = this.m_theme.styles[dataSource.styleSetName];
                dataSource.setStyleSet(styleSet, this.m_languages);
            }
            this.m_connectedDataSources.add(dataSource.name);
            this.dispatchEvent({
                type: MapViewEventNames.DataSourceConnect,
                dataSourceName: dataSource.name
            });
            this.update();
        })
            .catch(error => {
            this.dispatchEvent({
                type: MapViewEventNames.DataSourceConnect,
                dataSourceName: dataSource.name,
                error
            });
        });
    }
    /**
     * Removes [[DataSource]] from this `MapView`.
     *
     * @param dataSource The data source to be removed
     */
    removeDataSource(dataSource) {
        const dsIndex = this.m_tileDataSources.indexOf(dataSource);
        if (dsIndex === -1) {
            return;
        }
        dataSource.detach(this);
        this.m_visibleTiles.removeDataSource(dataSource.name);
        this.m_tileDataSources.splice(dsIndex, 1);
        this.m_connectedDataSources.delete(dataSource.name);
        this.update();
    }
    /**
     * Access the `VisibleTileSet` to get access to all current datasources and their visible tiles.
     */
    get visibleTileSet() {
        return this.m_visibleTiles;
    }
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements Array of [[TextElement]] to be added.
     */
    addOverlayText(textElements) {
        if (this.m_overlayTextElements !== undefined) {
            this.m_overlayTextElements = this.m_overlayTextElements.concat(textElements);
        }
        this.updateTextRenderer();
        this.update();
    }
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements Array of [[TextElement]] to be added.
     */
    clearOverlayText() {
        this.m_overlayTextElements = [];
    }
    /**
     * The method that sets the camera to the desired angle (`tiltDeg`) and `distance` (in meters)
     * to the `target` location, from a certain azimuth (`azimuthAngle`).
     *
     * @param target The location to look at.
     * @param distance The distance of the camera to the target in meters.
     * @param tiltDeg The camera tilt angle in degrees (0 is vertical).
     * @param azimuthDeg The camera azimuth angle in degrees and clockwise, starting north.
     */
    lookAt(target, distance, tiltDeg = 0, azimuthDeg = 0) {
        Utils_1.MapViewUtils.setRotation(this, -azimuthDeg, tiltDeg);
        this.geoCenter = Utils_1.MapViewUtils.getCameraCoordinatesFromTargetCoordinates(target, distance, -azimuthDeg, tiltDeg, this);
        const pitchRad = THREE.Math.degToRad(tiltDeg);
        this.camera.position.setZ(Math.cos(pitchRad) * distance);
    }
    /**
     * Moves the camera to the specified [[GeoCoordinates]], sets the desired `zoomLevel` and
     * adjusts the yaw and pitch.
     *
     * @param geoPos Geolocation to move the camera to.
     * @param zoomLevel Desired zoom level.
     * @param yawDeg Camera yaw in degrees.
     * @param pitchDeg Camera pitch in degrees.
     */
    setCameraGeolocationAndZoom(geoPos, zoomLevel, yawDeg = 0, pitchDeg = 0) {
        if (this.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            Utils_1.MapViewUtils.setRotation(this, yawDeg, pitchDeg);
            this.geoCenter = geoPos;
            Utils_1.MapViewUtils.zoomOnTargetPosition(this, 0, 0, zoomLevel);
        }
        else {
            this.geoCenter = new harp_geoutils_1.GeoCoordinates(geoPos.latitude, geoPos.longitude);
            const distanceToGround = Utils_1.MapViewUtils.calculateDistanceToGroundFromZoomLevel(this, THREE.Math.clamp(zoomLevel, this.minZoomLevel, this.maxZoomLevel));
            const surfaceNormal = new THREE.Vector3();
            this.projection.surfaceNormal(this.m_camera.position, surfaceNormal);
            this.m_camera.position.addScaledVector(surfaceNormal, distanceToGround);
            this.m_camera.lookAt(this.scene.position);
        }
        this.update();
    }
    /**
     * Returns `true` if this `MapView` is constantly redrawing the scene.
     */
    get animating() {
        return this.m_animationCount > 0;
    }
    /**
     * Begin animating the scene.
     */
    beginAnimation() {
        if (this.m_animationCount++ === 0) {
            if (!this.m_updatePending) {
                this.m_updatePending = true;
                this.drawFrame();
            }
            ANIMATION_STARTED_EVENT.time = Date.now();
            this.dispatchEvent(ANIMATION_STARTED_EVENT);
        }
    }
    /**
     * Stop animating the scene.
     */
    endAnimation() {
        if (this.m_animationCount > 0) {
            --this.m_animationCount;
        }
        if (this.m_animationCount === 0) {
            ANIMATION_FINISHED_EVENT.time = Date.now();
            this.dispatchEvent(ANIMATION_FINISHED_EVENT);
        }
    }
    /**
     * Returns `true` if the camera moved in the last frame.
     */
    get cameraIsMoving() {
        return this.m_movementDetector.cameraIsMoving;
    }
    /**
     * Returns the ratio between a pixel and a world unit for the current camera (in the center of
     * the camera projection).
     */
    get pixelToWorld() {
        if (this.m_pixelToWorld === undefined) {
            // At this point fov calculation should be always defined.
            harp_utils_1.assert(this.m_options.fovCalculation !== undefined);
            // NOTE: Look at distance is the distance to camera focus (and pivot) point.
            // In screen space this point is located in the center of canvas.
            // Given that zoom level is not modified (clamped by camera pitch), the following
            // formulas are all equivalent:
            // lookAtDistance = (EQUATORIAL_CIRCUMFERENCE * focalLength) / (256 * zoomLevel^2);
            // lookAtDistance = abs(cameraPos.z) / cos(cameraPitch);
            // Here we may use precalulated distance (once pre frame):
            const lookAtDistance = this.m_lookAtDistance;
            // Find world space object size that corresponds to one pixel on screen.
            this.m_pixelToWorld = Utils_1.MapViewUtils.calculateWorldSizeByFocalLength(this.m_focalLength, lookAtDistance, 1);
        }
        return this.m_pixelToWorld;
    }
    /**
     * Returns the ratio between a world and a pixel unit for the current camera (in the center of
     * the camera projection).
     */
    get worldToPixel() {
        return 1.0 / this.pixelToWorld;
    }
    get pixelRatio() {
        if (this.m_pixelRatio !== undefined) {
            return this.m_pixelRatio;
        }
        return typeof window !== "undefined" && window.devicePixelRatio !== undefined
            ? window.devicePixelRatio
            : 1.0;
    }
    /**
     * PixelRatio in the WebGlRenderer. May contain values > 1.0 for high resolution screens
     * (HiDPI).
     *
     * A value of `undefined` will make the getter return `window.devicePixelRatio`, setting a value
     * of `1.0` will disable the use of HiDPI on all devices.
     *
     * @note Since the current pixelRatio may have been used in some calculations (e.g. the icons)
     * they may appear in the wrong size now. To ensure proper display of data, a call to
     * `clearTileCache()` is required if the pixelRatio is changed after tiles have been loaded.
     *
     * @memberof MapView
     */
    set pixelRatio(pixelRatio) {
        this.m_pixelRatio = pixelRatio;
        if (this.renderer.getPixelRatio() !== this.pixelRatio) {
            this.renderer.setPixelRatio(this.pixelRatio);
        }
    }
    /**
     * PixelRatio ratio for rendering when the camera is moving or an animation is running. Useful
     * when rendering on high resolution displays with low performance GPUs that may be
     * fill-rate-limited.
     *
     * If a value is specified, a low resolution render pass is used to render the scene into a
     * low resolution render target, before it is copied to the screen.
     *
     * A value of `undefined` disables the low res render pass. Values between 0.5 and
     * `window.devicePixelRatio` can be tried to give  good results. The value should not be larger
     * than `window.devicePixelRatio`.
     *
     * @note Since no anti-aliasing is applied during dynamic rendering with `dynamicPixelRatio`
     * defined, visual artifacts may occur, especially with thin lines..
     *
     * @note The resolution of icons and text labels is not affected.
     *
     * @default `undefined`
     */
    set dynamicPixelRatio(ratio) {
        this.mapRenderingManager.lowResPixelRatio = ratio;
    }
    get dynamicPixelRatio() {
        return this.mapRenderingManager.lowResPixelRatio;
    }
    /**
     * Returns the screen position of the given geo coordinates.
     *
     * @param geoPos The geo coordinates.
     * @returns The screen position in CSS/client coordinates (no pixel ratio applied) or
     * `undefined`.
     */
    getScreenPosition(geoPos) {
        const worldPos = new THREE.Vector3();
        this.projection.projectPoint(geoPos, worldPos);
        const p = this.m_screenProjector.project(worldPos);
        if (p !== undefined) {
            const { width, height } = this.getCanvasClientSize();
            p.x = p.x + width / 2;
            p.y = height - (p.y + height / 2);
        }
        return p;
    }
    /**
     * Returns a ray caster using the supplied screen positions.
     *
     * @param x The X position in css/client coordinates (without applied display ratio).
     * @param y The Y position in css/client coordinates (without applied display ratio).
     *
     * @alpha
     *
     * @return Raycaster with origin at the camera and direction based on the supplied x / y screen
     * points.
     */
    raycasterFromScreenPoint(x, y) {
        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_rteCamera);
        return this.m_raycaster;
    }
    /**
     * Returns the world space position from the given screen position. The return value can be
     * `null`, in case the camera is facing the horizon and the given `(x, y)` value is not
     * intersecting the ground plane.
     *
     * @param x The X position in css/client coordinates (without applied display ratio).
     * @param y The Y position in css/client coordinates (without applied display ratio).
     */
    getWorldPositionAt(x, y) {
        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_camera);
        const worldPosition = new THREE.Vector3();
        return this.projection.type === harp_geoutils_1.ProjectionType.Spherical
            ? this.m_raycaster.ray.intersectSphere(this.m_sphere, worldPosition)
            : this.m_raycaster.ray.intersectPlane(this.m_plane, worldPosition);
    }
    /**
     * Returns the [[GeoCoordinates]] from the given screen position. The return value can be
     * `null`, in case the camera is facing the horizon and the given `(x, y)` value is not
     * intersecting the ground plane.
     *
     * @param x The X position in css/client coordinates (without applied display ratio).
     * @param y The Y position in css/client coordinates (without applied display ratio).
     */
    getGeoCoordinatesAt(x, y) {
        const worldPosition = this.getWorldPositionAt(x, y);
        if (!worldPosition) {
            return null;
        }
        return this.projection.unprojectPoint(worldPosition);
    }
    /**
     * Returns the normalized screen coordinates from the given pixel position.
     *
     * @param x The X position in css/client coordinates (without applied display ratio).
     * @param y The Y position in css/client coordinates (without applied display ratio).
     */
    getNormalizedScreenCoordinates(x, y) {
        // use clientWidth and clientHeight as it does not apply the pixelRatio and
        // therefore supports also HiDPI devices
        const { width, height } = this.getCanvasClientSize();
        return new THREE.Vector3((x / width) * 2 - 1, -((y / height) * 2) + 1, 0);
    }
    /**
     * Do a raycast on all objects in the scene. Useful for picking. Limited to objects that
     * THREE.js can raycast, the solid lines that get their geometry in the shader cannot be tested
     * for intersection.
     *
     * Note, if a [[DataSource]] adds an [[Object3D]] to a [[Tile]], it will be only pickable once
     * [[MapView.render]] has been called, this is because [[MapView.render]] method creates the
     * internal three.js root [[Object3D]] which is used in the [[PickHandler]] internally.
     * This method will not test for intersection custom objects added to the scene by for
     * example calling directly the [[scene.add]] method from THREE.
     *
     * @param x The X position in css/client coordinates (without applied display ratio).
     * @param y The Y position in css/client coordinates (without applied display ratio).
     * @returns The list of intersection results.
     */
    intersectMapObjects(x, y) {
        return this.m_pickHandler.intersectMapObjects(x, y);
    }
    /**
     * Resize the HTML canvas element and the THREE.js `WebGLRenderer`.
     *
     * @param width The new width.
     * @param height The new height.
     */
    resize(width, height) {
        this.m_renderer.setSize(width, height, false);
        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {
            this.m_renderer.setPixelRatio(this.pixelRatio);
        }
        if (this.mapRenderingManager !== undefined) {
            this.mapRenderingManager.setSize(width, height);
        }
        if (this.collisionDebugCanvas !== undefined) {
            this.collisionDebugCanvas.width = width;
            this.collisionDebugCanvas.height = height;
        }
        this.updateCameras();
        this.update();
        this.dispatchEvent({
            type: MapViewEventNames.Resize,
            size: {
                width,
                height
            }
        });
    }
    /**
     * Requests a redraw of the scene.
     */
    update() {
        if (this.m_updatePending) {
            return;
        } // compress the update request
        this.m_updatePending = true;
        if (this.animating) {
            return;
        } // nothing to do
        this.drawFrame();
    }
    /**
     * Returns `true` if an update has already been requested, such that after a currently rendering
     * frame, the next frame will be rendered immediately.
     */
    get updatePending() {
        return this.m_updatePending;
    }
    /**
     * Requests a redraw of the scene.
     * @deprecated Use the [[update]] method instead.
     */
    requestUpdateIfNeeded() {
        this.update();
    }
    /**
     * Clear the tile cache.
     *
     * Remove the [[Tile]] objects created by cacheable [[DataSource]]s. If a [[DataSource]] name is
     * provided, this method restricts the eviction the [[DataSource]] with the given name.
     *
     * @param dataSourceName The name of the [[DataSource]].
     */
    clearTileCache(dataSourceName) {
        this.m_visibleTiles.clearTileCache(dataSourceName);
    }
    /**
     * Apply visitor to all visible tiles.
     *
     * @param fun Visitor function
     */
    forEachVisibleTile(fun) {
        this.m_visibleTiles.forEachVisibleTile(fun);
    }
    /**
     * Apply a visitor function to all tiles in the cache.
     *
     * @param visitor Visitor function
     */
    forEachCachedTile(visitor) {
        this.m_visibleTiles.forEachCachedTile(visitor);
    }
    /**
     * Visit each tile in visible, rendered, and cached sets.
     *
     *  * Visible and temporarily rendered tiles will be marked for update and retained.
     *  * Cached but not rendered/visible will be evicted.
     *
     * @param dataSource If passed, only the tiles from this [[DataSource]] instance are processed.
     * If `undefined`, tiles from all [[DataSource]]s are processed.
     */
    markTilesDirty(dataSource) {
        this.m_visibleTiles.markTilesDirty(dataSource);
    }
    /**
     * Sets the DataSource which contains the elevations, the elevation range source, and the
     * elevation provider. Only a single elevation source is possible per [[MapView]]
     *
     * If the terrain-datasource is merged with this repository, we could internally construct
     * the [[ElevationRangeSource]] and the [[ElevationProvider]] and access would be granted to
     * the application when it asks for it, to simplify the API.
     *
     * @param elevationSource The datasource containing the terrain tiles.
     * @param elevationRangeSource Allows access to the elevation min / max per tile.
     * @param elevationProvider Allows access to the elevation at a given location or a ray
     *      from the camera.
     */
    setElevationSource(elevationSource, elevationRangeSource, elevationProvider) {
        // Try to remove incase this method was already called, will do nothing if it doesn't exist.
        this.removeDataSource(elevationSource);
        this.addDataSource(elevationSource);
        this.m_elevationRangeSource = elevationRangeSource;
        this.m_elevationRangeSource.connect();
        this.m_elevationProvider = elevationProvider;
    }
    /**
     * Public access to [[MapViewFog]] allowing to toggle it by setting its `enabled` property.
     */
    get fog() {
        return this.m_fog;
    }
    setPostEffects() {
        // First clear all the effects, then enable them from what is specified.
        this.mapRenderingManager.bloom.enabled = false;
        this.mapRenderingManager.outline.enabled = false;
        this.mapRenderingManager.vignette.enabled = false;
        this.mapRenderingManager.sepia.enabled = false;
        if (this.m_postEffects !== undefined) {
            if (this.m_postEffects.bloom !== undefined) {
                this.mapRenderingManager.bloom = this.m_postEffects.bloom;
            }
            if (this.m_postEffects.outline !== undefined) {
                this.mapRenderingManager.outline.enabled = this.m_postEffects.outline.enabled;
                this.mapRenderingManager.updateOutline(this.m_postEffects.outline);
            }
            if (this.m_postEffects.vignette !== undefined) {
                this.mapRenderingManager.vignette = this.m_postEffects.vignette;
            }
            if (this.m_postEffects.sepia !== undefined) {
                this.mapRenderingManager.sepia = this.m_postEffects.sepia;
            }
        }
    }
    /**
     * Returns the elevation provider.
     */
    get elevationProvider() {
        return this.m_elevationProvider;
    }
    /**
     * Updates the camera and the projections and resets the screen collisions,
     * note, setupCamera must be called before this is called.
     */
    updateCameras() {
        const { width, height } = this.m_renderer.getSize(tmpVector);
        this.m_camera.aspect =
            this.m_forceCameraAspect !== undefined ? this.m_forceCameraAspect : width / height;
        this.setFovOnCamera(this.m_options.fovCalculation, height);
        let nearPlane = 0;
        let farPlane = 0;
        if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            // near and far plane for a set up where
            // the camera is looking at the center of the scene.
            const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;
            const d = this.m_camera.position.length();
            const alpha = Math.asin(r / d);
            const xaxis = new THREE.Vector3();
            const yaxis = new THREE.Vector3();
            const zaxis = new THREE.Vector3();
            this.m_camera.matrixWorld.extractBasis(xaxis, yaxis, zaxis);
            const q = new THREE.Quaternion();
            q.setFromAxisAngle(xaxis, alpha);
            const fwd = zaxis.clone().negate();
            const p = this.m_camera.position.clone();
            p.addScaledVector(fwd.clone().applyQuaternion(q), Math.sqrt(d * d - r * r));
            farPlane = p
                .clone()
                .sub(this.m_camera.position)
                .dot(fwd);
            const bias = 2000; // TODO: generalize.
            nearPlane = Math.max(1, this.projection.groundDistance(this.m_camera.position) - bias);
        }
        else {
            const kMinNear = 0.1;
            const kMultiplier = 50.0;
            const kFarOffset = 200.0;
            const groundDistance = this.projection.groundDistance(this.m_camera.position);
            nearPlane = Math.max(kMinNear, groundDistance * 0.1);
            farPlane = nearPlane * kMultiplier + kFarOffset;
            if (this.m_options.farPlaneEvaluator !== undefined) {
                this.m_camera.getWorldDirection(this.m_tempVector3);
                const angle = THREE.Math.radToDeg(this.m_tempVector3.angleTo(EYE_INVERSE));
                const nearFarPlane = this.m_options.farPlaneEvaluator(this, angle, nearPlane, farPlane);
                nearPlane = Math.max(kMinNear, nearFarPlane.near);
                farPlane = Math.max(nearPlane + kFarOffset, nearFarPlane.far);
            }
        }
        this.m_camera.near = nearPlane;
        this.m_camera.far = farPlane;
        this.m_camera.updateProjectionMatrix();
        this.m_camera.updateMatrixWorld(false);
        // Update the "relative to eye" camera. Copy the public camera parameters
        // and place the "relative to eye" at the world's origin.
        this.m_rteCamera.copy(this.m_camera);
        this.m_rteCamera.position.setScalar(0);
        this.m_rteCamera.updateMatrixWorld(true);
        this.m_screenCamera.left = width / -2;
        this.m_screenCamera.right = width / 2;
        this.m_screenCamera.bottom = height / -2;
        this.m_screenCamera.top = height / 2;
        this.m_screenCamera.updateProjectionMatrix();
        this.m_screenCamera.updateMatrixWorld(false);
        this.m_screenProjector.update(this.camera, width, height);
        this.m_screenCollisions.update(width, height);
        this.m_pixelToWorld = undefined;
        if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_lookAtDistance = this.projection.groundDistance(this.m_camera.position);
            this.m_zoomLevel = Utils_1.MapViewUtils.calculateZoomLevelFromDistance(this.projection.groundDistance(this.m_camera.position), this);
        }
        else {
            const cameraPitch = Utils_1.MapViewUtils.extractYawPitchRoll(this.m_camera.quaternion).pitch;
            const cameraPosZ = Math.abs(this.projection.groundDistance(this.m_camera.position));
            this.m_lookAtDistance = cameraPosZ / Math.cos(cameraPitch);
            const zoomLevelDistance = cameraPosZ / Math.cos(Math.min(cameraPitch, Math.PI / 3));
            this.m_zoomLevel = Utils_1.MapViewUtils.calculateZoomLevelFromDistance(zoomLevelDistance, this);
        }
    }
    detectCurrentFps(now) {
        // Skip the first frames, they are from not originated from requestAnimationFrame()
        if (this.m_previousRequestAnimationTime !== undefined && this.m_frameNumber > 5) {
            const currentFps = 1000 / (now - this.m_previousRequestAnimationTime);
            this.m_frameTimeRing[this.m_frameTimeIndex % FRAME_RATE_RING_SIZE] = currentFps;
            this.m_frameTimeIndex++;
            const capturedFrames = Math.min(this.m_frameTimeIndex, FRAME_RATE_RING_SIZE);
            let sum = 0;
            for (let i = 0; i < capturedFrames; i++) {
                sum += this.m_frameTimeRing[i];
            }
            this.m_detectedFps = sum / capturedFrames;
        }
        this.m_previousRequestAnimationTime = now;
    }
    /**
     * Draw a new frame.
     */
    drawFrame() {
        if (this.m_drawing) {
            return;
        }
        // Cancel an active requestAnimationFrame() cycle. Failure to do this may end up in
        // rendering multiple times during a single frame.
        if (this.m_animationFrameHandle !== undefined) {
            cancelAnimationFrame(this.m_animationFrameHandle);
            this.m_animationFrameHandle = undefined;
        }
        if (this.m_maxFps <= 0) {
            // Render at maximum FPS.
            this.m_animationFrameHandle = requestAnimationFrame(this.handleRequestAnimationFrame);
            return;
        }
        // Magic ingredient to compensate time flux.
        const fudgeTimeInMs = 3;
        const vSyncFrameTime = 1000 / this.m_detectedFps;
        const frameInterval = 1000 / this.m_maxFps;
        const previousFrameTime = this.m_previousFrameTimeStamp === undefined ? 0 : this.m_previousFrameTimeStamp;
        // Compute a practical value to compare against.
        const targetTime = previousFrameTime + frameInterval - vSyncFrameTime - fudgeTimeInMs;
        this.m_targetRequestAnimationTime = targetTime;
        this.postponedAnimationFrame(previousFrameTime);
    }
    postponedAnimationFrame(now) {
        if (this.m_targetRequestAnimationTime === undefined) {
            return;
        }
        if (this.m_animationFrameHandle !== undefined) {
            cancelAnimationFrame(this.m_animationFrameHandle);
            this.m_animationFrameHandle = undefined;
        }
        this.detectCurrentFps(now);
        this.m_animationFrameHandle = requestAnimationFrame(now > this.m_targetRequestAnimationTime
            ? this.handleRequestAnimationFrame
            : this.handlePostponedAnimationFrame);
    }
    /**
     * Draw a new frame.
     */
    renderFunc(time) {
        this.render(time);
    }
    /**
     * Returns the list of the enabled data sources.
     */
    getEnabledTileDataSources() {
        // ### build this list once decoders && datasources are ready
        const enabledDataSources = [];
        for (const dataSource of this.m_tileDataSources) {
            if (!dataSource.enabled) {
                continue;
            }
            if (!dataSource.ready()) {
                continue;
            }
            if (!this.m_connectedDataSources.has(dataSource.name)) {
                continue;
            }
            enabledDataSources.push(dataSource);
        }
        return enabledDataSources;
    }
    /**
     * Renders the current frame.
     */
    render(time) {
        if (this.m_drawing) {
            return;
        }
        ++this.m_frameNumber;
        const stats = Statistics_1.PerformanceStatistics.instance;
        const gatherStatistics = stats.enabled;
        const frameStartTime = time;
        RENDER_EVENT.time = time;
        this.dispatchEvent(RENDER_EVENT);
        let currentFrameEvent;
        if (gatherStatistics) {
            currentFrameEvent = stats.currentFrame;
            currentFrameEvent.setValue("renderCount.frameNumber", this.m_frameNumber);
            if (this.m_previousFrameTimeStamp !== undefined) {
                const timeSincePreviousFrame = frameStartTime - this.m_previousFrameTimeStamp;
                if (gatherStatistics) {
                    currentFrameEvent.setValue("render.fullFrameTime", timeSincePreviousFrame);
                    // For convenience and easy readability
                    currentFrameEvent.setValue("render.fps", 1000 / timeSincePreviousFrame);
                }
            }
        }
        this.m_previousFrameTimeStamp = frameStartTime;
        let setupTime;
        let cullTime;
        let textPlacementTime;
        let drawTime;
        let textDrawTime;
        let endTime;
        this.m_renderer.info.reset();
        this.m_updatePending = false;
        this.m_thisFrameTilesChanged = undefined;
        this.m_drawing = true;
        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {
            this.m_renderer.setPixelRatio(this.pixelRatio);
        }
        this.updateCameras();
        this.m_fog.update(this.m_camera);
        this.m_renderer.clear();
        // clear the scene
        while (this.m_mapTilesRoot.children.length > 0) {
            this.m_mapTilesRoot.remove(this.m_mapTilesRoot.children[0]);
        }
        if (gatherStatistics) {
            setupTime = harp_utils_1.PerformanceTimer.now();
        }
        // TBD: Update renderList only any of its params (camera, etc...) has changed.
        if (!this.lockVisibleTileSet) {
            this.m_visibleTiles.updateRenderList(this.m_camera.position, this.storageLevel, Math.floor(this.zoomLevel), this.getEnabledTileDataSources(), this.m_elevationRangeSource);
        }
        if (gatherStatistics) {
            cullTime = harp_utils_1.PerformanceTimer.now();
        }
        const renderList = this.m_visibleTiles.dataSourceTileList;
        renderList.forEach(({ zoomLevel, renderedTiles }) => {
            renderedTiles.forEach(tile => {
                this.renderTileObjects(tile, zoomLevel);
                //We know that rendered tiles are visible (in the view frustum), so we update the
                //frame number, note we don't do this for the visibleTiles because some may still be
                //loading (and therefore aren't visible in the sense of being seen on the screen).
                //Note also, this number isn't currently used anywhere so should be considered to be
                //removed in the future (though could be good for debugging purposes).
                tile.frameNumLastVisible = this.m_frameNumber;
            });
        });
        this.m_mapAnchors.children.forEach((childObject) => {
            if (childObject.geoPosition === undefined) {
                return;
            }
            this.projection.projectPoint(childObject.geoPosition, childObject.position);
            childObject.position.sub(this.camera.position);
        });
        this.m_animatedExtrusionHandler.zoom = this.m_zoomLevel;
        if (currentFrameEvent !== undefined) {
            // Make sure the counters all have a value.
            currentFrameEvent.addValue("renderCount.numTilesRendered", 0);
            currentFrameEvent.addValue("renderCount.numTilesVisible", 0);
            currentFrameEvent.addValue("renderCount.numTilesLoading", 0);
            // Increment the counters for all data sources.
            renderList.forEach(({ zoomLevel, renderedTiles, visibleTiles, numTilesLoading }) => {
                currentFrameEvent.addValue("renderCount.numTilesRendered", renderedTiles.length);
                currentFrameEvent.addValue("renderCount.numTilesVisible", visibleTiles.length);
                currentFrameEvent.addValue("renderCount.numTilesLoading", numTilesLoading);
            });
        }
        this.m_movementDetector.checkCameraMoved(this, time);
        // The camera used to render the scene.
        const camera = this.m_pointOfView !== undefined ? this.m_pointOfView : this.m_rteCamera;
        if (this.renderLabels) {
            this.prepareRenderTextElements(time);
        }
        if (gatherStatistics) {
            textPlacementTime = harp_utils_1.PerformanceTimer.now();
        }
        if (this.m_skyBackground !== undefined && this.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            this.m_skyBackground.updateCamera(this.m_camera);
        }
        const isDynamicFrame = this.cameraIsMoving || this.animating || this.m_updatePending;
        this.mapRenderingManager.render(this.m_renderer, this.m_scene, camera, !isDynamicFrame);
        if (gatherStatistics) {
            drawTime = harp_utils_1.PerformanceTimer.now();
        }
        if (this.renderLabels) {
            this.finishRenderTextElements();
        }
        if (gatherStatistics) {
            textDrawTime = harp_utils_1.PerformanceTimer.now();
        }
        if (!this.m_firstFrameRendered) {
            this.m_firstFrameRendered = true;
            if (gatherStatistics) {
                stats.appResults.set("firstFrame", time);
            }
            FIRST_FRAME_EVENT.time = time;
            this.dispatchEvent(FIRST_FRAME_EVENT);
        }
        if (!this.m_firstFrameComplete &&
            this.m_visibleTiles.allVisibleTilesLoaded &&
            this.m_connectedDataSources.size === this.m_tileDataSources.length &&
            !this.m_updatePending &&
            !this.animating &&
            this.m_textElementsRenderer !== undefined &&
            !this.m_textElementsRenderer.loading) {
            this.m_firstFrameComplete = true;
            if (gatherStatistics) {
                stats.appResults.set("firstFrameComplete", time);
            }
            FRAME_COMPLETE_EVENT.time = time;
            this.dispatchEvent(FRAME_COMPLETE_EVENT);
        }
        this.m_visibleTiles.disposePendingTiles();
        this.m_drawing = false;
        if (this.animating || this.m_updatePending) {
            this.drawFrame();
        }
        this.checkCopyrightUpdates();
        if (currentFrameEvent !== undefined) {
            endTime = harp_utils_1.PerformanceTimer.now();
            currentFrameEvent.setValue("render.setupTime", setupTime - frameStartTime);
            currentFrameEvent.setValue("render.cullTime", cullTime - setupTime);
            currentFrameEvent.setValue("render.textPlacementTime", textPlacementTime - cullTime);
            currentFrameEvent.setValue("render.drawTime", drawTime - textPlacementTime);
            currentFrameEvent.setValue("render.textDrawTime", textDrawTime - drawTime);
            currentFrameEvent.setValue("render.cleanupTime", endTime - textDrawTime);
            currentFrameEvent.setValue("render.frameRenderTime", endTime - frameStartTime);
            Statistics_1.PerformanceStatistics.instance.storeFrameInfo(this.m_renderer.info);
        }
        DID_RENDER_EVENT.time = time;
        this.dispatchEvent(DID_RENDER_EVENT);
    }
    renderTileObjects(tile, zoomLevel) {
        const worldOffsetX = this.projection.worldExtent(0, 0).max.x * tile.offset;
        if (tile.willRender(zoomLevel)) {
            for (const object of tile.objects) {
                object.position.copy(tile.center);
                if (object.displacement !== undefined) {
                    object.position.add(object.displacement);
                }
                object.position.x += worldOffsetX;
                object.position.sub(this.m_camera.position);
                this.m_mapTilesRoot.add(object);
            }
        }
        tile.didRender();
    }
    prepareRenderTextElements(time) {
        // Disable rendering of text elements for debug camera. TextElements are rendered using an
        // orthographic camera that covers the entire available screen space. Unfortunately, this
        // particular camera set up is not compatible with the debug camera.
        const debugCameraActive = this.m_pointOfView !== undefined;
        if (this.m_textElementsRenderer === undefined ||
            !this.m_textElementsRenderer.ready ||
            debugCameraActive) {
            return;
        }
        if (this.checkIfTextElementsChanged() || this.checkIfTilesChanged()) {
            this.m_textElementsRenderer.placeAllTileLabels();
        }
        // User TextElements have the priority when it comes to reserving screen space, so
        // they are handled first. They will be rendered after the normal map objects and
        // TextElements
        this.m_textElementsRenderer.reset();
        this.m_textElementsRenderer.renderUserTextElements(time, this.m_frameNumber);
        this.m_textElementsRenderer.renderAllTileText(time, this.m_frameNumber);
        this.m_textElementsRenderer.renderOverlay(this.m_overlayTextElements);
        this.m_textElementsRenderer.update();
    }
    finishRenderTextElements() {
        const canRenderTextElements = this.m_pointOfView === undefined;
        if (canRenderTextElements && this.m_textElementsRenderer) {
            // copy far value from scene camera, as the distance to the POIs matter now.
            this.m_screenCamera.far = this.m_camera.far;
            this.m_textElementsRenderer.renderText(this.m_screenCamera);
        }
    }
    initTheme() {
        if (this.m_options.theme === undefined) {
            return;
        }
        const themePromise = typeof this.m_options.theme === "string"
            ? ThemeLoader_1.ThemeLoader.loadAsync(this.m_options.theme)
            : Promise.resolve(this.m_options.theme);
        themePromise.then((theme) => {
            this.theme = theme;
            THEME_LOADED_EVENT.time = Date.now();
            this.dispatchEvent(THEME_LOADED_EVENT);
        });
    }
    setupCamera() {
        const { width, height } = this.getCanvasClientSize();
        const defaultGeoCenter = new harp_geoutils_1.GeoCoordinates(52.518611, 13.376111, 3000);
        this.projection.projectPoint(defaultGeoCenter, this.m_camera.position);
        if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_camera.lookAt(this.scene.position);
        }
        this.m_lookAtDistance = defaultGeoCenter.altitude;
        this.calculateFocalLength(height);
        this.m_visibleTiles = new VisibleTileSet_1.VisibleTileSet(this.m_camera, this.m_tileGeometryManager, this.m_visibleTileSetOptions);
        // ### move & customize
        this.resize(width, height);
        this.geoCenter = defaultGeoCenter;
        this.m_screenCamera.position.z = 1;
        this.m_screenCamera.near = 0;
    }
    updateSkyBackground() {
        if (this.m_theme === undefined) {
            return;
        }
        const theme = this.m_theme;
        if (this.m_skyBackground instanceof SkyBackground_1.SkyBackground && theme.sky !== undefined) {
            // there is a sky in the view and there is a sky option in the theme. Update the colors
            this.updateSkyBackgroundColors(theme.sky, theme.clearColor);
        }
        else if (this.m_skyBackground === undefined && theme.sky !== undefined) {
            // there is no sky in the view but there is a sky option in the theme
            this.addNewSkyBackground(theme.sky, theme.clearColor);
            return;
        }
        else if (this.m_skyBackground instanceof SkyBackground_1.SkyBackground && theme.sky === undefined) {
            // there is a sky in the view, but not in the theme
            this.removeSkyBackGround();
        }
    }
    addNewSkyBackground(sky, clearColor) {
        if (sky.type === "gradient" && sky.groundColor === undefined) {
            sky.groundColor = harp_utils_1.getOptionValue(clearColor, "#000000");
        }
        this.m_skyBackground = new SkyBackground_1.SkyBackground(sky, this.projection.type, this.m_camera);
        this.m_scene.background = this.m_skyBackground.texture;
    }
    removeSkyBackGround() {
        this.m_scene.background = null;
        if (this.m_skyBackground !== undefined) {
            this.m_skyBackground.dispose();
            this.m_skyBackground = undefined;
        }
    }
    updateSkyBackgroundColors(sky, clearColor) {
        if (sky.type === "gradient" && sky.groundColor === undefined) {
            sky.groundColor = harp_utils_1.getOptionValue(clearColor, "#000000");
        }
        if (this.m_skyBackground !== undefined) {
            this.m_skyBackground.updateTexture(sky, this.projection.type);
        }
    }
    updateLighting() {
        if (!this.m_theme) {
            return;
        }
        const theme = this.m_theme;
        if (theme.clearColor !== undefined) {
            this.m_renderer.setClearColor(new THREE.Color(theme.clearColor));
        }
        if (this.m_createdLights) {
            this.m_createdLights.forEach((light) => {
                this.m_scene.remove(light);
            });
        }
        if (theme.lights !== undefined) {
            this.m_createdLights = [];
            theme.lights.forEach((lightDescription) => {
                const light = ThemeHelpers_1.createLight(lightDescription);
                if (!light) {
                    logger.log(
                    // tslint:disable-next-line: max-line-length
                    `MapView: failed to create light ${lightDescription.name} of type ${lightDescription.type}`);
                    return;
                }
                this.m_scene.add(light);
                this.m_createdLights.push(light);
            });
        }
    }
    movementStarted() {
        if (this.m_textElementsRenderer !== undefined) {
            this.m_textElementsRenderer.movementStarted();
        }
        MOVEMENT_STARTED_EVENT.time = Date.now();
        this.dispatchEvent(MOVEMENT_STARTED_EVENT);
    }
    movementFinished() {
        if (this.m_textElementsRenderer !== undefined) {
            this.m_textElementsRenderer.movementFinished();
        }
        MOVEMENT_FINISHED_EVENT.time = Date.now();
        this.dispatchEvent(MOVEMENT_FINISHED_EVENT);
        // render at the next possible time.
        if (!this.animating) {
            setTimeout(() => this.update(), 0);
        }
    }
    /**
     * Check if the `textElementsChanged` flag in any tile has been set to `true`. If any flag was
     * `true`, this function returns `true`, and resets the flag in all tiles to `false`.
     */
    checkIfTextElementsChanged() {
        const renderList = this.m_visibleTiles.dataSourceTileList;
        let textElementsChanged = false;
        renderList.forEach(({ renderedTiles }) => {
            renderedTiles.forEach(tile => {
                if (tile.textElementsChanged) {
                    tile.textElementsChanged = false;
                    textElementsChanged = true;
                }
            });
        });
        return textElementsChanged;
    }
    /**
     * Check if the set of visible tiles changed since the last frame.
     *
     * May be called multiple times per frame.
     *
     * Equality is computed by creating a string containing the IDs of the tiles.
     */
    checkIfTilesChanged() {
        if (this.m_thisFrameTilesChanged !== undefined) {
            return this.m_thisFrameTilesChanged;
        }
        const renderList = this.m_visibleTiles.dataSourceTileList;
        const tileIdList = [];
        tileIdList.length = 0;
        renderList.forEach(({ dataSource, renderedTiles }) => {
            renderedTiles.forEach(tile => {
                tileIdList.push(dataSource.name + "-" + tile.tileKey.mortonCode());
            });
        });
        tileIdList.sort();
        const newTileIds = tileIdList.join("#");
        if (newTileIds !== this.m_lastTileIds) {
            this.m_lastTileIds = newTileIds;
            this.m_thisFrameTilesChanged = true;
        }
        else {
            this.m_thisFrameTilesChanged = false;
        }
        return this.m_thisFrameTilesChanged;
    }
    checkCopyrightUpdates() {
        if (!this.checkIfTilesChanged()) {
            return;
        }
        const newCopyrightInfo = this.getRenderedTilesCopyrightInfo();
        if (newCopyrightInfo === this.m_copyrightInfo) {
            return;
        }
        if (newCopyrightInfo.length === this.m_copyrightInfo.length) {
            let allEqual = true;
            for (let i = 0; i < newCopyrightInfo.length; i++) {
                const a = newCopyrightInfo[i];
                const b = this.m_copyrightInfo[i];
                if (a.label !== b.label) {
                    allEqual = false;
                    break;
                }
            }
            if (allEqual) {
                return;
            }
        }
        this.m_copyrightInfo = newCopyrightInfo;
        this.dispatchEvent(COPYRIGHT_CHANGED_EVENT);
    }
    getRenderedTilesCopyrightInfo() {
        let result = [];
        for (const tileList of this.m_visibleTiles.dataSourceTileList) {
            for (const tile of tileList.renderedTiles) {
                const tileCopyrightInfo = tile.copyrightInfo;
                if (tileCopyrightInfo === undefined || tileCopyrightInfo.length === 0) {
                    continue;
                }
                result = CopyrightInfo_1.CopyrightInfo.mergeArrays(result, tileCopyrightInfo);
            }
        }
        return result;
    }
    updateImages() {
        if (!this.m_theme) {
            return;
        }
        const theme = this.m_theme;
        this.m_imageCache.clear();
        this.poiManager.clear();
        if (theme.images !== undefined) {
            for (const name of Object.keys(theme.images)) {
                const image = theme.images[name];
                this.m_imageCache.addImage(name, image.url, image.preload === true);
                if (typeof image.atlas === "string") {
                    this.poiManager.addTextureAtlas(name, image.atlas);
                }
            }
        }
        if (theme.imageTextures !== undefined) {
            theme.imageTextures.forEach((imageTexture) => {
                this.poiManager.addImageTexture(imageTexture);
            });
        }
    }
    loadPoiTables() {
        if (this.m_theme === undefined) {
            return;
        }
        this.poiTableManager.clear();
        // Add the POI tables defined in the theme.
        this.poiTableManager.loadPoiTables(this.m_theme);
    }
    setupStats(enable) {
        // tslint:disable-next-line:no-unused-expression
        new Statistics_1.PerformanceStatistics(enable, 1000);
    }
    setupRenderer() {
        this.m_renderer.setClearColor(DEFAULT_CLEAR_COLOR);
        this.m_scene.add(this.m_mapTilesRoot);
        this.m_scene.add(this.m_mapAnchors);
    }
    /**
     * Gradually initialize & update TextRenderer as assets arrive.
     */
    updateTextRenderer() {
        if (this.m_theme.textStyles === undefined) {
            return;
        }
        if (this.m_textElementsRenderer === undefined) {
            this.m_textElementsRenderer = new TextElementsRenderer_1.TextElementsRenderer(this, this.m_screenCollisions, this.m_screenProjector, this.m_options.minNumGlyphs, this.m_options.maxNumGlyphs, this.m_theme, this.m_options.maxNumVisibleLabels, this.m_options.numSecondChanceLabels, this.m_options.maxDistanceRatioForLabels, this.m_options.labelStartScaleDistance);
        }
        this.m_textElementsRenderer.placeAllTileLabels();
    }
    limitFov(fov, aspect) {
        fov = harp_geoutils_1.MathUtils.clamp(fov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);
        let hFov = harp_geoutils_1.MathUtils.radToDeg(Utils_1.MapViewUtils.calculateHorizontalFovByVerticalFov(harp_geoutils_1.MathUtils.degToRad(fov), aspect));
        if (hFov > MAX_FIELD_OF_VIEW || hFov < MIN_FIELD_OF_VIEW) {
            hFov = harp_geoutils_1.MathUtils.clamp(hFov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);
            fov = harp_geoutils_1.MathUtils.radToDeg(Utils_1.MapViewUtils.calculateVerticalFovByHorizontalFov(harp_geoutils_1.MathUtils.degToRad(hFov), aspect));
        }
        return fov;
    }
    /**
     * Sets the field of view calculation, and applies it immediately to the camera.
     *
     * @param type How to calculate the FOV
     */
    setFovOnCamera(fovCalculation, height) {
        let fov = 0;
        if (fovCalculation.type === "fixed") {
            this.calculateFocalLength(height);
            fov = fovCalculation.fov;
        }
        else {
            harp_utils_1.assert(this.m_focalLength !== 0);
            fov = Utils_1.MapViewUtils.calculateFovByFocalLength(this.m_focalLength, height);
        }
        this.m_camera.fov = this.limitFov(fov, this.m_camera.aspect);
    }
    /**
     * Sets the focal length based on the supplied fov and the height of the canvas. This must be
     * called at least once. This is necessary to be recalled when the [[FovCalculation]]'s type is
     * fixed. In such cases, when the height changes, the focal length must be readjusted whereas
     * the FOV stays the same. The opposite is true for the dynamic case, where the focal length is
     * fixed but the FOV changes.
     * @param height Height of the canvas in css / client pixels.
     */
    calculateFocalLength(height) {
        harp_utils_1.assert(this.m_options.fovCalculation !== undefined);
        this.m_focalLength = Utils_1.MapViewUtils.calculateFocalLengthByVerticalFov(harp_geoutils_1.MathUtils.degToRad(this.m_options.fovCalculation.fov), height);
    }
    /**
     * Get canvas client size in css/client pixels.
     *
     * Supports canvases not attached to DOM, which have 0 as `clientWidth` and `clientHeight` by
     * calculating it from actual canvas size and current pixel ratio.
     */
    getCanvasClientSize() {
        const { clientWidth, clientHeight } = this.canvas;
        if (clientWidth === 0 ||
            clientHeight === 0 ||
            typeof clientWidth !== "number" ||
            typeof clientHeight !== "number") {
            const pixelRatio = this.m_renderer.getPixelRatio();
            return {
                width: Math.round(this.canvas.width / pixelRatio),
                height: Math.round(this.canvas.height / pixelRatio)
            };
        }
        else {
            return { width: clientWidth, height: clientHeight };
        }
    }
}
exports.MapView = MapView;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapViewFog.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapViewFog.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Manages the fog display in [[MapView]].
 */
class MapViewFog {
    /**
     * Constructs a `MapViewFog` instance.
     *
     * @param m_scene The scene used in [[MapView]] that contains the map objects.
     */
    constructor(m_scene) {
        this.m_scene = m_scene;
        this.m_enabled = true;
        this.m_fog = new THREE.Fog(0x000000); // Default color asked by DefinitelyTyped.
        this.m_fogIsDefined = false;
        this.m_cachedTheme = { styles: {} };
    }
    /**
     * Allows for disabling the fog, even if it is defined in the theme. Use this property for
     * custom views like the demo app's debug camera. However, if the theme does not define a
     * fog, enabling this property here has no effect.
     *
     * @param value A boolean that specifies whether the fog should be enabled or disabled.
     */
    set enabled(enableFog) {
        this.m_enabled = enableFog;
        if (enableFog && this.m_fogIsDefined && this.m_scene.fog === null) {
            this.add();
        }
        else if (!enableFog && this.m_scene.fog !== null) {
            this.remove();
        }
    }
    /**
     * Returns the current fog status, enabled or disabled.
     */
    get enabled() {
        return this.m_enabled;
    }
    /**
     * Sets the fog depending on the [[Theme]] instance provided. This function is called when a
     * theme is loaded. Fog is added only if the theme contains a fog definition with a:
     * - `color` property, used to set the fog color.
     * - `startRatio` property, used to set the start distance of the fog as a ratio of the far
     * clipping plane distance.
     *
     * @param theme A [[Theme]] instance.
     */
    reset(theme) {
        this.m_cachedTheme = theme;
        if (theme !== undefined &&
            theme.fog !== undefined &&
            theme.fog.color !== undefined &&
            theme.fog.startRatio !== undefined) {
            this.m_fogIsDefined = true;
            this.m_fog.color.set(theme.fog.color);
            if (this.m_enabled && this.m_scene.fog === null) {
                this.add();
            }
        }
        else {
            this.m_fogIsDefined = false;
            if (this.m_scene.fog !== null) {
                this.remove();
            }
        }
    }
    /**
     * Updates the fog at runtime, depending on the camera.
     *
     * @param camera An instance of a `THREE.Camera` with a `far` property.
     */
    update(camera) {
        if (this.m_scene.fog !== null &&
            camera.far !== undefined &&
            this.m_cachedTheme !== undefined &&
            this.m_cachedTheme.fog &&
            this.m_cachedTheme.fog.startRatio !== undefined) {
            this.m_fog.far = camera.far;
            this.m_fog.near = camera.far * this.m_cachedTheme.fog.startRatio;
        }
    }
    /**
     * Handles fog addition.
     */
    add() {
        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...
        this.m_scene.fog = this.m_fog;
        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.
        this.setFogInRawShaderMaterials(true);
    }
    /**
     * Handles fog removal.
     */
    remove() {
        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...
        this.m_scene.fog = null;
        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.
        this.setFogInRawShaderMaterials(false);
    }
    /**
     * ThreeJS lets users manage the `RawShaderMaterial` themselves, so they need to be modified
     * explicitly.
     *
     * @see https://github.com/mrdoob/three.js/blob/dev/src/renderers/webgl/WebGLProgram.js#L298
     */
    setFogInRawShaderMaterials(enableFog) {
        this.m_scene.traverse(object => {
            if (object instanceof THREE.Mesh) {
                if (object.material instanceof THREE.Material) {
                    if (object.material instanceof THREE.Material &&
                        // HighPrecisionLineMaterial does not support fog
                        !(object.material instanceof harp_materials_1.HighPrecisionLineMaterial)) {
                        if (object.material instanceof harp_materials_1.SolidLineMaterial) {
                            const material = object.material;
                            material.updateFog(enableFog);
                        }
                        object.material.fog = enableFog;
                        object.material.needsUpdate = true;
                    }
                }
            }
        });
    }
}
exports.MapViewFog = MapViewFog;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapViewPoints.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapViewPoints.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * `MapViewPoints` is a class to extend for the `"circles"` and `"squares"` [[Technique]]s to
 * implement raycasting of [[THREE.Points]] as expected in [[MapView]], that is in screen space. It
 * copies the behaviour of the `raycast` method in [[THREE.Points]] and dispatches it to its
 * children classes, [[Circles]] and [[Squares]], who hold the intersection testing in the
 * `testPoint` method. This class also has the ability to dismiss the testing via the
 * `enableRayTesting` flag.
 *
 * Its main motivation is to handle the point styles of XYZ projects.
 *
 * @see https://github.com/mrdoob/three.js/blob/master/src/objects/Points.js
 */
class MapViewPoints extends THREE.Points {
    constructor() {
        super(...arguments);
        /**
         * This allows to discard the ray testing.
         */
        this.enableRayTesting = true;
    }
    /**
     * This method is similar to the original method `raycast` in [[THREE.Points]] except that it
     * then calls the tailored `testPoint` method in the children classes to test intersections
     * depending on whether the points are circles or squares, which [[THREE.Points]] cannot do.
     *
     * @param raycaster The raycaster.
     * @param intersects The array to fill with the results.
     */
    raycast(raycaster, intersects) {
        if (!this.enableRayTesting) {
            return;
        }
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const screenCoords = raycaster.ray.origin
            .clone()
            .add(raycaster.ray.direction)
            .project(raycaster.mapView.camera);
        const { clientWidth, clientHeight } = raycaster.mapView.canvas;
        const mouseCoords = new THREE.Vector2(Math.ceil(((screenCoords.x + 1) / 2) * clientWidth), Math.ceil(((1 - screenCoords.y) / 2) * clientHeight));
        if (geometry instanceof THREE.BufferGeometry) {
            const point = new THREE.Vector3();
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positions = attributes.position.array;
            if (index !== null) {
                const indices = index.array;
                for (let i = 0, il = indices.length; i < il; i++) {
                    const a = indices[i];
                    point.fromArray(positions, a * 3);
                    const pointInfo = getPointInfo(point, matrixWorld, raycaster, clientWidth, clientHeight);
                    if (pointInfo.pointIsOnScreen) {
                        this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, i, pointInfo.distance, intersects);
                    }
                }
            }
            else {
                for (let i = 0, l = positions.length / 3; i < l; i++) {
                    point.fromArray(positions, i * 3);
                    const pointInfo = getPointInfo(point, matrixWorld, raycaster, clientWidth, clientHeight);
                    if (pointInfo.pointIsOnScreen) {
                        this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, i, pointInfo.distance, intersects);
                    }
                }
            }
        }
        else {
            const vertices = geometry.vertices;
            for (let index = 0; index < vertices.length; index++) {
                const point = vertices[index];
                const pointInfo = getPointInfo(point, matrixWorld, raycaster, clientWidth, clientHeight);
                if (pointInfo.pointIsOnScreen) {
                    this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, index, pointInfo.distance, intersects);
                }
            }
        }
    }
}
exports.MapViewPoints = MapViewPoints;
function getPointInfo(point, matrixWorld, raycaster, width, height) {
    const worldPosition = point.clone();
    worldPosition.applyMatrix4(matrixWorld);
    const distance = worldPosition.distanceTo(raycaster.ray.origin);
    worldPosition.project(raycaster.mapView.camera);
    const relativeScreenPosition = new THREE.Vector2(worldPosition.x, worldPosition.y);
    const pointIsOnScreen = relativeScreenPosition.x < 1 &&
        relativeScreenPosition.x > -1 &&
        relativeScreenPosition.y < 1 &&
        relativeScreenPosition.y > -1;
    if (pointIsOnScreen) {
        worldPosition.x = ((worldPosition.x + 1) / 2) * width;
        worldPosition.y = ((1 - worldPosition.y) / 2) * height;
        const absoluteScreenPosition = new THREE.Vector2(worldPosition.x, worldPosition.y);
        return {
            absoluteScreenPosition,
            pointIsOnScreen,
            distance
        };
    }
    return {
        pointIsOnScreen
    };
}
/**
 * Point object that implements the raycasting of circles in screen space.
 */
class Circles extends MapViewPoints {
    testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {
        const dx = screenPosition.x - pickCoordinates.x;
        const dy = screenPosition.y - pickCoordinates.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const radius = this.material.size / 2;
        if (dist <= radius) {
            intersects.push({
                point,
                distance,
                index,
                object: this
            });
        }
    }
}
exports.Circles = Circles;
/**
 * Point object that implements the raycasting of squares in screen space.
 */
class Squares extends MapViewPoints {
    testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {
        const dx = screenPosition.x - pickCoordinates.x;
        const dy = screenPosition.y - pickCoordinates.y;
        const halfSize = this.material.size / 2;
        if (Math.abs(dx) <= halfSize && Math.abs(dy) <= halfSize) {
            intersects.push({
                point,
                distance,
                index,
                object: this
            });
        }
    }
}
exports.Squares = Squares;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/PickHandler.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/PickHandler.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const MapViewPoints_1 = __webpack_require__(/*! ./MapViewPoints */ "./node_modules/@here/harp-mapview/lib/MapViewPoints.js");
const PickingRaycaster_1 = __webpack_require__(/*! ./PickingRaycaster */ "./node_modules/@here/harp-mapview/lib/PickingRaycaster.js");
const RoadPicker_1 = __webpack_require__(/*! ./RoadPicker */ "./node_modules/@here/harp-mapview/lib/RoadPicker.js");
/**
 * Describes the general type of a picked object.
 */
var PickObjectType;
(function (PickObjectType) {
    /**
     * Unspecified.
     */
    PickObjectType[PickObjectType["Unspecified"] = 0] = "Unspecified";
    /**
     * A point object.
     */
    PickObjectType[PickObjectType["Point"] = 1] = "Point";
    /**
     * A line object.
     */
    PickObjectType[PickObjectType["Line"] = 2] = "Line";
    /**
     * An area object.
     */
    PickObjectType[PickObjectType["Area"] = 3] = "Area";
    /**
     * The text part of a [[TextElement]]
     */
    PickObjectType[PickObjectType["Text"] = 4] = "Text";
    /**
     * The Icon of a [[TextElement]].
     */
    PickObjectType[PickObjectType["Icon"] = 5] = "Icon";
    /**
     * Any general 3D object, for example, a landmark.
     */
    PickObjectType[PickObjectType["Object3D"] = 6] = "Object3D";
})(PickObjectType = exports.PickObjectType || (exports.PickObjectType = {}));
/**
 * Handles the picking of scene geometry and roads.
 */
class PickHandler {
    constructor(mapView, camera, enableRoadPicking = true) {
        this.mapView = mapView;
        this.camera = camera;
        this.enableRoadPicking = enableRoadPicking;
        this.m_plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));
        this.m_rayCaster = new PickingRaycaster_1.PickingRaycaster(mapView);
        if (enableRoadPicking) {
            this.m_roadPicker = new RoadPicker_1.RoadPicker(mapView);
        }
    }
    /**
     * The `RoadPicker` class manages picking of roads, which may not be pickable in THREE.js,
     * since their geometry is generated in the vertex shader. The `RoadPicker` requires that
     * all [[Tile]]s are registered before they can be picked successfully.
     */
    registerTile(tile) {
        return this.m_roadPicker !== undefined ? this.m_roadPicker.registerTile(tile) : undefined;
    }
    /**
     * Does a raycast on all objects in the scene; useful for picking. This function is Limited to
     * objects that THREE.js can raycast. However, any solid lines that have their geometry in the
     * shader cannot be tested for intersection.
     *
     * @param x The X position in CSS/client coordinates, without the applied display ratio.
     * @param y The Y position in CSS/client coordinates, without the applied display ratio.
     * @returns the list of intersection results.
     */
    intersectMapObjects(x, y) {
        const worldPos = this.mapView.getNormalizedScreenCoordinates(x, y);
        const rayCaster = this.m_rayCaster;
        const pickResults = [];
        if (this.mapView.textElementsRenderer !== undefined) {
            const { clientWidth, clientHeight } = this.mapView.canvas;
            const screenX = worldPos.x * clientWidth * 0.5 * this.mapView.pixelRatio;
            const screenY = worldPos.y * clientHeight * 0.5 * this.mapView.pixelRatio;
            const scenePosition = new THREE.Vector2(screenX, screenY);
            this.mapView.textElementsRenderer.pickTextElements(scenePosition, pickResults);
        }
        rayCaster.setFromCamera(worldPos, this.camera);
        // calculate objects intersecting the picking ray
        const intersects = rayCaster.intersectObjects(this.mapView.worldRootObject.children, true);
        for (const intersect of intersects) {
            const pickResult = {
                type: PickObjectType.Unspecified,
                point: intersect.point,
                distance: intersect.distance,
                intersection: intersect
            };
            if (intersect.object.userData !== undefined) {
                const featureData = intersect.object.userData !== undefined
                    ? intersect.object.userData.feature
                    : undefined;
                if (featureData === undefined) {
                    pickResults.push(pickResult);
                    continue;
                }
                this.addObjInfo(featureData, intersect, pickResult);
                if (featureData.ids !== undefined) {
                    const featureId = featureData.ids.length === 1 ? featureData.ids[0] : undefined;
                    pickResult.featureId = featureId;
                }
                let pickObjectType;
                switch (featureData.geometryType) {
                    case harp_datasource_protocol_1.GeometryType.Point:
                    case harp_datasource_protocol_1.GeometryType.Text:
                        pickObjectType = PickObjectType.Point;
                        break;
                    case harp_datasource_protocol_1.GeometryType.Line:
                    case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
                    case harp_datasource_protocol_1.GeometryType.SolidLine:
                    case harp_datasource_protocol_1.GeometryType.TextPath:
                        pickObjectType = PickObjectType.Line;
                        break;
                    case harp_datasource_protocol_1.GeometryType.Polygon:
                    case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                        pickObjectType = PickObjectType.Area;
                        break;
                    case harp_datasource_protocol_1.GeometryType.Object3D:
                        pickObjectType = PickObjectType.Object3D;
                        break;
                    default:
                        pickObjectType = PickObjectType.Unspecified;
                }
                pickResult.type = pickObjectType;
                pickResults.push(pickResult);
            }
        }
        if (this.enableRoadPicking) {
            const planeIntersectPosition = new THREE.Vector3();
            rayCaster.ray.intersectPlane(this.m_plane, planeIntersectPosition);
            const cameraPos = this.camera.position.clone();
            this.mapView.forEachVisibleTile(tile => {
                this.m_roadPicker.intersectRoads(tile, cameraPos, planeIntersectPosition, pickResults);
            });
        }
        pickResults.sort((a, b) => {
            return a.distance - b.distance;
        });
        return pickResults;
    }
    addObjInfo(featureData, intersect, pickResult) {
        if (pickResult.intersection.object instanceof MapViewPoints_1.MapViewPoints) {
            pickResult.userData = featureData.objInfos[intersect.index];
            return;
        }
        else if (featureData.objInfos === undefined ||
            featureData.starts === undefined ||
            intersect.faceIndex === undefined) {
            return;
        }
        if (featureData.starts.length > 1) {
            let objInfosIndex = 0;
            for (const polygonStartFace of featureData.starts) {
                if (polygonStartFace > intersect.faceIndex) {
                    break;
                }
                objInfosIndex++;
            }
            pickResult.userData = featureData.objInfos[objInfosIndex - 1];
        }
        else {
            pickResult.userData = featureData.objInfos[0];
        }
    }
}
exports.PickHandler = PickHandler;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/PickingRaycaster.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/PickingRaycaster.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Raycasting points is not supported as necessary in Three.js. This class extends a
 * [[THREE.Raycaster]] except that it holds a reference to [[MapView]] allowing to access the
 * camera and the renderer from [[MapViewPoints]], in order to project the points in screen space.
 */
class PickingRaycaster extends THREE.Raycaster {
    /**
     * Constructs a `MapViewRaycaster`. It keeps a reference to [[MapView]] in order to access the
     * active camera when calling the custom method `raycastPoints`.
     *
     * @param m_mapView the active [[MapView]].
     */
    constructor(mapView) {
        super();
        this.mapView = mapView;
    }
}
exports.PickingRaycaster = PickingRaycaster;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/RoadPicker.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/RoadPicker.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const PickHandler_1 = __webpack_require__(/*! ./PickHandler */ "./node_modules/@here/harp-mapview/lib/PickHandler.js");
const logger = harp_utils_1.LoggerManager.instance.create("RoadPicker");
const MAX_DISTANCE_ERROR = 0.01;
/**
 * The `RoadPicker` class manages picking of roads, which may not be pickable in THREE.js, since
 * their geometry is generated in the vertex shader.
 */
class RoadPicker {
    constructor(m_mapView) {
        this.m_mapView = m_mapView;
    }
    /**
     * Registers a tile with the `RoadPicker`. This function extracts line data from the [[Tile]],
     * but only if the tile has the necessary [[ExtendedTileInfo]] that allows for road features to
     * be reconstructed.
     *
     * @param tile The tile to register.
     */
    registerTile(tile) {
        harp_utils_1.assert(tile.decodedTile !== undefined);
        if (tile.decodedTile === undefined || tile.decodedTile.tileInfo === undefined) {
            return undefined;
        }
        const extendedTileInfo = tile.decodedTile.tileInfo;
        const lineFeatures = extendedTileInfo.lineGroup;
        if (lineFeatures === undefined || lineFeatures.numFeatures === 0) {
            // tileInfo not of expected type [[ExtendedTileInfo]]
            return undefined;
        }
        const widths = [];
        widths.length = lineFeatures.numFeatures;
        const level = tile.tileKey.level;
        for (let i = 0; i < lineFeatures.numFeatures; i++) {
            const technique = extendedTileInfo.techniqueCatalog[lineFeatures.techniqueIndex[i]];
            const width = this.getLineWidthInWorldUnit(technique, level);
            widths[i] = width !== undefined ? Math.max(1, width) : 1;
        }
        const objInfos = extendedTileInfo.lineGroup.userData;
        const roadIntersectionData = {
            ids: lineFeatures.featureIds,
            techniqueIndex: lineFeatures.techniqueIndex,
            starts: lineFeatures.positionIndex,
            widths,
            positions: lineFeatures.positions,
            techniques: extendedTileInfo.techniqueCatalog,
            objInfos
        };
        return roadIntersectionData;
    }
    /**
     * Tests the `pickPos` point for intersection with all roads on a tile.
     *
     * @param tile The tile to pick.
     * @param eyePos The WorldPosition of eye or camera to compute distances.
     * @param pickPos The WorldPosition of the picked point, on the plane.
     * @param results The existing array of [[PickResult]]; new results should be appended.
     */
    intersectRoads(tile, eyePos, pickPos, results) {
        if (tile.boundingBox.distanceToPoint(pickPos) > MAX_DISTANCE_ERROR) {
            // outside of bounding box of tile
            return false;
        }
        const roadIntersectionData = tile.roadIntersectionData;
        if (roadIntersectionData === undefined) {
            return false;
        }
        const ids = roadIntersectionData.ids;
        const techniques = roadIntersectionData.techniques;
        const techniqueIndices = roadIntersectionData.techniqueIndex;
        const numFeatures = ids.length;
        const positions = roadIntersectionData.positions;
        const widths = roadIntersectionData.widths;
        const px = pickPos.x - tile.center.x;
        const py = pickPos.y - tile.center.y;
        const pickDistance = pickPos.distanceTo(eyePos);
        if (widths.length !== ids.length ||
            ids.length !== techniqueIndices.length ||
            techniqueIndices.length !== roadIntersectionData.starts.length) {
            logger.error("The amount of widths, ids, techniqueIndices and starts has to be the same");
            return false;
        }
        for (let i = 0; i < numFeatures; i++) {
            const technique = techniques[techniqueIndices[i]];
            // if the technique is marked as background or as transient, we ignore it for picking
            if ( /*technique.isBackground === true ||*/technique.transient === true) {
                continue;
            }
            const featureStart = roadIntersectionData.starts[i];
            const featureEnd = i < numFeatures - 1
                ? roadIntersectionData.starts[i + 1]
                : roadIntersectionData.positions.length;
            let startX = positions[featureStart];
            let startY = positions[featureStart + 1];
            const lineWidthSqr = widths[i] * widths[i];
            let closestDistSqr = Number.MAX_VALUE;
            for (let j = featureStart + 2; j < featureEnd; j += 2) {
                const endX = positions[j];
                const endY = positions[j + 1];
                const distSqr = harp_utils_1.Math2D.distToSegmentSquared(px, py, startX, startY, endX, endY);
                if (distSqr < lineWidthSqr) {
                    if (distSqr < closestDistSqr) {
                        closestDistSqr = distSqr;
                    }
                }
                startX = endX;
                startY = endY;
            }
            if (closestDistSqr < Number.MAX_VALUE) {
                const roadPickResult = {
                    type: PickHandler_1.PickObjectType.Line,
                    point: pickPos,
                    distance: pickDistance,
                    distFromCenter: Math.sqrt(closestDistSqr),
                    featureId: ids[i],
                    positions: positions.slice(featureStart, featureEnd),
                    technique
                };
                this.addUserData(roadPickResult, i, roadIntersectionData.objInfos);
                results.push(roadPickResult);
            }
        }
        return false;
    }
    addUserData(roadPickResult, index, objInfos) {
        if (objInfos !== undefined && objInfos.length > 0) {
            roadPickResult.userData = Object.assign({}, objInfos[index]);
        }
    }
    getLineWidthInWorldUnit(technique, level) {
        const solidLineTech = technique;
        const metricUnit = harp_datasource_protocol_1.getPropertyValue(solidLineTech.metricUnit, level);
        if (metricUnit === "Pixel") {
            const pixelToWorld = this.m_mapView.renderer.getPixelRatio() * this.m_mapView.pixelToWorld * 0.5;
            const lineWidth = harp_datasource_protocol_1.getPropertyValue(solidLineTech.lineWidth, level);
            return ((lineWidth !== undefined
                ? lineWidth
                : harp_materials_1.SolidLineMaterial.DEFAULT_WIDTH) * pixelToWorld);
        }
        else {
            const lineTechnique = technique;
            return harp_datasource_protocol_1.getPropertyValue(lineTechnique.lineWidth, level);
        }
    }
}
exports.RoadPicker = RoadPicker;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ScreenCollisions.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ScreenCollisions.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const DebugContext_1 = __webpack_require__(/*! ./DebugContext */ "./node_modules/@here/harp-mapview/lib/DebugContext.js");
// tslint:disable-next-line:no-var-requires
const RTree = __webpack_require__(/*! rtree */ "./node_modules/rtree/lib/index.js");
const logger = harp_utils_1.LoggerManager.instance.create("ScreenCollissions");
/**
 * @hidden
 */
class ScreenCollisions {
    /**
     * Constructs a new ScreenCollisions object.
     */
    constructor() {
        /** The screen bounding box. */
        this.screenBounds = new harp_utils_1.Math2D.Box();
        /** Tree of allocated bounds. */
        this.rtree = new RTree();
        /**
         * An array of temporary variables used when converting boxes to reduce allocations.
         */
        this.m_returnArray = [];
        //
    }
    /**
     * Converts a [[THREE.Box2]] to an internal [[Math2D.Box]].
     *
     * @param threeBox The [[THREE.Box2]] to convert.
     * @param box2 The conversion target.
     */
    static toBox2D(threeBox, box2) {
        box2.x = threeBox.min.x;
        box2.y = threeBox.min.y;
        box2.w = threeBox.max.x - threeBox.min.x;
        box2.h = threeBox.max.y - threeBox.min.y;
    }
    /**
     * Resets the list of allocated screen bounds.
     */
    reset() {
        this.rtree = new RTree();
    }
    /**
     * Updates the screen bounds that are used to check if bounding boxes are visible.
     *
     * @param width The width of the container.
     * @param height The height of the container.
     */
    update(width, height) {
        this.screenBounds.set(width / -2, height / -2, width, height);
        this.reset();
    }
    /**
     * Marks the region of the screen intersecting with the given bounding box as allocated.
     *
     * @param bounds The bounding box in world coordinates.
     */
    allocate(bounds) {
        this.rtree.insert(bounds, null);
    }
    /**
     * Checks if the given bounding box is already allocated.
     *
     * @param bounds The bounding box in world coordinates.
     */
    isAllocated(bounds) {
        // Re-use array to reduce allocations.
        this.m_returnArray.length = 0;
        this.m_returnArray = this.rtree.search(bounds, undefined, this.m_returnArray);
        return this.m_returnArray.length !== 0;
    }
    /**
     * Checks if the given screen bounds intersects with the frustum of the active camera.
     *
     * @param bounds The bounding box in world coordinates.
     */
    isVisible(bounds) {
        return this.screenBounds.intersects(bounds);
    }
}
exports.ScreenCollisions = ScreenCollisions;
/**
 * @hidden
 *
 * Shows requests for screen space during labelling in an HTML canvas, which should be sized like
 * the actual map canvas. It can be placed on top of the map canvas to show exactly which requests
 * for screen space were done.
 *
 * Also logs statistics.
 */
class ScreenCollisionsDebug extends ScreenCollisions {
    /**
     * Constructs a new ScreenCollisions object which renders its state to a 2D canvas.
     */
    constructor(debugCanvas) {
        super();
        /** 2D rendering context. */
        this.m_renderContext = null;
        this.m_renderingEnabled = false;
        this.m_numAllocations = 0;
        this.m_numSuccessfulTests = 0;
        this.m_numFailedTests = 0;
        this.m_numSuccessfulVisibilityTests = 0;
        this.m_numFailedVisibilityTests = 0;
        if (debugCanvas !== undefined && debugCanvas !== null) {
            this.m_renderContext = debugCanvas.getContext("2d");
        }
    }
    /**
     * Resets the list of allocated bounds and clears the debug canvas.
     */
    reset() {
        super.reset();
        this.m_numAllocations = 0;
        this.m_numSuccessfulTests = 0;
        this.m_numFailedTests = 0;
        this.m_numSuccessfulVisibilityTests = 0;
        this.m_numFailedVisibilityTests = 0;
    }
    /**
     * Updates the screen bounds used to check if bounding boxes are visible.
     *
     * @param width The width of the container.
     * @param height The height of the container.
     */
    update(width, height) {
        if (this.m_renderingEnabled) {
            logger.log(
            // tslint:disable-next-line: max-line-length
            `Allocations: ${this.m_numAllocations} Successful Tests: ${this.m_numSuccessfulTests} Failed Tests: ${this.m_numFailedTests}  Successful Visibility Tests: ${this.m_numSuccessfulVisibilityTests}  Failed Visibility Tests: ${this.m_numFailedVisibilityTests} `);
        }
        super.update(width, height);
        if (this.m_renderContext !== null) {
            this.m_renderContext.canvas.width = width;
            this.m_renderContext.canvas.height = height;
        }
        // activate in the browser with:
        // window.__debugContext.setValue("DEBUG_SCREEN_COLLISIONS", true)
        this.m_renderingEnabled = DebugContext_1.debugContext.getValue("DEBUG_SCREEN_COLLISIONS");
    }
    /**
     * Marks the region of the screen intersecting with the given bounding box as allocated.
     *
     * @param bounds the bounding box in world coordinates.
     */
    allocate(bounds) {
        super.allocate(bounds);
        this.m_numAllocations++;
        if (this.m_renderingEnabled && this.m_renderContext !== null) {
            this.m_renderContext.strokeStyle = "#6666ff";
            this.m_renderContext.strokeRect(bounds.x - this.screenBounds.x, this.screenBounds.y + this.screenBounds.h - bounds.y - 1, bounds.w, -bounds.h);
        }
    }
    /**
     * Checks if the given bounding box is already allocated.
     *
     * @param bounds The bounding box in world coordinates.
     */
    isAllocated(bounds) {
        const isFailed = super.isAllocated(bounds);
        if (this.m_renderingEnabled && this.m_renderContext !== null) {
            const offset = isFailed ? 2 : 0;
            this.m_renderContext.strokeStyle = isFailed ? "#FF0000" : "#00ff00";
            this.m_renderContext.strokeRect(bounds.x - this.screenBounds.x - offset, this.screenBounds.y + this.screenBounds.h - bounds.y - 1 + offset, bounds.w + 2 * offset, -bounds.h - 2 * offset);
        }
        if (isFailed) {
            this.m_numFailedTests++;
        }
        else {
            this.m_numSuccessfulTests++;
        }
        return isFailed;
    }
    /**
     * Checks if the given screen bounds intersects with the frustum of the active camera.
     *
     * @param bounds The bounding box in world coordinates.
     */
    isVisible(bounds) {
        const visible = super.isVisible(bounds);
        if (visible) {
            this.m_numSuccessfulVisibilityTests++;
        }
        else {
            this.m_numFailedVisibilityTests++;
        }
        return visible;
    }
}
exports.ScreenCollisionsDebug = ScreenCollisionsDebug;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ScreenProjector.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ScreenProjector.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * @hidden
 * Handles the projection of world coordinates to screen coordinates.
 */
class ScreenProjector {
    /**
     * Constructs a new `ScreenProjector`.
     *
     * @param m_camera Camera to project against.
     */
    constructor(m_camera) {
        this.m_camera = m_camera;
        this.m_width = 0;
        this.m_height = 0;
    }
    /**
     * Height of the screen.
     */
    get width() {
        return this.m_width;
    }
    /**
     * Width of the screen.
     */
    get height() {
        return this.m_height;
    }
    /**
     * Apply current projectionViewMatrix of the camera to project the source vector into screen
     * coordinates.
     *
     * @param {(THREE.Vector3 | THREE.Vector4)} source The source vector to project.
     * @param {THREE.Vector3} target The target vector.
     * @returns {THREE.Vector3} The projected vector (the parameter 'target').
     */
    project(source, target = new THREE.Vector2()) {
        const p = this.projectVector(source, ScreenProjector.tempV3);
        if (p.z > -1 && p.z < 1) {
            target.set((p.x * this.m_width) / 2, (p.y * this.m_height) / 2);
            return target;
        }
        return undefined;
    }
    /**
     * Apply current projectionViewMatrix of the camera to project the source vector. Stores result
     * in NDC in the target vector.
     *
     * @param {(THREE.Vector3 | THREE.Vector4)} source The source vector to project.
     * @param {THREE.Vector3} target The target vector.
     * @returns {THREE.Vector3} The projected vector (the parameter 'target').
     */
    projectVector(source, target) {
        target.set(source.x, source.y, source.z).project(this.m_camera);
        return target;
    }
    /**
     * Fast test to check if projected point is on screen.
     *
     * @returns {boolean} `true` if point is on screen, `false` otherwise.
     */
    onScreen(source) {
        const p = this.projectVector(source, ScreenProjector.tempV3);
        if (p.z > -1 && p.z < 1) {
            return p.x >= -1 && p.x <= 1 && p.y >= -1 && p.y <= 1;
        }
        return false;
    }
    /**
     * Update the `ScreenProjector` with the latest values of the screen and the camera.
     *
     * @param {THREE.Camera} camera Camera to project against.
     * @param {number} width Width of screen/canvas.
     * @param {number} height Height of screen/canvas.
     */
    update(camera, width, height) {
        this.m_camera = camera;
        this.m_width = width;
        this.m_height = height;
    }
}
ScreenProjector.tempV2 = new THREE.Vector2();
ScreenProjector.tempV3 = new THREE.Vector3();
exports.ScreenProjector = ScreenProjector;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/SkyBackground.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/SkyBackground.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const SkyCubemapTexture_1 = __webpack_require__(/*! ./SkyCubemapTexture */ "./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js");
const SkyGradientTexture_1 = __webpack_require__(/*! ./SkyGradientTexture */ "./node_modules/@here/harp-mapview/lib/SkyGradientTexture.js");
/**
 * Class that handles [[MapView]]'s sky background.
 */
class SkyBackground {
    /**
     * Constructs a new `SkyBackground`.
     *
     * @param m_sky Sky configuration parameters.
     * @param m_projectionType [[MapView]]'s projection type.
     * @param camera [[MapView]]'s camera.
     */
    constructor(m_sky, m_projectionType, camera) {
        this.m_sky = m_sky;
        this.m_projectionType = m_projectionType;
        switch (this.m_sky.type) {
            case "gradient":
                this.m_skyTexture = new SkyGradientTexture_1.SkyGradientTexture(this.m_sky, this.m_projectionType);
                this.updateCamera(camera);
                break;
            case "cubemap": {
                this.m_skyTexture = new SkyCubemapTexture_1.SkyCubemapTexture(this.m_sky);
                break;
            }
        }
    }
    /**
     * Disposes allocated resources.
     */
    dispose() {
        this.m_skyTexture.dispose();
    }
    /**
     * Sky texture.
     */
    get texture() {
        return this.m_skyTexture.texture;
    }
    /**
     * This method updates the skybox based on the camera position (needed for some types of sky).
     *
     * @param camera The camera used in the map view.
     */
    updateCamera(camera) {
        if (this.m_sky.type === "gradient") {
            this.m_skyTexture.update(camera);
        }
    }
    /**
     * Updates the sky texture with new parameters.
     *
     * @param params New sky configuration parameters.
     * @param projectionType Which projection is used, this may also change (in which case the
     * textures should be recreated).
     */
    updateTexture(params, projectionType) {
        const isSameSkyType = this.m_sky.type === params.type && this.m_projectionType === projectionType;
        switch (params.type) {
            case "gradient":
                if (isSameSkyType) {
                    this.m_skyTexture.updateTexture(params);
                }
                else {
                    this.m_skyTexture = new SkyGradientTexture_1.SkyGradientTexture(params, projectionType);
                }
                break;
            case "cubemap": {
                if (isSameSkyType) {
                    this.m_skyTexture.updateTexture(params);
                }
                else {
                    this.m_skyTexture = new SkyCubemapTexture_1.SkyCubemapTexture(params);
                }
                break;
            }
        }
        this.m_projectionType = projectionType;
        this.m_sky = params;
    }
}
exports.SkyBackground = SkyBackground;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const three_1 = __webpack_require__(/*! three */ "three");
const logger = harp_utils_1.LoggerManager.instance.create("SkyCubemapTexture");
/**
 * Number of faces that form a [[SkyCubemapTexture]].
 */
exports.SKY_CUBEMAP_FACE_COUNT = 6;
/**
 * Maps the faceId to the expected position in the threejs faces array.
 */
var SkyCubemapFaceId;
(function (SkyCubemapFaceId) {
    SkyCubemapFaceId[SkyCubemapFaceId["positiveX"] = 0] = "positiveX";
    SkyCubemapFaceId[SkyCubemapFaceId["negativeX"] = 1] = "negativeX";
    SkyCubemapFaceId[SkyCubemapFaceId["positiveY"] = 2] = "positiveY";
    SkyCubemapFaceId[SkyCubemapFaceId["negativeY"] = 3] = "negativeY";
    SkyCubemapFaceId[SkyCubemapFaceId["positiveZ"] = 4] = "positiveZ";
    SkyCubemapFaceId[SkyCubemapFaceId["negativeZ"] = 5] = "negativeZ";
})(SkyCubemapFaceId = exports.SkyCubemapFaceId || (exports.SkyCubemapFaceId = {}));
/**
 * Class that handles loading all 6 faces of a [[CubeTexture]], to be used with [[SkyBackground]].
 */
class SkyCubemapTexture {
    /**
     * Constructs a new `SkyCubemapTexture`.
     *
     * @param sky Initial [[CubemapSky]] configuration.
     */
    constructor(sky) {
        const faces = this.createCubemapFaceArray(sky);
        this.m_skybox =
            faces !== undefined ? new three_1.CubeTextureLoader().load(faces) : new three_1.CubeTexture();
    }
    /**
     * Disposes allocated resources.
     */
    dispose() {
        this.m_skybox.dispose();
    }
    /**
     * `SkyCubemapTexture`'s texture resource.
     */
    get texture() {
        return this.m_skybox;
    }
    /**
     * Updates the `SkyCubemapTexture` with new parameters.
     *
     * @param params New [[CubemapSky]] configuration.
     */
    updateTexture(sky) {
        const faces = this.createCubemapFaceArray(sky);
        if (faces === undefined) {
            return;
        }
        this.m_skybox = new three_1.CubeTextureLoader().load(faces);
    }
    createCubemapFaceArray(sky) {
        const faces = [
            undefined,
            undefined,
            undefined,
            undefined,
            undefined,
            undefined
        ];
        for (let i = 0; i < exports.SKY_CUBEMAP_FACE_COUNT; ++i) {
            const face = sky[SkyCubemapFaceId[i]];
            if (face === undefined) {
                logger.error(`Face "${SkyCubemapFaceId[i]}" was not defined.`);
                return;
            }
            faces[i] = face;
        }
        return faces;
    }
}
exports.SkyCubemapTexture = SkyCubemapTexture;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/SkyGradientTexture.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/SkyGradientTexture.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const three_1 = __webpack_require__(/*! three */ "three");
exports.DEFAULT_TEXTURE_SIZE = 512;
exports.DEFAULT_MONOMIAL_POWER = 1;
// Vectors used for skybox bitmap computation.
const cameraDir = [
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(-1, 0, 0),
    new three_1.Vector3(0, -1, 0),
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 0, 1),
    new three_1.Vector3(0, 0, -1)
];
const cameraRight = [
    new three_1.Vector3(0, 0, -1),
    new three_1.Vector3(0, 0, 1),
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(-1, 0, 0)
];
const cameraUp = [
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 0, 1),
    new three_1.Vector3(0, 0, -1),
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 1, 0)
];
/**
 * Class tha generates a texture containing a linear gradient, to be used with [[SkyBackground]].
 *
 * The gradient is mapped onto a sphere, where `topColor` maps to the top of the upper hemisphere,
 * `bottomColor` to the bottom of the upper hemisphere, and `groundColor` fills the bottom
 *  hemisphere..
 */
class SkyGradientTexture {
    /**
     * Constructs a new `SkyGradientTexture`.
     *
     * @param sky Initial [[GradientSky]] configuration.
     * @param m_projectionType [[MapView]]'s projection type.
     * @param m_height Optional height parameter.
     */
    constructor(sky, m_projectionType, m_height = exports.DEFAULT_TEXTURE_SIZE) {
        this.m_projectionType = m_projectionType;
        this.m_height = m_height;
        const topColor = new three_1.Color(sky.topColor);
        const bottomColor = new three_1.Color(sky.bottomColor);
        const groundColor = new three_1.Color(sky.groundColor);
        this.m_width = this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? 1.0 : this.m_height;
        this.m_faceCount = this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? 1.0 : 6.0;
        this.m_faces = [];
        for (let i = 0; i < this.m_faceCount; ++i) {
            const data = new Uint8Array(3 * this.m_width * this.m_height);
            this.fillTextureData(data, i, topColor, bottomColor, groundColor, sky.monomialPower);
            const texture = new three_1.DataTexture(data, this.m_width, this.m_height, three_1.RGBFormat);
            texture.needsUpdate = true;
            texture.unpackAlignment = 1;
            this.m_faces.push(texture);
        }
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_skybox = new three_1.CubeTexture(this.m_faces);
            this.m_skybox.needsUpdate = true;
        }
        else {
            this.m_farClipPlaneDividedVertically = new three_1.Line3();
            this.m_groundPlane = new three_1.Plane(new three_1.Vector3(0, 0, 1));
            this.m_bottomMidFarPoint = new three_1.Vector3();
            this.m_topMidFarPoint = new three_1.Vector3();
            this.m_horizonPosition = new three_1.Vector3();
            this.m_farClipPlaneCorners = [
                new three_1.Vector3(),
                new three_1.Vector3(),
                new three_1.Vector3(),
                new three_1.Vector3()
            ];
        }
    }
    /**
     * Disposes allocated resources.
     */
    dispose() {
        for (let i = 0; i < this.m_faceCount; ++i) {
            this.m_faces[i].dispose();
        }
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_skybox.dispose();
        }
    }
    /**
     * `SkyGradientTexture`'s texture resource (simple texture or cubemap depending on
     * [[MapView]]'s projection).
     */
    get texture() {
        return this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? this.m_faces[0] : this.m_skybox;
    }
    /**
     * This method updates the position of the texture depending on the camera frustum.
     *
     * @param camera The camera used in the map view.
     */
    update(camera) {
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Planar) {
            this.setHorizonPosition(camera);
            this.updateTexturePosition();
        }
    }
    /**
     * Updates the `SkyGradientTexture` with new parameters.
     *
     * @param params New [[GradientSky]] configuration.
     */
    updateTexture(sky) {
        for (let i = 0; i < this.m_faceCount; ++i) {
            this.fillTextureData(this.m_faces[i].image.data, i, new three_1.Color(sky.topColor), new three_1.Color(sky.bottomColor), new three_1.Color(sky.groundColor), sky.monomialPower);
            this.m_faces[i].needsUpdate = true;
        }
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_skybox.needsUpdate = true;
        }
    }
    // When creating the texture, a Uint8Array is required, because the resulting texture passed
    // to the scene as a background, is a texImage2D object, that does not accept UintClampedArray
    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
    // But, when updating the texture, a Uint8ClampedArray is passed as argument, because
    // this.m_texture.image.data returns a Uint8ClampedArray. That's why this method accepts both.
    fillTextureData(data, faceIdx, topColor, bottomColor, groundColor, monomialPower) {
        const color = new three_1.Color();
        const dir = new three_1.Vector3();
        const right = new three_1.Vector3();
        const up = new three_1.Vector3();
        const upDir = new three_1.Vector3(0, 0, 1);
        for (let i = 0; i < this.m_height; ++i) {
            for (let j = 0; j < this.m_width; ++j) {
                if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
                    const offsetX = right
                        .copy(cameraRight[faceIdx])
                        .multiplyScalar(((j + 0.5) / this.m_width) * 2.0 - 1.0);
                    const offsetY = up
                        .copy(cameraUp[faceIdx])
                        .multiplyScalar(((i + 0.5) / this.m_height) * 2.0 - 1.0);
                    dir.copy(cameraDir[faceIdx])
                        .add(offsetX)
                        .add(offsetY)
                        .normalize();
                    const t = Math.max(upDir.dot(dir), 0);
                    color
                        .copy(groundColor)
                        .lerp(bottomColor, Math.min(t * 100, 1))
                        .lerp(topColor, Math.pow(t, harp_utils_1.getOptionValue(monomialPower, exports.DEFAULT_MONOMIAL_POWER)))
                        .multiplyScalar(255);
                }
                else {
                    const t = i / this.m_height;
                    if (i === 0) {
                        color.copy(groundColor).multiplyScalar(255);
                    }
                    else {
                        color
                            .copy(bottomColor)
                            .lerp(topColor, Math.pow(t, harp_utils_1.getOptionValue(monomialPower, exports.DEFAULT_MONOMIAL_POWER)))
                            .multiplyScalar(255);
                    }
                }
                data[i * this.m_width * 3 + j * 3] = color.r;
                data[i * this.m_width * 3 + j * 3 + 1] = color.g;
                data[i * this.m_width * 3 + j * 3 + 2] = color.b;
            }
        }
    }
    setHorizonPosition(camera) {
        this.m_farClipPlaneCorners[0].set(-1, -1, 1).unproject(camera);
        this.m_farClipPlaneCorners[1].set(1, -1, 1).unproject(camera);
        this.m_farClipPlaneCorners[2].set(-1, 1, 1).unproject(camera);
        this.m_farClipPlaneCorners[3].set(1, 1, 1).unproject(camera);
        this.m_bottomMidFarPoint.copy(this.m_farClipPlaneCorners[0])
            .add(this.m_farClipPlaneCorners[1])
            .multiplyScalar(0.5);
        this.m_topMidFarPoint.copy(this.m_farClipPlaneCorners[2])
            .add(this.m_farClipPlaneCorners[3])
            .multiplyScalar(0.5);
        this.m_farClipPlaneDividedVertically.set(this.m_bottomMidFarPoint, this.m_topMidFarPoint);
        const hasIntersection = this.m_groundPlane.intersectLine(this.m_farClipPlaneDividedVertically, this.m_horizonPosition);
        // When there is no intersection between the ground plane and the
        // farClipPlaneDividedVertically, be sure that the horizon is reset. Otherwise a previous
        // intersection point stored in the m_horizonPosition will be considered the valid one.
        if (!hasIntersection) {
            this.m_horizonPosition.set(0.0, 0.0, 0.0);
        }
    }
    updateTexturePosition() {
        const coveredBySky = this.m_bottomMidFarPoint.distanceTo(this.m_horizonPosition);
        const frustumHeight = this.m_farClipPlaneDividedVertically.distance();
        const skyRatio = coveredBySky / frustumHeight;
        // If there is no intersection between the ground plane and the line that defines the far
        // clip plane divided vertically, it means that there is no sky visible and therefore the
        // ground color should be displayed. When there is no intersection, the length of the
        // this.m_horizonPosition is still equal to zero, as threejs initialize an empty vector with
        // all the three components to zero.
        // If there is an intersection, calculate the offset.
        const ratio = this.m_horizonPosition.length() === 0 ? 1 : skyRatio - 2 / this.m_height;
        // If the bottom part of the far clipping plane is under the ground plane, scroll the
        // texture down. Otherwise, the camera is looking at the sky, therefore, scroll the texture
        // up.
        this.m_faces[0].offset.set(0, this.m_bottomMidFarPoint.z <= 0 ? -ratio : skyRatio);
    }
}
exports.SkyGradientTexture = SkyGradientTexture;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/Statistics.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/Statistics.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const logger = harp_utils_1.LoggerManager.instance.create("Statistics");
/**
 * A simple ring buffer to store the last `n` values of the timer. The buffer works on
 * a First-In-First-Out (FIFO) basis.
 */
class RingBuffer {
    /**
     * Sets up the ring buffer.
     *
     * @param capacity The buffer's capacity.
     */
    constructor(capacity) {
        this.capacity = capacity;
        this.buffer = new Array(capacity);
        this.capacity = capacity;
        this.head = this.tail = this.size = 0;
    }
    /**
     * Clears the contents, removes all elements.
     */
    clear() {
        this.head = this.tail = this.size = 0;
    }
    /**
     * Adds a single element to the ring buffer.
     *
     * @param data Data element.
     */
    enqOne(data) {
        let next = this.head + 1;
        if (next >= this.capacity) {
            next = 0;
        }
        if (this.size < this.capacity) {
            this.size++;
        }
        this.buffer[this.head] = data;
        this.head = next;
        if (this.size === this.capacity) {
            this.tail = this.head;
        }
    }
    /**
     * Adds one or more elements.
     *
     * @param data The elements to add.
     */
    enq(...data) {
        for (const v of data) {
            this.enqOne(v);
        }
    }
    /**
     * Obtains the oldest element (FIFO). May throw an exception if a buffer underrun occurs.
     * Before calling this method, make sure that `size > 0`.
     */
    deq() {
        if (this.size === 0) {
            throw new Error("Ringbuffer underrun");
        }
        const data = this.buffer[this.tail];
        let next = this.tail + 1;
        if (next >= this.capacity) {
            next = 0;
        }
        if (this.size > 0) {
            this.size--;
        }
        this.tail = next;
        return data;
    }
    /**
     * Obtains the oldest element (FIFO) without removing it. Throws an exception if a buffer is
     * empty. Before calling this method, make sure that `size > 0`.
     */
    get top() {
        if (this.size === 0) {
            throw new Error("Ringbuffer underrun");
        }
        return this.buffer[this.tail];
    }
    /**
     * Obtains the latest element (LIFO) without removing it. Throws an exception if a buffer is
     * empty. Before calling this method, make sure that `size > 0`.
     */
    get bottom() {
        if (this.size === 0) {
            throw new Error("Ringbuffer underrun");
        }
        let previous = this.head - 1;
        if (previous < 0) {
            previous = this.capacity - 1;
        }
        return this.buffer[previous];
    }
    /**
     * Creates an iterator for the buffer.
     */
    iterator() {
        return new RingBuffer.Iterator(this);
    }
    /**
     * Returns a copy of the buffer, where the elements are properly sorted from oldest to newest.
     */
    asArray() {
        const array = new Array();
        for (let i = 0; i < this.size; i++) {
            array.push(this.buffer[(this.tail + i) % this.capacity]);
        }
        return array;
    }
}
exports.RingBuffer = RingBuffer;
(function (RingBuffer) {
    /**
     * A local class for RingBuffer<T>
     */
    class Iterator {
        /**
         * Creates an iterator for the ring buffer.
         *
         * @param m_buffer `Ringbuffer` to iterate over.
         * @param m_index Start index.
         */
        constructor(m_buffer, m_index = 0) {
            this.m_buffer = m_buffer;
            this.m_index = m_index;
        }
        /**
         * Gets the iterator's current value. This function does not fail even if an overrun occurs.
         * To detect an overrun, watch the result for [[next]].
         */
        get value() {
            return this.m_buffer.buffer[(this.m_buffer.tail + this.m_index) % this.m_buffer.capacity];
        }
        /**
         * Advances the iterator to the next element.
         *
         * @returns `true` if the iterator is still valid; `false` if an overrun occurs.
         */
        next() {
            this.m_index++;
            return this.m_index < this.m_buffer.size;
        }
    }
    RingBuffer.Iterator = Iterator;
})(RingBuffer = exports.RingBuffer || (exports.RingBuffer = {}));
/**
 * A simple timer that stores only the latest measurement.
 */
class SimpleTimer {
    constructor(statistics, name) {
        this.statistics = statistics;
        this.name = name;
        /** `true` if timer has been started. */
        this.running = false;
    }
    /**
     * Gets the latest measurement. This function may return `undefined` if no measurement
     * was done.
     */
    get value() {
        return this.m_currentValue;
    }
    /**
     * Sets the measurement value for the amount of time that has elapsed from start() to stop().
     * Use this function to override the timer's duration.
     *
     * @param val The timer's duration.
     */
    setValue(val) {
        this.m_currentValue = val;
    }
    /**
     * Resets the value to be able to start again.
     */
    reset() {
        this.m_currentValue = undefined;
    }
    /**
     * Starts the timer. Returns the current time, based on `Performance.now()`.
     */
    start() {
        if (!this.statistics.enabled) {
            return -1;
        }
        if (this.running) {
            throw new Error("Timer '" + this.name + "' is already running");
        }
        this.running = true;
        return (this.m_currentValue = harp_utils_1.PerformanceTimer.now());
    }
    /**
     * Stops the timer. Requires that the timer has started.
     */
    stop() {
        if (!this.statistics.enabled) {
            return -1;
        }
        if (!this.running) {
            throw new Error("Timer '" + this.name + "' has not been started");
        }
        else {
            // this.currentValue is a number now!
            const t = harp_utils_1.PerformanceTimer.now() - (this.m_currentValue || 0);
            this.m_currentValue = t;
            this.setValue(t);
            this.running = false;
            return t;
        }
    }
    /**
     * Samples the timer. Requires that the timer has started.
     *
     * @returns the current timer value; `-1` if statistics are disabled.
     */
    now() {
        if (!this.statistics.enabled) {
            return -1;
        }
        if (!this.running) {
            throw new Error("Timer '" + this.name + "' has not been started");
        }
        else {
            const t = harp_utils_1.PerformanceTimer.now() - (this.m_currentValue || 0);
            return t;
        }
    }
}
exports.SimpleTimer = SimpleTimer;
/**
 * A timer that stores the last `n` samples in a ring buffer.
 */
class SampledTimer extends SimpleTimer {
    /**
     * Creates a `SampledTimer` instance. Must still be added to statistics if it should be logged!
     *
     * @param statistics Statistics to use for management.
     * @param name Name of the timer. Use colons to build a hierarchy.
     */
    constructor(statistics, name) {
        super(statistics, name);
        this.statistics = statistics;
        this.name = name;
        /**
         * The number of times the timer has reset.
         */
        this.numResets = 0;
        /**
         * Maximum samples until the statistics are reset and updated, which may destroy a median
         * computation.
         */
        this.maxNumSamples = 1000;
        /**
         * The array of sampled values, its length cannot exceed `maxNumSamples`.
         */
        this.samples = new RingBuffer(this.maxNumSamples);
    }
    /**
     * Resets the timer and clears all of its historical values.
     */
    reset() {
        super.reset();
        this.getStats();
        this.samples.clear();
        this.numResets++;
    }
    /**
     * Add a single measurement to the sample.
     *
     * @param val A measurement to add.
     */
    setValue(val) {
        super.setValue(val);
        if (val !== undefined) {
            this.samples.enqOne(val);
        }
    }
    /**
     * Updates the `min`, `max`, `avg`, and `median` values. Currently, this function is expensive,
     * as it requires a copy of the sampled values.
     */
    getStats() {
        return computeArrayStats(this.samples.asArray());
    }
}
exports.SampledTimer = SampledTimer;
/**
 * Only exported for testing
 * @ignore
 *
 * Compute the [[ArrayStats]] for the passed in array of numbers.
 *
 * @param {number[]} samples Array containing sampled values. Will be modified (!) by sorting the
 *      entries.
 * @returns {(Stats | undefined)}
 */
function computeArrayStats(samples) {
    if (samples.length === 0) {
        return undefined;
    }
    samples.sort((a, b) => {
        return a - b;
    });
    const min = samples[0];
    const max = samples[samples.length - 1];
    let median;
    let median90;
    let median95;
    let median97;
    let median99;
    let median999;
    if (samples.length === 1) {
        median90 = median95 = median97 = median99 = median999 = median = samples[0];
    }
    else if (samples.length === 2) {
        median = samples[0] * 0.5 + samples[1] * 0.5;
        median90 = median95 = median97 = median99 = median999 = samples[1];
    }
    else {
        const mid = Math.floor(samples.length / 2);
        median =
            samples.length % 2 === 0 ? samples[mid - 1] * 0.5 + samples[mid] * 0.5 : samples[mid];
        const mid90 = Math.round(samples.length * 0.9) - 1;
        median90 = samples[mid90];
        const mid95 = Math.round(samples.length * 0.95) - 1;
        median95 = samples[mid95];
        const mid97 = Math.round(samples.length * 0.97) - 1;
        median97 = samples[mid97];
        const mid99 = Math.round(samples.length * 0.99) - 1;
        median99 = samples[mid99];
        const mid999 = Math.round(samples.length * 0.999) - 1;
        median999 = samples[mid999];
    }
    let sum = 0;
    for (let i = 0, l = samples.length; i < l; i++) {
        sum += samples[i];
    }
    const avg = sum / samples.length;
    return {
        min,
        max,
        avg,
        median,
        median90,
        median95,
        median97,
        median99,
        median999,
        numSamples: samples.length
    };
}
exports.computeArrayStats = computeArrayStats;
/**
 * Measures a sequence of connected events, such as multiple processing stages in a function.
 * Each stage is identified with a timer name, that must be a valid timer in the statistics
 * object. Additionally, all timers within a `MultiStageTimer` must be unique.
 *
 * Internally, the `MultiStageTimer` manages a list of timers where at the end of each stage,
 * one timer stops and the next timer starts.
 */
class MultiStageTimer {
    /**
     * Defines the `MultiStageTimer` with a list of timer names that represent its stages.
     *
     * @param statistics The statistics object that manages the timers.
     * @param name Name of this `MultiStageTimer`.
     * @param stages List of timer names.
     */
    constructor(statistics, name, stages) {
        this.statistics = statistics;
        this.name = name;
        this.stages = stages;
        if (stages.length < 1) {
            throw new Error("MultiStageTimer needs stages");
        }
        stages.forEach(stage => {
            if (!statistics.hasTimer(stage)) {
                throw new Error("Unknown timer: " + stage);
            }
        });
    }
    /**
     * Gets the timer value for the last stage. If the `MultiStageTimer` did not finish its
     * last stage, the value is `undefined`.
     */
    get value() {
        return this.statistics.getTimer(this.stages[this.stages.length - 1]).value;
    }
    /**
     * Resets the timers across all stages.
     */
    reset() {
        if (!this.statistics.enabled) {
            return;
        }
        this.stages.forEach(stage => {
            this.statistics.getTimer(stage).reset();
        });
    }
    /**
     * Starts the `MultiStageTimer` at its first stage.
     */
    start() {
        this.stage = this.stages[0];
        return this.statistics.getTimer(this.stages[0]).value || -1;
    }
    /**
     * Stops the `MultiStageTimer`. Returns the measurement of the last stage, which may be
     * `undefined` if not all stages started.
     */
    stop() {
        this.stage = undefined;
        return this.value !== undefined ? this.value : -1;
    }
    /**
     * Gets the current stage.
     */
    get stage() {
        return this.currentStage;
    }
    /**
     * Sets the current stage. If a new stage is provided, the current timer (if available) is
     * stopped, and the next timer is started. If the timer in the next stage is `undefined`,
     * this is equivalent to calling `stop` on the `MultiStageTimer`.
     *
     * @param stage The next stage to start.
     */
    set stage(stage) {
        if (this.currentStage === stage) {
            return;
        }
        if (this.statistics.enabled && this.currentStage !== undefined) {
            this.statistics.getTimer(this.currentStage).stop();
        }
        this.currentStage = stage;
        if (this.statistics.enabled && this.currentStage !== undefined) {
            this.statistics.getTimer(this.currentStage).start();
        }
    }
}
exports.MultiStageTimer = MultiStageTimer;
/**
 * Manages a set of timers. The main objective of `Statistics` is to log these timers. You can
 * disable statistics to minimize their impact on performance.
 */
class Statistics {
    /**
     * Sets up a group of timers.
     *
     * @param name The statistics name, for logging purposes.
     * @param enabled If `false`, the timers do not measure the performance.
     */
    constructor(name, enabled = false) {
        this.name = name;
        this.enabled = enabled;
        this.timers = new Map();
        this.nullTimer = new SimpleTimer(this, "<null>");
    }
    /**
     * Adds a timer, based on the name specified.
     *
     * @param name The timer's name; must be unique.
     */
    createTimer(name, keepSamples = true) {
        const timer = keepSamples ? new SampledTimer(this, name) : new SimpleTimer(this, name);
        return this.addTimer(timer);
    }
    /**
     * Adds the timer specified.
     *
     * @param timer The timer's name, which must be unique within this statistics object.
     */
    addTimer(timer) {
        if (this.timers.get(timer.name) !== undefined) {
            throw new Error("Duplicate timer name: '" + timer.name + "'");
        }
        this.timers.set(timer.name, timer);
        return timer;
    }
    /**
     * Gets a timer by name.
     *
     * @param name The timer's name.
     */
    getTimer(name) {
        if (!this.enabled) {
            return this.nullTimer;
        }
        const t = this.timers.get(name);
        return t === undefined ? this.nullTimer : t;
    }
    /**
     * Checks if a timer with the specified name already exists.
     *
     * @param name The timer's name.
     * @returns `true` if a timer with `name` already exists; `false` otherwise.
     */
    hasTimer(name) {
        const t = this.timers.get(name);
        return t !== undefined;
    }
    /**
     * Resets all timers.
     */
    reset() {
        this.timers.forEach((timer) => {
            timer.reset();
        });
    }
    /**
     * Prints all values to the console.
     *
     * @param header Optional header line.
     * @param footer Optional footer line.
     */
    log(header, footer) {
        if (header !== undefined || this.name !== undefined) {
            logger.log(header !== undefined ? header : this.name);
        }
        let maxNameLength = 0;
        this.timers.forEach((timer) => {
            maxNameLength = Math.max(maxNameLength, timer.name.length);
        });
        // simple printing function for number limits the number of decimal points.
        const print = (v) => {
            return v !== undefined ? v.toFixed(5) : "?";
        };
        this.timers.forEach((timer) => {
            let s = timer.name + ": " + " ".repeat(maxNameLength - timer.name.length);
            s += print(timer.value);
            // sampled timers also update their stats and log them
            if (timer instanceof SampledTimer) {
                const simpleStats = timer.getStats();
                if (simpleStats !== undefined) {
                    s +=
                        `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +
                            `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +
                            `med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, ` +
                            `N=${print(simpleStats.numSamples)} ]`;
                }
            }
            logger.log(s);
        });
        if (footer !== undefined) {
            logger.log(footer);
        }
    }
}
exports.Statistics = Statistics;
/**
 * Class containing all counters, timers and events of the current frame.
 */
class FrameStats {
    constructor() {
        this.entries = new Map();
        this.messages = undefined;
    }
    /**
     * Retrieve the value of the performance number.
     *
     * @param name Name of the performance number.
     * @returns The value of the performance number or `undefined` if it has not been declared by
     *      `setValue` before.
     */
    getValue(name) {
        return this.entries.get(name);
    }
    /**
     * Set the value of the performance number.
     *
     * @param name Name of the performance number.
     * @param name New value of the performance number.
     */
    setValue(name, value) {
        this.entries.set(name, value);
    }
    /**
     * Add a value to the current value of the performance number. If the performance is not known,
     * it will be initialized with `value`.
     *
     * @param name Name of the performance number.
     * @param name Value to be added to the performance number.
     */
    addValue(name, value) {
        const oldValue = this.entries.get(name);
        this.entries.set(name, value + (oldValue === undefined ? 0 : oldValue));
    }
    /**
     * Add a text message to the frame, like "Font XYZ has been loaded"
     *
     * @param message The message to add.
     */
    addMessage(message) {
        if (this.messages === undefined) {
            this.messages = [];
        }
        this.messages.push(message);
    }
    /**
     * Reset all known performance values to `0` and the messages to `undefined`.
     */
    reset() {
        this.entries.forEach((value, name) => {
            this.entries.set(name, 0);
        });
        this.messages = undefined;
    }
}
exports.FrameStats = FrameStats;
/**
 * @ignore
 * Only exported for testing.
 *
 * Instead of passing around an array of objects, we store the frame statistics as an object of
 * arrays. This allows convenient computations from [[RingBuffer]],
 */
class FrameStatsArray {
    constructor(capacity = 0) {
        this.capacity = capacity;
        this.frameEntries = new Map();
        this.messages = new RingBuffer(capacity);
    }
    get length() {
        return this.messages.size;
    }
    reset() {
        this.frameEntries.forEach((buffer, name) => {
            buffer.clear();
        });
        this.messages.clear();
    }
    addFrame(frameStats) {
        const currentSize = this.length;
        const frameEntries = this.frameEntries;
        frameStats.entries.forEach((value, name) => {
            let buffer = frameEntries.get(name);
            if (buffer === undefined) {
                // If there is a buffer that has not been known before, add it to the known buffers,
                // fill it up with with 0 to the size of all the other buffers to make them of equal
                // size to make PerfViz happy.
                buffer = new RingBuffer(this.capacity);
                for (let i = 0; i < currentSize; i++) {
                    buffer.enqOne(0);
                }
                this.frameEntries.set(name, buffer);
            }
            buffer.enqOne(value);
        });
        this.messages.enq(frameStats.messages);
    }
    /**
     * Prints all values to the console.
     */
    log() {
        let maxNameLength = 0;
        this.frameEntries.forEach((buffer, name) => {
            maxNameLength = Math.max(maxNameLength, name.length);
        });
        // simple printing function for number limits the number of decimal points.
        const print = (v) => {
            return v !== undefined ? v.toFixed(5) : "?";
        };
        this.frameEntries.forEach((buffer, name) => {
            let s = name + ": " + " ".repeat(maxNameLength - name.length);
            const simpleStats = computeArrayStats(buffer.asArray());
            if (simpleStats !== undefined) {
                s +=
                    `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +
                        `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +
                        `med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, ` +
                        `N=${print(simpleStats.numSamples)} ]`;
            }
            logger.log(s);
        });
    }
}
exports.FrameStatsArray = FrameStatsArray;
/**
 * Performance measurement central. Maintains the current [[FrameStats]], which holds all individual
 * performance numbers.
 *
 * Implemented as an instance for easy access.
 */
class PerformanceStatistics {
    /**
     * Creates an instance of PerformanceStatistics. Overrides the current `instance`.
     *
     * @param {boolean} [enabled=true] If `false` the performance values will not be stored.
     * @param {number} [maxNumFrames=1000] The maximum number of frames that are to be stored.
     * @memberof PerformanceStatistics
     */
    constructor(enabled = true, maxNumFrames = 1000) {
        this.enabled = enabled;
        this.maxNumFrames = maxNumFrames;
        /**
         * Current frame statistics. Contains all values for the current frame. Will be cleared when
         * [[PerformanceStatistics#storeFrameInfo]] is called.
         *
         * @type {FrameStats}
         * @memberof PerformanceStatistics
         */
        this.currentFrame = new FrameStats();
        /**
         * Additional results stored for the current application run, not per frame. Only the last value
         * is stored.
         *
         * @type {(Map<string, number>)}
         */
        this.appResults = new Map();
        /**
         * Additional configuration values stored for the current application run, not per frame. Only
         * the last value is stored.
         *
         * @type {(Map<string, string>)}
         * @memberof PerformanceStatistics
         */
        this.configs = new Map();
        PerformanceStatistics.m_instance = this;
        this.m_frameEvents = new FrameStatsArray(maxNumFrames);
    }
    /**
     * Returns `true` when the maximum number of storable frames is reached.
     *
     * @readonly
     * @type {boolean}
     * @memberof PerformanceStatistics
     */
    get isFull() {
        return this.m_frameEvents.length >= this.maxNumFrames;
    }
    /**
     * Global instance to the instance. The current instance can be overridden by creating a new
     * `PerformanceStatistics`.
     */
    static get instance() {
        if (PerformanceStatistics.m_instance === undefined) {
            PerformanceStatistics.m_instance = new PerformanceStatistics(false, 0);
        }
        return PerformanceStatistics.m_instance;
    }
    /**
     * @ignore
     * Only exported for testing.
     *
     * Return the array of frame events.
     */
    get frameEvents() {
        return this.m_frameEvents;
    }
    /**
     * Clears all settings, all stored frame events as well as the current frame values.
     *
     * @memberof PerformanceStatistics
     */
    clear() {
        this.clearFrames();
        this.configs.clear();
        this.appResults.clear();
    }
    /**
     * Clears only all stored frame events as well as the current frame values.
     *
     * @memberof PerformanceStatistics
     */
    clearFrames() {
        this.m_frameEvents.reset();
        this.currentFrame.reset();
    }
    /**
     * Stores the current frame events into the array of events. Uses [[THREE.WebGLInfo]] to add the
     * render state information to the current frame.
     *
     * @param {THREE.WebGLInfo} webGlInfo
     * @returns {boolean} Returns `false` if the maximum number of storable frames has been reached.
     * @memberof PerformanceStatistics
     */
    storeFrameInfo(webGlInfo) {
        if (this.m_frameEvents.length >= this.maxNumFrames) {
            return false;
        }
        if (webGlInfo !== undefined) {
            if (webGlInfo.render !== undefined) {
                this.currentFrame.setValue("gl.numCalls", webGlInfo.render.calls === null ? 0 : webGlInfo.render.calls);
                this.currentFrame.setValue("gl.numPoints", webGlInfo.render.points === null ? 0 : webGlInfo.render.points);
                this.currentFrame.setValue("gl.numLines", webGlInfo.render.lines === null ? 0 : webGlInfo.render.lines);
                this.currentFrame.setValue("gl.numTriangles", webGlInfo.render.triangles === null ? 0 : webGlInfo.render.triangles);
            }
            if (webGlInfo.memory !== undefined) {
                this.currentFrame.setValue("gl.numGeometries", webGlInfo.memory.geometries === null ? 0 : webGlInfo.memory.geometries);
                this.currentFrame.setValue("gl.numTextures", webGlInfo.memory.textures === null ? 0 : webGlInfo.memory.textures);
            }
            if (webGlInfo.programs !== undefined) {
                this.currentFrame.setValue("gl.numPrograms", webGlInfo.programs === null ? 0 : webGlInfo.programs.length);
            }
        }
        if (window !== undefined && window.performance !== undefined) {
            const memory = window.performance.memory;
            if (memory !== undefined) {
                this.currentFrame.setValue("memory.totalJSHeapSize", memory.totalJSHeapSize);
                this.currentFrame.setValue("memory.usedJSHeapSize", memory.usedJSHeapSize);
                this.currentFrame.setValue("memory.jsHeapSizeLimit", memory.jsHeapSizeLimit);
            }
        }
        this.m_frameEvents.addFrame(this.currentFrame);
        this.currentFrame.reset();
        return true;
    }
    /**
     * Logs all values to the logger.
     *
     * @param header Optional header line.
     * @param footer Optional footer line.
     */
    log(header, footer) {
        logger.log(header !== undefined ? header : "PerformanceStatistics");
        const appResults = this.appResults;
        appResults.forEach((value, name) => {
            logger.log(name, value);
        });
        const configs = this.configs;
        configs.forEach((value, name) => {
            logger.log(name, value);
        });
        this.m_frameEvents.log();
        if (footer !== undefined) {
            logger.log(footer);
        }
    }
    /**
     * Convert to a plain object that can be serialized. Required to copy the test results over to
     * nightwatch.
     */
    getAsPlainObject() {
        const appResults = {};
        const configs = {};
        const frames = {};
        const plainObject = {
            configs,
            appResults,
            frames
        };
        const appResultValues = this.appResults;
        appResultValues.forEach((value, name) => {
            appResults[name] = value;
        });
        const configValues = this.configs;
        configValues.forEach((value, name) => {
            configs[name] = value;
        });
        for (const [name, buffer] of this.m_frameEvents.frameEntries) {
            frames[name] = buffer.asArray();
        }
        plainObject.messages = this.m_frameEvents.messages.asArray();
        return plainObject;
    }
    /**
     * Convert the last frame values to a plain object that can be serialized. Required to copy the
     * test results over to nightwatch.
     */
    getLastFrameStatistics() {
        const appResults = {};
        const configs = {};
        const frames = {};
        const plainObject = {
            configs,
            appResults,
            frames
        };
        const appResultValues = this.appResults;
        appResultValues.forEach((value, name) => {
            appResults[name] = value;
        });
        const configValues = this.configs;
        configValues.forEach((value, name) => {
            configs[name] = value;
        });
        for (const [name, buffer] of this.m_frameEvents.frameEntries) {
            frames[name] = buffer.bottom;
        }
        plainObject.messages = this.m_frameEvents.messages.asArray();
        return plainObject;
    }
}
PerformanceStatistics.m_instance = undefined;
exports.PerformanceStatistics = PerformanceStatistics;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ThemeHelpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ThemeHelpers.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Returns `three.js` pixel format object basing on a [[PixelFormat]] specified.
 */
function toPixelFormat(format) {
    switch (format) {
        case "Alpha":
            return THREE.AlphaFormat;
        case "RGB":
            return THREE.RGBFormat;
        case "RGBA":
            return THREE.RGBAFormat;
        case "Luminance":
            return THREE.LuminanceFormat;
        case "LuminanceAlpha":
            return THREE.LuminanceAlphaFormat;
        case "RGBE":
            return THREE.RGBEFormat;
        case "Depth":
            return THREE.DepthFormat;
        case "DepthStencil":
            return THREE.DepthStencilFormat;
        case "Red":
            return THREE.RedFormat;
        default:
            throw new Error(`invalid pixel format: ${format}`);
    }
}
exports.toPixelFormat = toPixelFormat;
/**
 * Returns `three.js` texture data types based on a [[TextureDataType]] specified.
 */
function toTextureDataType(dataType) {
    switch (dataType) {
        case "UnsignedByte":
            return THREE.UnsignedByteType;
        case "Byte":
            return THREE.ByteType;
        case "Short":
            return THREE.ShortType;
        case "UnsignedShort":
            return THREE.UnsignedShortType;
        case "Int":
            return THREE.IntType;
        case "UnsignedInt":
            return THREE.UnsignedIntType;
        case "Float":
            return THREE.FloatType;
        case "HalfFloat":
            return THREE.HalfFloatType;
        default:
            throw new Error(`invalid texture data type: ${dataType}`);
    }
}
exports.toTextureDataType = toTextureDataType;
/**
 * Returns `three.js` wrapping mode object based on a [[WrappingMode]] specified.
 */
function toWrappingMode(mode) {
    switch (mode) {
        case "clamp":
            return THREE.ClampToEdgeWrapping;
        case "repeat":
            return THREE.RepeatWrapping;
        case "mirror":
            return THREE.MirroredRepeatWrapping;
        default:
            throw new Error(`invalid wrapping mode: ${mode}`);
    }
}
exports.toWrappingMode = toWrappingMode;
/**
 * Returns `three.js` texture filter object based on a [[MagFilter]] or [[MinFilter]] specified.
 */
function toTextureFilter(filter) {
    switch (filter) {
        case "nearest":
            return THREE.NearestFilter;
        case "nearestMipMapNearest":
            return THREE.NearestMipMapNearestFilter;
        case "nearestMipMapLinear":
            return THREE.NearestMipMapLinearFilter;
        case "linear":
            return THREE.LinearFilter;
        case "linearMipMapNearest":
            return THREE.LinearMipMapNearestFilter;
        case "linearMipMapLinear":
            return THREE.LinearMipMapLinearFilter;
        default:
            throw new Error(`invalid texture filter: ${filter}`);
    }
}
exports.toTextureFilter = toTextureFilter;
/**
 * Create a specific light for lightening the map.
 */
function createLight(lightDescription) {
    switch (lightDescription.type) {
        case "ambient": {
            const light = new THREE.AmbientLight(lightDescription.color, lightDescription.intensity);
            light.name = lightDescription.name;
            return light;
        }
        case "directional": {
            const light = new THREE.DirectionalLight(lightDescription.color, lightDescription.intensity);
            light.name = lightDescription.name;
            if (lightDescription.castShadow !== undefined) {
                light.castShadow = lightDescription.castShadow;
            }
            light.position.set(lightDescription.direction.x, lightDescription.direction.y, lightDescription.direction.z);
            light.position.normalize();
            return light;
        }
    }
}
exports.createLight = createLight;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ThemeLoader.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ThemeLoader.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(/*! @here/harp-fetch */ "./node_modules/@here/harp-fetch/index.web.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const SkyCubemapTexture_1 = __webpack_require__(/*! ./SkyCubemapTexture */ "./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js");
/**
 * Loads and validates a theme from URL objects.
 */
class ThemeLoader {
    /**
     * Loads a [[Theme]] from a remote resource, provided as a URL that points to a
     * JSON-encoded theme.
     *
     * Relative URLs are resolved to full URL using the document's base URL
     * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).
     *
     * @param themeUrl The URL to the theme.
     */
    static loadAsync(themeUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            themeUrl = harp_utils_1.defaultUrlResolver(themeUrl);
            const response = yield fetch(themeUrl);
            if (!response.ok) {
                throw new Error(`ThemeLoader#loadAsync: cannot load theme: ${response.statusText}`);
            }
            const theme = (yield response.json());
            if (theme === null) {
                throw new Error("ThemeLoader#loadAsync: loaded resource is not valid JSON");
            }
            // Remember the URL where the theme has been loaded from.
            theme.url = themeUrl;
            return this.resolveUrls(theme);
        });
    }
    /**
     * Resolves all [[Theme]]'s relatives URLs to full URL using the [[Theme]]'s URL
     * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).
     *
     * @param theme The [[Theme]] to resolve.
     */
    static resolveUrls(theme) {
        // Ensure that all resources referenced in theme by relative URLs are in fact relative to
        // theme.
        const childUrlResolver = harp_utils_1.composeUrlResolvers((childUrl) => harp_utils_1.resolveReferenceUrl(theme.url, childUrl), harp_utils_1.defaultUrlResolver);
        if (theme.sky && theme.sky.type === "cubemap") {
            for (let i = 0; i < SkyCubemapTexture_1.SKY_CUBEMAP_FACE_COUNT; ++i) {
                const faceUrl = theme.sky[SkyCubemapTexture_1.SkyCubemapFaceId[i]];
                if (faceUrl !== undefined) {
                    theme.sky[SkyCubemapTexture_1.SkyCubemapFaceId[i]] = childUrlResolver(faceUrl);
                }
            }
        }
        if (theme.images) {
            for (const name of Object.keys(theme.images)) {
                const image = theme.images[name];
                image.url = childUrlResolver(image.url);
                if (image.atlas !== undefined) {
                    image.atlas = childUrlResolver(image.atlas);
                }
            }
        }
        if (theme.fontCatalogs) {
            for (const font of theme.fontCatalogs) {
                font.url = childUrlResolver(font.url);
            }
        }
        if (theme.poiTables) {
            for (const poiTable of theme.poiTables) {
                poiTable.url = childUrlResolver(poiTable.url);
            }
        }
        if (theme.styles) {
            for (const styleSetName in theme.styles) {
                if (!theme.styles.hasOwnProperty(styleSetName)) {
                    continue;
                }
                const styleSet = theme.styles[styleSetName];
                for (const style of styleSet) {
                    if (!style.attr) {
                        continue;
                    }
                    ["map", "normalMap", "displacementMap", "roughnessMap"].forEach(texturePropertyName => {
                        const textureProperty = style.attr[texturePropertyName];
                        if (textureProperty && typeof textureProperty === "string") {
                            style.attr[texturePropertyName] = childUrlResolver(textureProperty);
                        }
                    });
                }
            }
        }
        return theme;
    }
}
exports.ThemeLoader = ThemeLoader;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/Tile.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/Tile.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const Statistics_1 = __webpack_require__(/*! ./Statistics */ "./node_modules/@here/harp-mapview/lib/Statistics.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-mapview/lib/Utils.js");
/**
 * Minimum estimated size of a JS object.
 */
const MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION = 16;
const MINIMUM_OBJECT_SIZE_ESTIMATION = 100;
/**
 * A default empty [[DecodedTile]], for tiles that must be rendered but do not have any objects.
 */
const defaultEmptyDecodedTile = {
    techniques: [],
    geometries: []
};
/**
 * Compute the memory footprint of `TileFeatureData`.
 */
function getFeatureDataSize(featureData) {
    let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;
    if (featureData.ids !== undefined) {
        numBytes += featureData.ids.length * 8;
    }
    if (featureData.starts !== undefined) {
        numBytes += featureData.starts.length * 8;
    }
    if (featureData.objInfos !== undefined) {
        // 16 (estimated) bytes per objInfos
        numBytes += featureData.objInfos.length * MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION;
    }
    return numBytes;
}
exports.getFeatureDataSize = getFeatureDataSize;
/**
 * Compute the memory footprint of `RoadIntersectionData`.
 */
function getRoadIntersectionDataSize(intersectionData) {
    let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;
    // 8 bytes per techniqueIndex
    // 8 bytes per start
    // 8 bytes per width
    // 8 bytes per position
    // 100 (estimated) bytes per technique
    const bytesPerEntry = 8 + 8 + 8 + 8 + MINIMUM_OBJECT_SIZE_ESTIMATION;
    const numEntries = intersectionData.techniqueIndex.length;
    numBytes += intersectionData.techniqueIndex.length * bytesPerEntry;
    if (intersectionData.ids !== undefined) {
        numBytes += numEntries * 8;
    }
    if (intersectionData.objInfos !== undefined) {
        // 16 (estimated) bytes per objInfos
        numBytes += numEntries * MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION;
    }
    return numBytes;
}
/**
 * Missing Typedoc
 */
var TileLoaderState;
(function (TileLoaderState) {
    TileLoaderState[TileLoaderState["Initialized"] = 0] = "Initialized";
    TileLoaderState[TileLoaderState["Loading"] = 1] = "Loading";
    TileLoaderState[TileLoaderState["Loaded"] = 2] = "Loaded";
    TileLoaderState[TileLoaderState["Decoding"] = 3] = "Decoding";
    TileLoaderState[TileLoaderState["Ready"] = 4] = "Ready";
    TileLoaderState[TileLoaderState["Canceled"] = 5] = "Canceled";
    TileLoaderState[TileLoaderState["Failed"] = 6] = "Failed";
})(TileLoaderState = exports.TileLoaderState || (exports.TileLoaderState = {}));
/**
 * The class that holds the tiled data for a [[DataSource]].
 */
class Tile {
    /**
     * Creates a new [[Tile]].
     *
     * @param dataSource The [[DataSource]] that created this [[Tile]].
     * @param tileKey The unique identifier for this [[Tile]]. Currently only up to level 24 is
     * supported, because of the use of the upper bits for the offset.
     * @param offset The optional offset, this is an integer which represents what multiple of 360
     * degrees to shift, only useful for flat projections, hence optional.
     */
    constructor(dataSource, tileKey, offset = 0) {
        this.dataSource = dataSource;
        this.tileKey = tileKey;
        this.offset = offset;
        /**
         * A list of the THREE.js objects stored in this `Tile`.
         */
        this.objects = [];
        /**
         * The optional list of HERE TileKeys of tiles with geometries that cross
         * the boundaries of this `Tile`.
         */
        this.dependencies = new Array();
        /**
         * The bounding box of this `Tile` in world coordinates.
         */
        this.boundingBox = new THREE.Box3();
        /**
         * The center of this `Tile` in world coordinates.
         */
        this.center = new THREE.Vector3();
        /**
         * Keeping some stats for the individual [[Tile]]s to analyze caching behavior.
         *
         * The frame the [[Tile]] was last requested. This is required to know when the given [[Tile]]
         * can be removed from the cache.
         */
        this.frameNumLastRequested = -1;
        /**
         * The frame the `Tile` was first visible.
         */
        this.frameNumVisible = -1;
        /**
         * The last frame this `Tile` has been rendered (or was in the visible set). Used to determine
         * visibility of `Tile` at the end of a frame, if the number is the current frame number, it is
         * visible.
         */
        this.frameNumLastVisible = -1;
        /**
         * After removing from cache, this is the number of frames the `Tile` was visible.
         */
        this.numFramesVisible = 0;
        this.m_disposed = false;
        this.m_forceHasGeometry = undefined;
        // Used for [[TextElement]]s which the developer defines.
        this.m_userTextElements = [];
        // Used for [[TextElement]]s that are stored in the data, and that are placed explicitly,
        // fading in and out.
        this.m_textElementGroups = new harp_utils_1.GroupedPriorityList();
        // All visible [[TextElement]]s.
        this.m_placedTextElements = new harp_utils_1.GroupedPriorityList();
        // If `true`, the text content of the [[Tile]] changed.
        this.m_textElementsChanged = false;
        this.m_visibleArea = 0;
        // List of owned textures for disposal
        this.m_ownedTextures = new WeakSet();
        this.geoBox = this.dataSource.getTilingScheme().getGeoBox(this.tileKey);
        this.projection.projectBox(this.geoBox, this.boundingBox);
        this.boundingBox.getCenter(this.center);
    }
    /**
     * The visibility status of the [[Tile]]. It is actually visible or planned to become visible.
     */
    get isVisible() {
        // Tiles are not evaluated as invisible until the second frame they aren't requested.
        // This happens in order to prevent that, during [[VisibleTileSet]] visibility evaluation,
        // visible tiles that haven't yet been evaluated for the current frame are preemptively
        // removed from [[DataSourceCache]].
        return this.frameNumLastRequested >= this.dataSource.mapView.frameNumber - 1;
    }
    set isVisible(visible) {
        this.frameNumLastRequested = visible ? this.dataSource.mapView.frameNumber : -1;
    }
    /**
     * The [[Projection]] currently used by the [[MapView]].
     */
    get projection() {
        return this.dataSource.projection;
    }
    /**
     * The [[MapView]] this `Tile` belongs to.
     */
    get mapView() {
        return this.dataSource.mapView;
    }
    /**
     * Get the currently visible [[TextElement]]s of this `Tile`. This list is continuously
     * modified, and is not designed to be used to store developer-defined [[TextElements]].
     */
    get placedTextElements() {
        return this.m_placedTextElements;
    }
    /*
     * The size of this Tile in system memory.
     */
    get memoryUsage() {
        if (this.m_resourceInfo === undefined) {
            this.computeResourceInfo();
        }
        return this.m_resourceInfo.heapSize;
    }
    /**
     * Compute [[TileResourceInfo]] of this `Tile`. May be using a cached value. The method
     * `invalidateResourceInfo` can be called beforehand to force a recalculation.
     *
     * @returns `TileResourceInfo` for this `Tile`.
     */
    getResourceInfo() {
        if (this.m_resourceInfo === undefined) {
            this.computeResourceInfo();
        }
        return this.m_resourceInfo;
    }
    /**
     * Force invalidation of the cached [[TileResourceInfo]]. Useful after the `Tile` has been
     * modified.
     */
    invalidateResourceInfo() {
        this.m_resourceInfo = undefined;
    }
    /**
     * Add ownership of a texture to this tile. The texture will be disposed if the `Tile` is
     * disposed.
     * @param texture Texture to be owned by the `Tile`
     */
    addOwnedTexture(texture) {
        this.m_ownedTextures.add(texture);
    }
    /**
     * Gets the list of developer-defined [[TextElement]] in this `Tile`. This list is always
     * rendered first.
     */
    get userTextElements() {
        return this.m_userTextElements;
    }
    /**
     * Adds a developer-defined [[TextElement]] to this `Tile`. The [[TextElement]] is always
     * visible, if it's in the map's currently visible area.
     *
     * @param textElement The Text element to add.
     */
    addUserTextElement(textElement) {
        this.m_userTextElements.push(textElement);
        this.textElementsChanged = true;
    }
    /**
     * Removes a developer-defined [[TextElement]] from this `Tile`.
     *
     * @param textElement A developer-defined TextElement to remove.
     * @returns `true` if the element has been removed successfully; `false` otherwise.
     */
    removeUserTextElement(textElement) {
        const foundIndex = this.m_userTextElements.indexOf(textElement);
        if (foundIndex >= 0) {
            this.m_userTextElements.splice(foundIndex, 1);
            this.textElementsChanged = true;
            return true;
        }
        return false;
    }
    /**
     * Adds a [[TextElement]] to this `Tile`, which is added to the visible set of
     * [[TextElement]]s based on the capacity and visibility. The [[TextElement]]'s priority
     * controls if or when it becomes visible.
     *
     * To ensure that a TextElement is visible, use a high value for its priority, such as
     * `Number.MAX_SAFE_INTEGER`. Since the number of visible TextElements is limited by the
     * screen space, not all TextElements are visible at all times.
     *
     * @param textElement The TextElement to add.
     */
    addTextElement(textElement) {
        this.textElementGroups.add(textElement);
        this.textElementsChanged = true;
    }
    /**
     * Removes a [[TextElement]] from this `Tile`. For the element to be removed successfully, the
     * priority of the [[TextElement]] has to be equal to its priority when it was added.
     *
     * @param textElement The TextElement to remove.
     * @returns `true` if the TextElement has been removed successfully; `false` otherwise.
     */
    removeTextElement(textElement) {
        if (this.textElementGroups.remove(textElement)) {
            this.textElementsChanged = true;
            return true;
        }
        return false;
    }
    /**
     * Gets the current [[GroupedPriorityList]] which contains a list of all [[TextElement]]s to be
     * selected and placed for rendering.
     */
    get textElementGroups() {
        return this.m_textElementGroups;
    }
    /**
     * Gets the current modification state for the list of [[TextElement]]s in the `Tile`. If the
     * value is `true` the TextElement is placed for rendering during the next frame.
     */
    get textElementsChanged() {
        return this.m_textElementsChanged;
    }
    set textElementsChanged(changed) {
        this.m_textElementsChanged = changed;
    }
    /**
     * Called by [[VisibleTileSet]] to mark that [[Tile]] is visible and it should prepare its road
     * geometry for picking.
     */
    prepareTileInfo() {
        // If the tile is not ready for display, or if it has become invisible while being loaded,
        // for example by moving the camera, the tile is not finished and its geometry is not
        // created. This is an optimization for fast camera movements and zooms.
        if (this.m_decodedTile === undefined || this.m_disposed || !this.isVisible) {
            return;
        }
        if (this.m_decodedTile.tileInfo !== undefined) {
            this.roadIntersectionData = this.dataSource.mapView.pickHandler.registerTile(this);
        }
    }
    /**
     * Called before [[MapView]] starts rendering this `Tile`.
     *
     * @param zoomLevel The current zoom level.
     * @returns Returns `true` if this `Tile` should be rendered.
     */
    willRender(_zoomLevel) {
        return true;
    }
    /**
     * Called after [[MapView]] has rendered this `Tile`.
     */
    didRender() {
        // to be overridden by subclasses
    }
    /**
     * Estimated visible area of tile used for sorting the priorities during loading.
     */
    get visibleArea() {
        return this.m_visibleArea;
    }
    set visibleArea(area) {
        this.m_visibleArea = area;
        if (this.tileLoader !== undefined) {
            this.tileLoader.updatePriority(area);
        }
    }
    /**
     * Gets the decoded tile; it is removed after geometry handling.
     */
    get decodedTile() {
        return this.m_decodedTile;
    }
    /**
     * Called by [[TileLoader]] when data for geometry is available.
     *
     * @param decodedTile
     */
    setDecodedTile(decodedTile) {
        this.m_decodedTile = decodedTile;
        this.invalidateResourceInfo();
        const stats = Statistics_1.PerformanceStatistics.instance;
        if (stats.enabled && decodedTile.decodeTime !== undefined) {
            stats.currentFrame.addValue("decode.decodingTime", decodedTile.decodeTime);
        }
    }
    /**
     * Remove the decodedTile when no longer needed.
     */
    removeDecodedTile() {
        this.m_decodedTile = undefined;
        this.invalidateResourceInfo();
    }
    /**
     * Called when the default implementation of `dispose()` needs
     * to free the geometry of a `Tile` object.
     *
     * @param object The object that references the geometry.
     * @returns `true` if the geometry can be disposed.
     */
    // tslint:disable-next-line:no-unused-variable
    shouldDisposeObjectGeometry(object) {
        return true;
    }
    /**
     * Called when the default implementation of `dispose()` needs
     * to free a `Tile` object's material.
     *
     * @param object The object referencing the geometry.
     * @returns `true` if the material can be disposed.
     */
    // tslint:disable-next-line:no-unused-variable
    shouldDisposeObjectMaterial(object) {
        return true;
    }
    /**
     * Called when the default implementation of `dispose()` needs
     * to free a Texture that is part of a `Tile` object's material.
     *
     * @param texture The texture about to be disposed.
     * @returns `true` if the texture can be disposed.
     */
    shouldDisposeTexture(texture) {
        return this.m_ownedTextures.has(texture);
    }
    /**
     * Returns `true` if this `Tile` has been disposed.
     */
    get disposed() {
        return this.m_disposed;
    }
    /**
     * Gets the [[TileGeometryLoader]] that manages this tile.
     */
    get tileGeometryLoader() {
        return this.m_tileGeometryLoader;
    }
    /**
     * Sets the [[TileGeometryLoader]] to manage this tile.
     *
     * @param tileGeometryLoader A [[TileGeometryLoader]] instance to manage the geometry creation
     *      for this tile.
     */
    set tileGeometryLoader(tileGeometryLoader) {
        this.m_tileGeometryLoader = tileGeometryLoader;
    }
    /**
     * `True` if the basic geometry has been loaded, and the `Tile` is ready  for display.
     */
    get basicGeometryLoaded() {
        return this.m_tileGeometryLoader === undefined
            ? this.hasGeometry
            : this.m_tileGeometryLoader.basicGeometryLoaded || this.m_tileGeometryLoader.isFinished;
    }
    /**
     * `True` if all geometry of the `Tile` has been loaded.
     */
    get allGeometryLoaded() {
        return this.m_tileGeometryLoader === undefined
            ? this.hasGeometry
            : this.m_tileGeometryLoader.allGeometryLoaded || this.m_tileGeometryLoader.isFinished;
    }
    /**
     * MapView checks if this `Tile` is ready to be rendered while culling.
     *
     * By default, MapView checks if the [[objects]] list is not empty. However, you can override
     * this check by manually setting this property.
     */
    get hasGeometry() {
        if (this.m_forceHasGeometry === undefined) {
            return this.objects.length !== 0;
        }
        else {
            return this.m_forceHasGeometry;
        }
    }
    /**
     * Overrides the default value for [[hasGeometry]].
     *
     * @param value A new value for the [[hasGeometry]] flag.
     */
    forceHasGeometry(value) {
        if (value) {
            this.setDecodedTile(defaultEmptyDecodedTile);
        }
        this.m_forceHasGeometry = value;
    }
    /**
     * Gets the [[ITileLoader]] that manages this tile.
     */
    get tileLoader() {
        return this.m_tileLoader;
    }
    /**
     * Sets the [[ITileLoader]] to manage this tile.
     *
     * @param tileLoader A [[ITileLoader]] instance to manage the loading process for this tile.
     */
    set tileLoader(tileLoader) {
        this.m_tileLoader = tileLoader;
    }
    /**
     * Forces the update of this `Tile` geometry.
     */
    reload() {
        this.dataSource.updateTile(this);
    }
    /**
     * Handler for animation of `Tile` geometries.
     */
    get animatedExtrusionTileHandler() {
        return this.m_animatedExtrusionTileHandler;
    }
    set animatedExtrusionTileHandler(handler) {
        this.m_animatedExtrusionTileHandler = handler;
    }
    /**
     * Frees the rendering resources allocated by this `Tile`.
     *
     * The default implementation of this method frees the geometries and the materials for all the
     * reachable objects.
     * Textures are freed if they are owned by this `Tile` (i.e. if they where created by this
     * `Tile`or if the ownership was explicitely set to this `Tile` by [[addOwnedTexture]]).
     */
    clear() {
        const disposeMaterial = (material) => {
            Object.getOwnPropertyNames(material).forEach((property) => {
                const materialProperty = material[property];
                if (materialProperty !== undefined && materialProperty instanceof THREE.Texture) {
                    const texture = materialProperty;
                    if (this.shouldDisposeTexture(texture)) {
                        texture.dispose();
                    }
                }
            });
            material.dispose();
        };
        const disposeObject = (object) => {
            if (object.geometry !== undefined && this.shouldDisposeObjectGeometry(object)) {
                object.geometry.dispose();
            }
            if (object.material !== undefined && this.shouldDisposeObjectMaterial(object)) {
                if (object.material instanceof Array) {
                    object.material.forEach((material) => {
                        if (material !== undefined) {
                            disposeMaterial(material);
                        }
                    });
                }
                else {
                    disposeMaterial(object.material);
                }
            }
        };
        this.objects.forEach((rootObject) => {
            rootObject.traverse((object) => {
                disposeObject(object);
            });
            disposeObject(rootObject);
        });
        this.objects.length = 0;
        if (this.preparedTextPaths) {
            this.preparedTextPaths = [];
        }
        if (this.m_animatedExtrusionTileHandler !== undefined) {
            this.m_animatedExtrusionTileHandler.dispose();
        }
        this.placedTextElements.clear();
        this.textElementGroups.clear();
        this.userTextElements.length = 0;
        this.invalidateResourceInfo();
    }
    /**
     * Disposes this `Tile`, freeing all geometries and materials for the reachable objects.
     */
    dispose() {
        if (this.m_disposed) {
            return;
        }
        if (this.m_tileLoader) {
            this.m_tileLoader.cancel();
            this.m_tileLoader = undefined;
        }
        if (this.m_tileGeometryLoader !== undefined) {
            this.m_tileGeometryLoader.dispose();
            this.m_tileGeometryLoader = undefined;
        }
        this.clear();
        this.userTextElements.length = 0;
        this.m_disposed = true;
        // Ensure that tile is removable from tile cache.
        this.frameNumLastRequested = 0;
    }
    computeResourceInfo() {
        let heapSize = 0;
        let num3dObjects = 0;
        let numTextElements = 0;
        let numUserTextElements = 0;
        const aggregatedObjSize = {
            heapSize: 0,
            gpuSize: 0
        };
        // Keep a map of the uuids of the larger objects, like Geometries, Materials and Attributes.
        // They should be counted only once even if they are shared.
        const visitedObjects = new Map();
        for (const object of this.objects) {
            if (object.visible) {
                num3dObjects++;
            }
            Utils_1.MapViewUtils.estimateObject3dSize(object, aggregatedObjSize, visitedObjects);
        }
        for (const group of this.textElementGroups.groups) {
            numTextElements += group[1].elements.length;
        }
        numUserTextElements = this.userTextElements.length;
        // 216 was the shallow size of a single TextElement last time it has been checked, 312 bytes
        // was the minimum retained size of a TextElement that was not being rendered. If a
        // TextElement is actually rendered, the size may be _much_ bigger.
        heapSize += (numTextElements + numUserTextElements) * 312;
        if (this.m_decodedTile !== undefined && this.m_decodedTile.tileInfo !== undefined) {
            aggregatedObjSize.heapSize += this.m_decodedTile.tileInfo.numBytes;
        }
        if (this.roadIntersectionData !== undefined) {
            heapSize += getRoadIntersectionDataSize(this.roadIntersectionData);
        }
        this.m_resourceInfo = {
            heapSize: aggregatedObjSize.heapSize + heapSize,
            gpuSize: aggregatedObjSize.gpuSize,
            num3dObjects,
            numTextElements,
            numUserTextElements
        };
    }
}
exports.Tile = Tile;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/Utils.js":
/*!******************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/Utils.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const geoUtils = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const EarthConstants_1 = __webpack_require__(/*! @here/harp-geoutils/lib/projection/EarthConstants */ "./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const Tile_1 = __webpack_require__(/*! ./Tile */ "./node_modules/@here/harp-mapview/lib/Tile.js");
const logger = harp_utils_1.LoggerManager.instance.create("MapViewUtils");
// Estimation of the size of an Object3D with all the simple properties, like matrices and flags.
// There may be cases where it is possible to construct Object3Ds with considerable less memory
// consumption, but this value is used to simplify the estimation.
const MINIMUM_OBJECT3D_SIZE_ESTIMATION = 1000;
const MINIMUM_ATTRIBUTE_SIZE_ESTIMATION = 56;
var MapViewUtils;
(function (MapViewUtils) {
    //Caching those for performance reasons.
    const groundPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1));
    const groundSphere = new THREE.Sphere(undefined, EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS);
    const cameraZPosition = new THREE.Vector3(0, 0, 0);
    const rotationMatrix = new THREE.Matrix4();
    const unprojectionMatrix = new THREE.Matrix4();
    const rayCaster = new THREE.Raycaster();
    /**
     * Yaw rotation as quaternion. Declared as a const to avoid object re-creation in certain
     * functions.
     */
    const yawQuaternion = new THREE.Quaternion();
    /**
     * Pitch rotation as quaternion. Declared as a const to avoid object re-creation in certain
     *  functions.
     */
    const pitchQuaternion = new THREE.Quaternion();
    /**
     * The yaw axis around we rotate when we change the yaw.
     * This axis is fix and is the -Z axis `(0,0,1)`.
     */
    const yawAxis = new THREE.Vector3(0, 0, 1);
    /**
     * The pitch axis which we use to rotate around when we change the pitch.
     * The axis is fix and is the +X axis `(1,0,0)`.
     */
    const pitchAxis = new THREE.Vector3(1, 0, 0);
    /**
     * Zooms and moves the map in such a way that the given target position remains at the same
     * position after the zoom.
     *
     * @param mapView Instance of MapView
     * @param targetPositionOnScreenXinNDC Target x position in NDC space.
     * @param targetPositionOnScreenYinNDC Target y position in NDC space.
     */
    function zoomOnTargetPosition(mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC, zoomLevel) {
        //Get current target position in world space before we zoom.
        const targetPosition = rayCastWorldCoordinates(mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC);
        //Set the cameras height according to the given zoom level.
        mapView.camera.position.setZ(calculateDistanceToGroundFromZoomLevel(mapView, zoomLevel));
        mapView.camera.matrixWorldNeedsUpdate = true;
        //Get new target position after the zoom
        const newTargetPosition = rayCastWorldCoordinates(mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC);
        if (!targetPosition || !newTargetPosition) {
            return;
        }
        //Calculate the difference and pan the map to maintain
        //the map relative to the target position.
        const diff = targetPosition.sub(newTargetPosition);
        pan(mapView, diff.x, diff.y);
    }
    MapViewUtils.zoomOnTargetPosition = zoomOnTargetPosition;
    /**
     * Returns the [[GeoCoordinates]] of the camera, given its target coordinates on the map and its
     * zoom, yaw and pitch.
     *
     * @param targetCoordinates Coordinates of the center of the view.
     * @param distance Distance to the target in meters.
     * @param yawDeg Camera yaw in degrees.
     * @param pitchDeg Camera pitch in degrees.
     * @param mapView Active MapView, needed to get the camera fov and map projection.
     */
    function getCameraCoordinatesFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, mapView) {
        // Get the world distance between the target and the camera.
        const pitchRad = THREE.Math.degToRad(pitchDeg);
        const cameraHeight = distance * Math.cos(pitchRad);
        const projectedDistanceOnTheGround = cameraHeight * Math.tan(pitchRad);
        // Get the camera coordinates.
        const yawRad = THREE.Math.degToRad(yawDeg);
        const worldTargetCoordinates = mapView.projection.projectPoint(targetCoordinates);
        const cameraWorldCoordinates = {
            x: worldTargetCoordinates.x + Math.sin(yawRad) * projectedDistanceOnTheGround,
            y: worldTargetCoordinates.y - Math.cos(yawRad) * projectedDistanceOnTheGround,
            z: 0
        };
        // Convert back to GeoCoordinates and return result.
        return mapView.projection.unprojectPoint(cameraWorldCoordinates);
    }
    MapViewUtils.getCameraCoordinatesFromTargetCoordinates = getCameraCoordinatesFromTargetCoordinates;
    /**
     * Casts a ray in NDC space from the current map view and returns the intersection point of that
     * ray wih the map in world space.
     *
     * @param mapView Instance of MapView.
     * @param pointOnScreenXinNDC X coordinate in NDC space.
     * @param pointOnScreenYinNDC Y coordinate in NDC space.
     * @param elevation Optional param used to offset the ground plane. Used when wanting to pan
     * based on a plane at some altitude. Necessary for example when panning with terrain.
     *
     * @returns Intersection coordinates, or `null` if raycast failed.
     */
    function rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC, elevation) {
        const pointInNDCPosition = new THREE.Vector3(pointOnScreenXinNDC, pointOnScreenYinNDC, 0.5);
        cameraZPosition.copy(mapView.camera.position);
        rotationMatrix.extractRotation(mapView.camera.matrixWorld);
        //Prepare the unprojection matrix which projects from NDC space to camera space
        //and takes the current rotation of the camera into account.
        unprojectionMatrix.multiplyMatrices(rotationMatrix, unprojectionMatrix.getInverse(mapView.camera.projectionMatrix));
        //Unproject the point via the the unprojection matrix.
        const pointInCameraSpace = pointInNDCPosition.applyMatrix4(unprojectionMatrix);
        //Use the point in camera space as the vector towards this point.
        rayCaster.set(cameraZPosition, pointInCameraSpace.normalize());
        if (elevation !== undefined) {
            groundPlane.constant = -elevation;
        }
        const worldPosition = new THREE.Vector3();
        const result = mapView.projection.type === geoUtils.ProjectionType.Planar
            ? rayCaster.ray.intersectPlane(groundPlane, worldPosition)
            : rayCaster.ray.intersectSphere(groundSphere, worldPosition);
        groundPlane.constant = 0;
        return result;
    }
    MapViewUtils.rayCastWorldCoordinates = rayCastWorldCoordinates;
    /**
     * Calculates and returns the distance from the ground,
     * which is needed to put the camera to this
     * height, to see the size of the area, which would be covered
     * by one tile for the given zoom level.
     *
     * @param mapView Instance of MapView.
     * @param zoomLevel
     */
    function calculateDistanceToGroundFromZoomLevel(mapView, zoomLevel) {
        const cameraPitch = extractYawPitchRoll(mapView.camera.quaternion).pitch;
        const tileSize = EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);
        return ((mapView.focalLength * tileSize) / 256) * Math.cos(cameraPitch);
    }
    MapViewUtils.calculateDistanceToGroundFromZoomLevel = calculateDistanceToGroundFromZoomLevel;
    /**
     * Pans the camera according to the projection.
     *
     * @param mapView Instance of MapView.
     * @param xOffset In world space. Value > 0 will pan the map to the right, value < 0 will pan
     * the map to the left in default camera orientation.
     * @param yOffset In world space. Value > 0 will pan the map upwards, value < 0 will pan the map
     * downwards in default camera orientation.
     */
    function pan(mapView, offsetX, offsetY) {
        mapView.camera.position.x += offsetX;
        mapView.camera.position.y += offsetY;
        mapView.update();
    }
    MapViewUtils.pan = pan;
    /**
     * Sets the rotation of the camera according to yaw and pitch in degrees.
     *
     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the
     * map.
     *
     * @param mapView Instance of MapView.
     * @param yaw Yaw in degrees.
     * @param pitch Pitch in degrees.
     */
    function setRotation(mapView, yaw, pitch) {
        yawQuaternion.setFromAxisAngle(yawAxis, geoUtils.MathUtils.degToRad(yaw));
        pitchQuaternion.setFromAxisAngle(pitchAxis, geoUtils.MathUtils.degToRad(pitch));
        yawQuaternion.multiply(pitchQuaternion);
        mapView.camera.quaternion.copy(yawQuaternion);
        mapView.camera.matrixWorldNeedsUpdate = true;
    }
    MapViewUtils.setRotation = setRotation;
    /**
     * Extracts yaw, pitch, and roll rotation in radians.
     * - Yaw : Rotation around the Z axis `(0,0,1)`.
     * - Pitch :Rotation around the X axis `(1,0,0)`.
     * - Roll : Rotation around the Y axis `(0,1,0)`.
     *
     * @see https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles
     *
     * @param q : Quaternion that represents the given rotation
     * from which to extract the yaw, roll, and pitch.
     */
    function extractYawPitchRoll(q) {
        const ysqr = q.y * q.y;
        // pitch (x-axis rotation)
        const t0 = +2.0 * (q.w * q.x + q.y * q.z);
        const t1 = +1.0 - 2.0 * (q.x * q.x + ysqr);
        const pitch = Math.atan2(t0, t1);
        // roll (y-axis rotation)
        let t2 = +2.0 * (q.w * q.y - q.z * q.x);
        t2 = t2 > 1.0 ? 1.0 : t2;
        t2 = t2 < -1.0 ? -1.0 : t2;
        const roll = Math.asin(t2);
        // yaw (z-axis rotation)
        const t3 = +2.0 * (q.w * q.z + q.x * q.y);
        const t4 = +1.0 - 2.0 * (ysqr + q.z * q.z);
        const yaw = Math.atan2(t3, t4);
        return { yaw, pitch, roll };
    }
    MapViewUtils.extractYawPitchRoll = extractYawPitchRoll;
    /**
     * Casts a ray in NDC space from the current view of the camera and returns the intersection
     * point of that ray against the map in geo coordinates. The return value can be `null` when
     * the raycast is above the horizon.
     *
     * @param mapView Instance of MapView.
     * @param pointOnScreenNDC  Point in NDC space.
     * @returns Intersection geo coordinates, or `null` if raycast is above the horizon.
     */
    function rayCastGeoCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC) {
        const worldCoordinates = rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC);
        if (!worldCoordinates) {
            return null;
        }
        return mapView.projection.unprojectPoint(worldCoordinates);
    }
    MapViewUtils.rayCastGeoCoordinates = rayCastGeoCoordinates;
    /**
     * Calculates the zoom level, which corresponds to the current distance from
     * camera to lookAt point.
     * Therefore the zoom level is a `float` and not an `int`. The height of the camera can be in
     * between zoom levels. By setting the zoom level, you change the height position of the camera
     * in away that the field of view of the camera should be able to cover one tile for the given
     * zoom level.
     *
     * As an example for this, when you have a tile of zoom level 14 in front of the camera and you
     * set the zoom level of the camera to 14, then you are able to see the whole tile in front of
     * you.
     */
    function calculateZoomLevelFromDistance(distance, mapView) {
        const tileSize = (256 * distance) / mapView.focalLength;
        return geoUtils.MathUtils.clamp(Math.log2(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / tileSize), mapView.minZoomLevel, mapView.maxZoomLevel);
    }
    MapViewUtils.calculateZoomLevelFromDistance = calculateZoomLevelFromDistance;
    /**
     * Translates a linear clip-space distance value to the actual value stored in the depth buffer.
     * This is useful as the depth values are not stored in the depth buffer linearly, and this can
     * lead into confusing behavior when not taken into account.
     *
     * @param clipDistance Distance from the camera in clip space (range: [0, 1]).
     * @param camera Camera applying the perspective projection.
     */
    function calculateDepthFromClipDistance(clipDistance, camera) {
        const perspCam = camera;
        const cameraRange = perspCam.far - perspCam.near;
        const viewSpaceDistance = clipDistance * perspCam.far;
        return (1.0 - perspCam.near / viewSpaceDistance) * (perspCam.far / cameraRange);
    }
    MapViewUtils.calculateDepthFromClipDistance = calculateDepthFromClipDistance;
    /**
     * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into
     * [0..cameraFar].
     *
     * @param distance Distance from the camera (range: [0, 1]).
     * @param camera Camera applying the perspective projection.
     */
    function cameraToWorldDistance(distance, camera) {
        const perspCam = camera;
        return distance * perspCam.far;
    }
    MapViewUtils.cameraToWorldDistance = cameraToWorldDistance;
    /**
     * Calculates vertical field of view for given horizontal field of vision and aspect ratio.
     *
     * @param hFov Horizontal field of view in rad.
     * @param aspect Aspect ratio.
     */
    function calculateVerticalFovByHorizontalFov(hFov, aspect) {
        return 2 * Math.atan(Math.tan(hFov / 2) / aspect);
    }
    MapViewUtils.calculateVerticalFovByHorizontalFov = calculateVerticalFovByHorizontalFov;
    /**
     * Calculates horizontal field of view for given vertical field of vision and aspect ratio.
     *
     * @param hFov Vertical field of view in rad.
     * @param aspect Aspect ratio.
     */
    function calculateHorizontalFovByVerticalFov(vFov, aspect) {
        return 2 * Math.atan(Math.tan(vFov / 2) * aspect);
    }
    MapViewUtils.calculateHorizontalFovByVerticalFov = calculateHorizontalFovByVerticalFov;
    /**
     * Calculates the focal length based on the vertical FOV and height.
     *
     * @param vFov Vertical field of view in rad.
     * @param height Height of canvas in pixels.
     */
    function calculateFocalLengthByVerticalFov(vFov, height) {
        return height / 2 / Math.tan(vFov / 2);
    }
    MapViewUtils.calculateFocalLengthByVerticalFov = calculateFocalLengthByVerticalFov;
    /**
     * Calculates the vertical field of view based on the focal length and the height.
     *
     * @param focalLength Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])
     * @param height Height of canvas in pixels.
     */
    function calculateFovByFocalLength(focalLength, height) {
        return geoUtils.MathUtils.radToDeg(2 * Math.atan(height / 2 / focalLength));
    }
    MapViewUtils.calculateFovByFocalLength = calculateFovByFocalLength;
    /**
     * Calculates object's screen size based on the focal length and it's camera distance.
     *
     * @param focalLength Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])
     * @param distance Object distance in world space.
     * @param worldSize Object size in world space.
     * @return object size in screen space.
     */
    function calculateScreenSizeByFocalLength(focalLength, distance, worldSize) {
        return (focalLength * worldSize) / distance;
    }
    MapViewUtils.calculateScreenSizeByFocalLength = calculateScreenSizeByFocalLength;
    /**
     * Calculates object's world size based on the focal length and it's camera distance.
     *
     * @param focalLength Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])
     * @param distance Object distance in world space.
     * @param screenSize Object size in screen space.
     * @return object size in world space.
     */
    function calculateWorldSizeByFocalLength(focalLength, distance, screenSize) {
        return (distance * screenSize) / focalLength;
    }
    MapViewUtils.calculateWorldSizeByFocalLength = calculateWorldSizeByFocalLength;
    /**
     * Computes estimate for size of a THREE.Object3D object and its children. Shared materials
     * and/or attributes will be counted multiple times.
     *
     * @param object The mesh object to evaluate
     * @param size The [[MemoryUsage]] to update.
     * @param visitedObjects Optional map to store large objects that could be shared.
     *
     * @returns Estimate of object size in bytes for heap and GPU.
     */
    function estimateObject3dSize(object, parentSize, visitedObjects) {
        const size = parentSize !== undefined
            ? parentSize
            : {
                heapSize: 0,
                gpuSize: 0
            };
        if (visitedObjects === undefined) {
            visitedObjects = new Map();
        }
        estimateMeshSize(object, size, visitedObjects);
        if (object.children.length > 0) {
            for (const child of object.children) {
                estimateObject3dSize(child, size, visitedObjects);
            }
        }
        return size;
    }
    MapViewUtils.estimateObject3dSize = estimateObject3dSize;
    function estimateTextureSize(texture, objectSize, visitedObjects) {
        if (texture === null || texture.image === undefined) {
            return;
        }
        if (texture.uuid !== undefined && visitedObjects.get(texture.uuid) === true) {
            return;
        }
        visitedObjects.set(texture.uuid, true);
        // May be HTMLImage or ImageData
        const image = texture.image;
        // Assuming RGBA
        const imageBytes = 4 * image.width * image.height;
        objectSize.heapSize += imageBytes;
        objectSize.gpuSize += imageBytes;
    }
    function estimateMaterialSize(material, objectSize, visitedObjects) {
        if (material.uuid !== undefined && visitedObjects.get(material.uuid) === true) {
            return;
        }
        visitedObjects.set(material.uuid, true);
        if (material instanceof THREE.RawShaderMaterial ||
            material instanceof THREE.ShaderMaterial) {
            const rawMaterial = material;
            for (const name in rawMaterial.uniforms) {
                if (rawMaterial.uniforms[name] !== undefined) {
                    const uniform = rawMaterial.uniforms[name];
                    if (uniform instanceof THREE.Texture) {
                        estimateTextureSize(uniform, objectSize, visitedObjects);
                    }
                }
            }
        }
        else if (material instanceof THREE.MeshBasicMaterial ||
            material instanceof harp_materials_1.MapMeshBasicMaterial) {
            const meshMaterial = material;
            estimateTextureSize(meshMaterial.map, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.aoMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.specularMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.alphaMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.envMap, objectSize, visitedObjects);
        }
        else if (material instanceof harp_materials_1.MapMeshStandardMaterial) {
            const standardMaterial = material;
            estimateTextureSize(standardMaterial.map, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.lightMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.aoMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.emissiveMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.bumpMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.normalMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.displacementMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.roughnessMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.metalnessMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.alphaMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.envMap, objectSize, visitedObjects);
        }
        else if (material instanceof THREE.LineBasicMaterial ||
            material instanceof THREE.LineDashedMaterial) {
            // Nothing to be done here
        }
        else {
            logger.warn("estimateMeshSize: unidentified material: ", material);
        }
    }
    function estimateAttributeSize(attribute, attrName, objectSize, visitedObjects) {
        // Attributes (apparently) do not have their uuid set up.
        if (attribute.uuid === undefined) {
            attribute.uuid = THREE.Math.generateUUID();
        }
        if (visitedObjects.get(attribute.uuid) === true) {
            return;
        }
        visitedObjects.set(attribute.uuid, true);
        let attrBytes = 0;
        let bytesPerElement = 4;
        if (attribute.array.BYTES_PER_ELEMENT !== undefined) {
            bytesPerElement = attribute.array.BYTES_PER_ELEMENT;
        }
        if (attribute instanceof THREE.InterleavedBufferAttribute ||
            attribute instanceof THREE.BufferAttribute) {
            attrBytes = bytesPerElement * attribute.count * attribute.itemSize;
        }
        else {
            logger.warn("estimateMeshSize: unidentified attribute: ", attrName);
        }
        objectSize.heapSize += attrBytes + MINIMUM_ATTRIBUTE_SIZE_ESTIMATION;
        objectSize.gpuSize += attrBytes;
    }
    function estimateGeometrySize(geometry, objectSize, visitedObjects) {
        const isNewObject = geometry.uuid === undefined || visitedObjects.get(geometry.uuid) !== true;
        if (!isNewObject) {
            return;
        }
        visitedObjects.set(geometry.uuid, true);
        let bufferGeometry;
        if (geometry instanceof THREE.Geometry) {
            // Each vertex is represented as 3 floats vector (24 bytes).
            objectSize.heapSize += geometry.vertices.length * 24;
            // Face: 3 indices (24 byte), 1 normal (3 floats = 24). Vertex normals and
            // colors are not counted here.
            objectSize.heapSize += geometry.faces.length * (24 + 24);
            // Additionally, the internal _bufferGeometry is also counted:
            bufferGeometry = geometry._bufferGeometry;
        }
        else if (geometry instanceof THREE.BufferGeometry) {
            bufferGeometry = geometry;
        }
        if (bufferGeometry === undefined) {
            // Nothing more to calculate.
            return;
        }
        const attributes = bufferGeometry.attributes;
        if (attributes === undefined) {
            logger.warn("estimateGeometrySize: unidentified geometry: ", geometry);
            return;
        }
        for (const property in attributes) {
            if (attributes[property] !== undefined) {
                estimateAttributeSize(attributes[property], property, objectSize, visitedObjects);
            }
        }
        if (bufferGeometry.index !== null) {
            estimateAttributeSize(bufferGeometry.index, "index", objectSize, visitedObjects);
        }
    }
    function estimateMeshSize(object, objectSize, visitedObjects) {
        if (!object.isObject3D || object instanceof THREE.Scene) {
            return;
        }
        if (object.uuid !== undefined && visitedObjects.get(object.uuid) === true) {
            return;
        }
        visitedObjects.set(object.uuid, true);
        if (object.isMesh || object.isLine || object.isPoints) {
            // Estimated minimum impact on heap.
            let heapSize = MINIMUM_OBJECT3D_SIZE_ESTIMATION;
            const gpuSize = 0;
            // Cast to Points class which contains the minimal required properties sub-set.
            const mesh = object;
            // Calculate material(s) impact.
            if (mesh.material !== undefined) {
                if (Array.isArray(mesh.material)) {
                    const materials = mesh.material;
                    for (const material of materials) {
                        estimateMaterialSize(material, objectSize, visitedObjects);
                    }
                }
                else {
                    const material = mesh.material;
                    estimateMaterialSize(material, objectSize, visitedObjects);
                }
            }
            // Calculate cost of geometry.
            if (mesh.geometry !== undefined) {
                estimateGeometrySize(mesh.geometry, objectSize, visitedObjects);
            }
            // Add info that is required for picking (parts of) objects and match them to
            // the featureID in the map data.
            const featureData = object.userData !== undefined
                ? object.userData.feature
                : undefined;
            if (featureData !== undefined) {
                heapSize += Tile_1.getFeatureDataSize(featureData);
            }
            objectSize.heapSize += heapSize;
            objectSize.gpuSize += gpuSize;
        }
        else {
            logger.warn("estimateMeshSize: unidentified object", object);
        }
    }
    /**
     * Gets language list used by the browser
     *
     * @returns Array of iso language codes
     */
    function getBrowserLanguages() {
        if (navigator.languages !== undefined && navigator.languages.length > 0) {
            const languageList = [];
            for (const lang of navigator.languages) {
                languageList.push(getIsoLanguageCode(lang));
            }
            return languageList;
        }
        if (navigator.language !== undefined) {
            return [getIsoLanguageCode(navigator.language)];
        }
        return undefined;
    }
    MapViewUtils.getBrowserLanguages = getBrowserLanguages;
    /**
     * Gets ISO-639-1 language code from browser's code (ex. en for en-US)
     */
    function getIsoLanguageCode(language) {
        return language.substring(0, 2);
    }
})(MapViewUtils = exports.MapViewUtils || (exports.MapViewUtils = {}));
/** @hidden */
const powerOfTwo = [
    0x1,
    0x2,
    0x4,
    0x8,
    0x10,
    0x20,
    0x40,
    0x80,
    0x100,
    0x200,
    0x400,
    0x800,
    0x1000,
    0x2000,
    0x4000,
    0x8000,
    0x10000,
    0x20000,
    0x40000,
    0x80000,
    0x100000,
    0x200000,
    0x400000,
    0x800000,
    0x1000000,
    0x2000000,
    0x4000000,
    0x8000000,
    0x10000000,
    0x20000000,
    0x40000000,
    0x80000000,
    0x100000000,
    0x200000000,
    0x400000000,
    0x800000000,
    0x1000000000,
    0x2000000000,
    0x4000000000,
    0x8000000000,
    0x10000000000,
    0x20000000000,
    0x40000000000,
    0x80000000000,
    0x100000000000,
    0x200000000000,
    0x400000000000,
    0x800000000000,
    0x1000000000000,
    0x2000000000000,
    0x4000000000000,
    0x8000000000000,
    0x10000000000000
];
var TileOffsetUtils;
(function (TileOffsetUtils) {
    /**
     * Creates a unique key based on the supplied parameters. Note, the uniqueness is bounded by the
     * bitshift. The [[TileKey.mortonCode()]] supports currently up to 26 levels (this is because
     * 26*2 equals 52, and 2^52 is the highest bit that can be set in an integer in Javascript), the
     * bitshift reduces this accordingly, so given the default bitshift of four, we support up to 24
     * levels. Given the current support up to level 19 this should be fine.
     *
     * @param tileKey The unique [[TileKey]] from which to compute the unique key.
     * @param offset How much the given [[TileKey]] is offset
     * @param bitshift How much space we have to store the offset. The default of 4 means we have
     *      enough space to store 16 unique tiles in a single view.
     */
    function getKeyForTileKeyAndOffset(tileKey, offset, bitshift = 4) {
        const shiftedOffset = getShiftedOffset(offset, bitshift);
        return tileKey.mortonCode() + shiftedOffset;
    }
    TileOffsetUtils.getKeyForTileKeyAndOffset = getKeyForTileKeyAndOffset;
    /**
     * Extracts the offset and morton key from the given key (must be created by:
     * [[getKeyForTileKeyAndOffset]])
     *
     * Note, we can't use bitshift operators in Javascript because they work on 32-bit integers, and
     * would truncate the numbers, hence using powers of two.
     *
     * @param key Key to extract offset and morton key.
     * @param bitshift How many bits to shift by, must be the same as was used when creating the
     * key.
     */
    function extractOffsetAndMortonKeyFromKey(key, bitshift = 4) {
        let offset = 0;
        let mortonCode = key;
        let i = 0;
        // Compute the offset
        for (; i < bitshift; i++) {
            // Note, we use 52, because 2^53-1 is the biggest value, the highest value
            // that can be set is the bit in the 52th position.
            const num = powerOfTwo[52 - i];
            if (mortonCode >= num) {
                mortonCode -= num;
                offset += powerOfTwo[bitshift - 1 - i];
            }
        }
        // We subtract half of the total amount, this undoes what is computed in getShiftedOffset
        offset -= powerOfTwo[bitshift - 1];
        return { offset, mortonCode };
    }
    TileOffsetUtils.extractOffsetAndMortonKeyFromKey = extractOffsetAndMortonKeyFromKey;
    /**
     * Returns the key of the parent. Key must have been computed using the function
     * [[getKeyForTileKeyAndOffset]].
     *
     * @param calculatedKey Key to decompose
     * @param bitshift Bit shift used to create the key
     */
    function getParentKeyFromKey(calculatedKey, bitshift = 4) {
        const { offset, mortonCode } = extractOffsetAndMortonKeyFromKey(calculatedKey, bitshift);
        const parentTileKey = geoUtils.TileKey.fromMortonCode(geoUtils.TileKey.parentMortonCode(mortonCode));
        return getKeyForTileKeyAndOffset(parentTileKey, offset, bitshift);
    }
    TileOffsetUtils.getParentKeyFromKey = getParentKeyFromKey;
    /**
     * Packs the supplied offset into the high bits, where the highbits are between 2^52 and
     * 2^(52-bitshift).
     *
     * Offsets are wrapped around, to fit in the offsetBits. In practice, this doesn't really
     * matter, this is primarily used to find a unique id, if there is an offset 10, which is
     * wrapped to 2, it doesn't matter, because the offset of 10 is still stored in the tile.
     * What can be a problem though is that the cache gets filled up and isn't emptied.
     *
     * Note, because bit shifting in JavaScript works on 32 bit integers, we use powers of 2 to set
     * the high bits instead.
     *
     * @param offset Offset to pack into the high bits.
     * @param offsetBits How many bits to use to pack the offset.
     */
    function getShiftedOffset(offset, offsetBits = 4) {
        let result = 0;
        const totalOffsetsToStore = powerOfTwo[offsetBits];
        //Offsets are stored by adding half 2 ^ (bitshift - 1), i.e.half of the max amount stored,
        //and then wrapped based on this value.For example, given a bitshift of 3, and an offset -
        //3, it would have 4 added(half of 2 ^ 3), and be stored as 1, 3 would have 4 added and be
        //stored as 7, 4 would be added with 4 and be stored as 0 (it wraps around).
        offset += totalOffsetsToStore / 2;
        while (offset < 0) {
            offset += totalOffsetsToStore;
        }
        while (offset >= totalOffsetsToStore) {
            offset -= totalOffsetsToStore;
        }
        // Offset is now a number between >= 0 and < totalOffsetsToStore
        for (let i = 0; i < offsetBits && offset > 0; i++) {
            // tslint:disable: no-bitwise
            // 53 is used because 2^53-1 is the biggest number that Javascript can represent as an
            // integer safely.
            if (offset & 0x1) {
                result += powerOfTwo[53 - offsetBits + i];
            }
            offset >>>= 1;
            // tslint:enable: no-bitwise
        }
        harp_utils_1.assert(offset === 0);
        return result;
    }
})(TileOffsetUtils = exports.TileOffsetUtils || (exports.TileOffsetUtils = {}));


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/VisibleTileSet.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/VisibleTileSet.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_geometry_1 = __webpack_require__(/*! @here/harp-geometry */ "./node_modules/@here/harp-geometry/index.js");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_lrucache_1 = __webpack_require__(/*! @here/harp-lrucache */ "./node_modules/@here/harp-lrucache/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const ElevationRangeSource_1 = __webpack_require__(/*! ./ElevationRangeSource */ "./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js");
const MapTileCuller_1 = __webpack_require__(/*! ./MapTileCuller */ "./node_modules/@here/harp-mapview/lib/MapTileCuller.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-mapview/lib/Utils.js");
/**
 * Way the memory consumption of a tile is computed. Either in number of tiles, or in MegaBytes. If
 * it is in MB, an estimation is used.
 */
var ResourceComputationType;
(function (ResourceComputationType) {
    ResourceComputationType[ResourceComputationType["EstimationInMb"] = 0] = "EstimationInMb";
    ResourceComputationType[ResourceComputationType["NumberOfTiles"] = 1] = "NumberOfTiles";
})(ResourceComputationType = exports.ResourceComputationType || (exports.ResourceComputationType = {}));
/**
 * Represents a unique TileKey and the area it takes up on screen.
 *
 * Note, in certain tiling projections, it is possible to have an offset, which represents a tile
 * which has fully wrapped around, hence this defaults to 0 to simplify usage for projections which
 * don't require it.
 */
class TileKeyEntry {
    constructor(tileKey, area, offset = 0) {
        this.tileKey = tileKey;
        this.area = area;
        this.offset = offset;
    }
}
const MB_FACTOR = 1.0 / (1024.0 * 1024.0);
/**
 * Missing Typedoc
 */
class DataSourceCache {
    constructor(options, dataSource) {
        this.dataSource = dataSource;
        this.disposedTiles = [];
        this.resourceComputationType = ResourceComputationType.EstimationInMb;
        this.resourceComputationType =
            options.resourceComputationType === undefined
                ? ResourceComputationType.EstimationInMb
                : options.resourceComputationType;
        this.tileCache = new harp_lrucache_1.LRUCache(options.tileCacheSize, (tile) => {
            if (this.resourceComputationType === ResourceComputationType.EstimationInMb) {
                // Default is size in MB.
                return tile.memoryUsage * MB_FACTOR;
            }
            else {
                return 1;
            }
        });
        this.tileCache.evictionCallback = (_, tile) => {
            if (tile.tileLoader !== undefined) {
                // Cancel downloads as early as possible.
                tile.tileLoader.cancel();
            }
            this.disposedTiles.push(tile);
        };
        this.tileCache.canEvict = (_, tile) => {
            // Tiles can be evicted that weren't requested in the last frame.
            return !tile.isVisible;
        };
    }
    disposeTiles() {
        this.disposedTiles.forEach(tile => {
            tile.dispose();
        });
        this.disposedTiles.length = 0;
    }
    get(tileCode) {
        return this.tileCache.get(tileCode);
    }
}
/**
 * Manages visible [[Tile]]s for [[MapView]].
 *
 * Responsible for election of rendered tiles:
 *  - quad-tree traversal
 *  - frustum culling
 *  - sorting tiles by relevance (visible area) to prioritize load
 *  - limiting number of visible tiles
 *  - caching tiles
 *  - searching cache to replace visible but yet empty tiles with already loaded siblings in nearby
 *    zoom levels
 */
class VisibleTileSet {
    constructor(m_camera, m_tileGeometryManager, options) {
        this.m_camera = m_camera;
        this.m_tileGeometryManager = m_tileGeometryManager;
        this.dataSourceTileList = [];
        this.allVisibleTilesLoaded = false;
        this.m_dataSourceCache = new Map();
        // used to project global coordinates into camera local coordinates
        this.m_viewProjectionMatrix = new THREE.Matrix4();
        this.m_frustum = new THREE.Frustum();
        this.m_ResourceComputationType = ResourceComputationType.EstimationInMb;
        this.m_mapTileCuller = new MapTileCuller_1.MapTileCuller(m_camera);
        this.options = options;
    }
    /**
     * Returns cache size.
     */
    getDataSourceCacheSize() {
        return this.options.tileCacheSize;
    }
    /**
     * Sets cache size.
     *
     * @param size cache size
     * @param computationType Optional value specifying the way a [[Tile]]s cache usage is computed,
     *      either based on size in MB (mega bytes) or in number of tiles. Defaults to
     *      `ResourceComputationType.EstimationInMb`.
     */
    setDataSourceCacheSize(size, computationType = ResourceComputationType.EstimationInMb) {
        this.options.tileCacheSize = size;
        this.resourceComputationType = computationType;
    }
    /**
     * Retrieves maximum number of visible tiles.
     */
    getNumberOfVisibleTiles() {
        return this.options.maxVisibleDataSourceTiles;
    }
    /**
     * Sets maximum number of visible tiles.
     *
     * @param size size of visible tiles array
     */
    setNumberOfVisibleTiles(size) {
        this.options.maxVisibleDataSourceTiles = size;
    }
    /**
     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of
     * tiles.
     */
    get resourceComputationType() {
        return this.m_ResourceComputationType;
    }
    set resourceComputationType(computationType) {
        this.m_ResourceComputationType = computationType;
        this.m_dataSourceCache.forEach(dataStore => {
            dataStore.tileCache.setCapacity(this.options.tileCacheSize);
            dataStore.resourceComputationType = computationType;
            dataStore.tileCache.shrinkToCapacity();
        });
    }
    updateRenderList(worldCenter, storageLevel, zoomLevel, dataSources, elevationRangeSource) {
        this.m_viewProjectionMatrix.multiplyMatrices(this.m_camera.projectionMatrix, this.m_camera.matrixWorldInverse);
        this.m_frustum.setFromMatrix(this.m_viewProjectionMatrix);
        let allVisibleTilesLoaded = true;
        if (this.options.extendedFrustumCulling) {
            this.m_mapTileCuller.setup();
        }
        const visibleTileResult = this.getVisibleTilesForDataSources(worldCenter, zoomLevel, dataSources, elevationRangeSource);
        this.dataSourceTileList = [];
        for (const { dataSource, visibleTiles } of visibleTileResult.tiles) {
            // Sort by projected (visible) area, now the tiles that are further away are at the end
            // of the list.
            //
            // Sort is unstable if distance is equal, which happens a lot when looking top-down.
            // Unstable sorting makes label placement unstable at tile borders, leading to
            // flickering.
            visibleTiles.sort((a, b) => {
                const areaDiff = b.area - a.area;
                // Take care or numerical precision issues
                const minDiff = (a.area + b.area) * 0.001;
                return Math.abs(areaDiff) < minDiff
                    ? b.tileKey.mortonCode() - a.tileKey.mortonCode()
                    : areaDiff;
            });
            const actuallyVisibleTiles = [];
            let allDataSourceTilesLoaded = true;
            let numTilesLoading = 0;
            // Create actual tiles only for the allowed number of visible tiles
            const displayZoomLevel = dataSource.getDisplayZoomLevel(zoomLevel);
            for (let i = 0; i < visibleTiles.length &&
                actuallyVisibleTiles.length < this.options.maxVisibleDataSourceTiles; i++) {
                const tileEntry = visibleTiles[i];
                if (!dataSource.shouldRender(displayZoomLevel, tileEntry.tileKey)) {
                    continue;
                }
                const tile = this.getTile(dataSource, tileEntry.tileKey, tileEntry.offset);
                if (tile === undefined) {
                    continue;
                }
                tile.prepareTileInfo();
                allDataSourceTilesLoaded = allDataSourceTilesLoaded && tile.hasGeometry;
                if (!tile.hasGeometry) {
                    numTilesLoading++;
                }
                else {
                    tile.numFramesVisible++;
                    if (tile.frameNumVisible < 0) {
                        // Store the fist frame the tile became visible.
                        tile.frameNumVisible = dataSource.mapView.frameNumber;
                    }
                }
                actuallyVisibleTiles.push(tile);
                // Update the visible area of the tile. This is used for those tiles that are
                // currently loaded and are waiting to be decoded to sort the jobs by area.
                tile.visibleArea = tileEntry.area;
            }
            this.m_tileGeometryManager.updateTiles(actuallyVisibleTiles);
            this.dataSourceTileList.push({
                dataSource,
                storageLevel,
                zoomLevel: displayZoomLevel,
                allVisibleTileLoaded: allDataSourceTilesLoaded,
                numTilesLoading,
                visibleTiles: actuallyVisibleTiles,
                renderedTiles: actuallyVisibleTiles
            });
            allVisibleTilesLoaded = allVisibleTilesLoaded && allDataSourceTilesLoaded;
        }
        this.allVisibleTilesLoaded =
            allVisibleTilesLoaded && visibleTileResult.allBoundingBoxesFinal;
        this.fillMissingTilesFromCache();
        this.forEachCachedTile(tile => {
            // Remove all tiles that are still being loaded, but are no longer visible. They have to
            // be reloaded when they become visible again. Hopefully, they are still in the browser
            // cache by then.
            if (!tile.isVisible && tile.tileLoader !== undefined && !tile.tileLoader.isFinished) {
                // The internal TileLoader is cancelled automatically when the Tile is disposed.
                this.disposeTile(tile);
            }
        });
        this.dataSourceTileList.forEach(renderListEntry => {
            const dataSource = renderListEntry.dataSource;
            const cache = this.m_dataSourceCache.get(dataSource.name);
            if (cache !== undefined) {
                cache.tileCache.shrinkToCapacity();
            }
        });
    }
    getTile(dataSource, tileKey, offset = 0) {
        function updateTile(tileToUpdate) {
            if (tileToUpdate === undefined) {
                return;
            }
            // Keep the tile from being removed from the cache.
            tileToUpdate.frameNumLastRequested = dataSource.mapView.frameNumber;
        }
        if (!dataSource.cacheable) {
            const resultTile = dataSource.getTile(tileKey);
            updateTile(resultTile);
            return resultTile;
        }
        const { tileCache } = this.getOrCreateCache(dataSource);
        const tileKeyMortonCode = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, offset);
        let tile = tileCache.get(tileKeyMortonCode);
        if (tile !== undefined && tile.offset === offset) {
            updateTile(tile);
            return tile;
        }
        tile = dataSource.getTile(tileKey);
        if (tile !== undefined) {
            tile.offset = offset;
            updateTile(tile);
            tileCache.set(tileKeyMortonCode, tile);
            this.m_tileGeometryManager.initTile(tile);
        }
        return tile;
    }
    /**
     * Removes all internal bookkeeping entries and cache related to specified datasource.
     *
     * Called by [[MapView]] when [[DataSource]] has been removed from [[MapView]].
     */
    removeDataSource(dataSourceName) {
        this.clearTileCache(dataSourceName);
        this.dataSourceTileList = this.dataSourceTileList.filter(tileList => tileList.dataSource.name !== dataSourceName);
        this.m_dataSourceCache.delete(dataSourceName);
    }
    /**
     * Clear the tile cache.
     *
     * Remove the [[Tile]] objects created by cacheable [[DataSource]]. If a [[DataSource]] name is
     * provided, this method restricts the eviction the [[DataSource]] with the given name.
     *
     * @param dataSourceName The name of the [[DataSource]].
     */
    clearTileCache(dataSourceName) {
        if (dataSourceName !== undefined) {
            const cache = this.m_dataSourceCache.get(dataSourceName);
            if (cache) {
                cache.tileCache.evictAll();
            }
        }
        else {
            this.m_dataSourceCache.forEach(dataSourceCache => {
                dataSourceCache.tileCache.evictAll();
            });
        }
    }
    /**
     * Visit each tile in visible, rendered, and cached sets.
     *
     *  * Visible and temporarily rendered tiles will be marked for update and retained.
     *  * Cached but not rendered/visible will be evicted.
     *
     * @param dataSource If passed, only the tiles from this [[DataSource]] instance are processed.
     *     If `undefined`, tiles from all [[DataSource]]s are processed.
     */
    markTilesDirty(dataSource) {
        if (dataSource === undefined) {
            this.dataSourceTileList.forEach(renderListEntry => {
                this.markDataSourceTilesDirty(renderListEntry);
            });
        }
        else {
            const renderListEntry = this.dataSourceTileList.find(e => e.dataSource === dataSource);
            if (renderListEntry === undefined) {
                return;
            }
            this.markDataSourceTilesDirty(renderListEntry);
        }
    }
    /**
     * Dispose tiles that are marked for removal by [[LRUCache]] algorithm.
     */
    disposePendingTiles() {
        this.m_dataSourceCache.forEach(cache => {
            cache.disposeTiles();
        });
    }
    forEachVisibleTile(fun) {
        for (const listEntry of this.dataSourceTileList) {
            listEntry.renderedTiles.forEach(fun);
        }
    }
    forEachCachedTile(fun, filterDataSource) {
        this.m_dataSourceCache.forEach(dataSourceCache => {
            if (filterDataSource === undefined || filterDataSource(dataSourceCache.dataSource)) {
                dataSourceCache.tileCache.forEach(tile => {
                    fun(tile);
                });
            }
        });
    }
    /**
     * Dispose a `Tile` from cache, 'dispose()' is also called on the tile to free its resources.
     */
    disposeTile(tile) {
        const cache = this.m_dataSourceCache.get(tile.dataSource.name);
        if (cache) {
            const tileCode = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tile.tileKey, tile.offset);
            cache.tileCache.delete(tileCode);
            tile.dispose();
        }
    }
    /**
     * Returns the target [[Projection]].
     */
    get projection() {
        return this.options.projection;
    }
    /**
     * Returns the type of the target [[Projection]].
     */
    get projectionType() {
        return this.projection.type;
    }
    /**
     * Returns true if the tile wrapping is enabled.
     *
     * The default implementation returns true for planar projections.
     */
    get tileWrappingEnabled() {
        return this.projectionType === harp_geoutils_1.ProjectionType.Planar;
    }
    getGeoBox(tilingScheme, childTileKey, offset) {
        const geoBox = tilingScheme.getGeoBox(childTileKey);
        const longitudeOffset = 360.0 * offset;
        geoBox.northEast.longitude += longitudeOffset;
        geoBox.southWest.longitude += longitudeOffset;
        return geoBox;
    }
    /**
     * Creates the intersection cache and initializes values for the root nodes.
     *
     * @param workList The list of work items with which to initialize the cache.
     */
    createIntersectionCache(workList) {
        const map = new Map();
        for (const item of workList) {
            map.set(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(item.tileKey, item.offset), Infinity);
        }
        return map;
    }
    /**
     * Create a list of root nodes to test against the frustum. The root nodes each start at level 0
     * and have an offset (see [[Tile]]) based on:
     * - the current position [[worldCenter]].
     * - the height of the camera above the world.
     * - the field of view of the camera (the maximum value between the horizontal / vertical
     *   values)
     * - the tilt of the camera (because we see more tiles when tilted).
     *
     * @param worldCenter The center of the camera in world space.
     */
    getRequiredInitialRootTileKeys(worldCenter) {
        const rootTileKey = harp_geoutils_1.TileKey.fromRowColumnLevel(0, 0, 0);
        if (!this.tileWrappingEnabled) {
            return [new TileKeyEntry(rootTileKey, 0)];
        }
        const worldGeoPoint = this.options.projection.unprojectPoint(worldCenter);
        const result = [];
        const startOffset = Math.round(worldGeoPoint.longitude / 360.0);
        // This algorithm computes the number of offsets we need to test. The following diagram may
        // help explain the algorithm below.
        //
        //   |🎥
        //   |.\ .
        //   | . \  .
        // z |  .  \   .c2
        //   |  c1.  \b    .
        //   |     .   \      .
        //___|a___d1.____\e______.d2______f
        //
        // Where:
        // - 🎥 is the camera
        // - z is the height of the camera above the ground.
        // - a is a right angle.
        // - b is the look at vector of the camera.
        // - c1 and c2 are the frustum planes of the camera.
        // - c1 to c2 is the fov.
        // - d1 and d2 are the intersection points of the frustum with the world plane.
        // - e is the tilt/pitch of the camera.
        // - f is the world
        //
        // The goal is to find the distance from e->d2. This is a longitude value, and we convert it
        // to some offset range. Note e->d2 >= e->d1 (because we can't have a negative tilt).
        // To find e->d2, we use the right triangle 🎥, a, d2 and subtract the distance a->d2 with
        // a->e.
        // a->d2 is found using the angle between a and d2 from the 🎥, this is simply e (because of
        // similar triangles, angle between a, 🎥 and e equals the tilt) + half of the fov (because
        // we need the angle between e, 🎥 and d2) and using trigonometry, result is therefore:
        // (tan(a->d2) * z).
        // a->e needs just the tilt and trigonometry to compute, result is: (tan(a->e) * z).
        const camera = this.m_camera;
        const cameraPitch = Utils_1.MapViewUtils.extractYawPitchRoll(camera.quaternion).pitch;
        // Ensure that the aspect is >= 1.
        const aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;
        // Angle between a->d2, note, the fov is vertical, hence we translate to horizontal.
        const totalAngleRad = harp_geoutils_1.MathUtils.degToRad((camera.fov * aspect) / 2) + cameraPitch;
        // Length a->d2
        const worldLengthHorizontalFull = Math.tan(totalAngleRad) * camera.position.z;
        // Length a->e
        const worldLengthHorizontalSmallerHalf = Math.tan(cameraPitch) * camera.position.z;
        // Length e -> d2
        const worldLengthHorizontal = worldLengthHorizontalFull - worldLengthHorizontalSmallerHalf;
        const worldLeftPoint = new THREE.Vector3(worldCenter.x - worldLengthHorizontal, worldCenter.y, worldCenter.z);
        const worldLeftGeoPoint = this.options.projection.unprojectPoint(worldLeftPoint);
        // We multiply by SQRT2 because we need to account for a rotated view (in which case there
        // are more tiles that can be seen).
        const offsetRange = harp_geoutils_1.MathUtils.clamp(Math.ceil(Math.abs((worldGeoPoint.longitude - worldLeftGeoPoint.longitude) / 360) * Math.SQRT2), 0, 
        // We can store currently up to 16 unique keys(2^4, where 4 is the default bit-shift
        // value which is used currently in the [[VisibleTileSet]] methods) hence we can have a
        // maximum range of 7 (because 2*7+1 = 15).
        7);
        for (let offset = -offsetRange + startOffset; offset <= offsetRange + startOffset; offset++) {
            result.push(new TileKeyEntry(rootTileKey, 0, offset));
        }
        return result;
    }
    /**
     * Search cache to replace visible but yet empty tiles with already loaded siblings in nearby
     * zoom levels.
     *
     * Useful, when zooming in/out and when "newly elected" tiles are not yet loaded. Prevents
     * flickering by rendering already loaded tiles from upper/higher zoom levels.
     */
    fillMissingTilesFromCache() {
        this.dataSourceTileList.forEach(renderListEntry => {
            const dataSource = renderListEntry.dataSource;
            const tilingScheme = dataSource.getTilingScheme();
            const displayZoomLevel = renderListEntry.zoomLevel;
            const renderedTiles = new Map();
            const checkedTiles = new Set();
            // Direction in quad tree to search: up -> shallower levels, down -> deeper levels.
            let SearchDirection;
            (function (SearchDirection) {
                SearchDirection[SearchDirection["UP"] = 0] = "UP";
                SearchDirection[SearchDirection["DOWN"] = 1] = "DOWN";
                SearchDirection[SearchDirection["BOTH"] = 2] = "BOTH";
            })(SearchDirection || (SearchDirection = {}));
            const tileCache = this.m_dataSourceCache.get(dataSource.name);
            if (tileCache === undefined) {
                return;
            }
            const cacheSearchUp = this.options.quadTreeSearchDistanceUp > 0 &&
                displayZoomLevel > dataSource.minZoomLevel;
            const cacheSearchDown = this.options.quadTreeSearchDistanceDown > 0 &&
                displayZoomLevel < dataSource.maxZoomLevel;
            if (!cacheSearchDown && !cacheSearchUp) {
                return;
            }
            const defaultSearchDirection = cacheSearchDown && cacheSearchUp
                ? SearchDirection.BOTH
                : cacheSearchDown
                    ? SearchDirection.DOWN
                    : SearchDirection.UP;
            let incompleteTiles = new Map();
            renderListEntry.visibleTiles.forEach(tile => {
                const tileCode = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tile.tileKey, tile.offset);
                if (tile.hasGeometry) {
                    renderedTiles.set(tileCode, tile);
                }
                else {
                    // if dataSource supports cache and it was existing before this render
                    // then enable searching for loaded tiles in cache
                    incompleteTiles.set(tileCode, defaultSearchDirection);
                }
            });
            if (incompleteTiles.size === 0) {
                // short circuit, nothing to be done
                return;
            }
            // iterate over incomplete (not loaded tiles)
            // and find their parents or children that are in cache that can be rendered temporarily
            // until tile is loaded
            while (incompleteTiles.size !== 0) {
                const nextLevelCandidates = new Map();
                incompleteTiles.forEach((searchDirection, tileKeyCode) => {
                    if (searchDirection === SearchDirection.BOTH ||
                        searchDirection === SearchDirection.UP) {
                        const parentCode = Utils_1.TileOffsetUtils.getParentKeyFromKey(tileKeyCode);
                        if (!checkedTiles.has(parentCode) && !renderedTiles.get(parentCode)) {
                            checkedTiles.add(parentCode);
                            const parentTile = tileCache.get(parentCode);
                            if (parentTile !== undefined && parentTile.hasGeometry) {
                                // parentTile has geometry, so can be reused as fallback
                                renderedTiles.set(parentCode, parentTile);
                                return;
                            }
                            const { mortonCode } = Utils_1.TileOffsetUtils.extractOffsetAndMortonKeyFromKey(parentCode);
                            const parentTileKey = parentTile
                                ? parentTile.tileKey
                                : harp_geoutils_1.TileKey.fromMortonCode(mortonCode);
                            // if parentTile is missing or incomplete, try at max 3 levels up from
                            // current display level
                            const nextLevelDiff = Math.abs(displayZoomLevel - parentTileKey.level);
                            if (nextLevelDiff < this.options.quadTreeSearchDistanceUp) {
                                nextLevelCandidates.set(parentCode, SearchDirection.UP);
                            }
                        }
                    }
                    if (searchDirection === SearchDirection.BOTH ||
                        searchDirection === SearchDirection.DOWN) {
                        const { offset, mortonCode } = Utils_1.TileOffsetUtils.extractOffsetAndMortonKeyFromKey(tileKeyCode);
                        const tileKey = harp_geoutils_1.TileKey.fromMortonCode(mortonCode);
                        tilingScheme.getSubTileKeys(tileKey).forEach(childTileKey => {
                            const childTileCode = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset);
                            checkedTiles.add(childTileCode);
                            const childTile = tileCache.get(childTileCode);
                            if (childTile !== undefined && childTile.hasGeometry) {
                                // childTile has geometry, so can be reused as fallback
                                renderedTiles.set(childTileCode, childTile);
                                return;
                            }
                            const nextLevelDiff = Math.abs(childTileKey.level - displayZoomLevel);
                            if (nextLevelDiff < this.options.quadTreeSearchDistanceDown) {
                                nextLevelCandidates.set(childTileCode, SearchDirection.DOWN);
                            }
                        });
                    }
                });
                incompleteTiles = nextLevelCandidates;
            }
            renderListEntry.renderedTiles = Array.from(renderedTiles.values());
        });
    }
    getOrCreateCache(dataSource) {
        const dataSourceName = dataSource.name;
        let dataSourceCache = this.m_dataSourceCache.get(dataSourceName);
        if (dataSourceCache === undefined) {
            dataSourceCache = new DataSourceCache(this.options, dataSource);
            this.m_dataSourceCache.set(dataSourceName, dataSourceCache);
        }
        return dataSourceCache;
    }
    markDataSourceTilesDirty(renderListEntry) {
        const dataSourceCache = this.m_dataSourceCache.get(renderListEntry.dataSource.name);
        const retainedTiles = new Set();
        renderListEntry.visibleTiles.forEach(tile => {
            const tileCode = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tile.tileKey, tile.offset);
            retainedTiles.add(tileCode);
            tile.reload();
        });
        renderListEntry.renderedTiles.forEach(tile => {
            const tileCode = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tile.tileKey, tile.offset);
            if (!retainedTiles.has(tileCode)) {
                retainedTiles.add(tileCode);
                tile.reload();
            }
        });
        if (dataSourceCache !== undefined) {
            dataSourceCache.tileCache.forEach((tile, tileCode) => {
                if (!retainedTiles.has(tileCode)) {
                    tile.dispose();
                    dataSourceCache.tileCache.delete(tileCode);
                }
            });
        }
    }
    // Computes the visible tiles for each supplied datasource.
    getVisibleTilesForDataSources(worldCenter, zoomLevel, dataSources, elevationRangeSource) {
        const tiles = [];
        let allBoundingBoxesFinal = true;
        for (const dataSource of dataSources) {
            const displayZoomLevel = dataSource.getDisplayZoomLevel(zoomLevel);
            const tilingScheme = dataSource.getTilingScheme();
            const useElevationRangeSource = elevationRangeSource !== undefined &&
                elevationRangeSource.getTilingScheme() === tilingScheme;
            const tileBounds = new THREE.Box3();
            const workList = this.getRequiredInitialRootTileKeys(worldCenter);
            const visibleTiles = [];
            const tileFrustumIntersectionCache = this.createIntersectionCache(workList);
            while (workList.length > 0) {
                const tileEntry = workList.pop();
                if (tileEntry === undefined) {
                    continue;
                }
                const tileKey = tileEntry.tileKey;
                const uniqueKey = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, tileEntry.offset);
                const area = tileFrustumIntersectionCache.get(uniqueKey);
                if (area === undefined) {
                    throw new Error("Unexpected tile key");
                }
                if (area <= 0 || tileKey.level > displayZoomLevel) {
                    continue;
                }
                if (dataSource.shouldRender(displayZoomLevel, tileKey)) {
                    visibleTiles.push(tileEntry);
                }
                tilingScheme.getSubTileKeys(tileKey).forEach(childTileKey => {
                    const offset = tileEntry.offset;
                    const tileKeyAndOffset = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset);
                    const intersectsFrustum = tileFrustumIntersectionCache.get(tileKeyAndOffset);
                    if (intersectsFrustum !== undefined) {
                        return;
                    }
                    const geoBox = this.getGeoBox(tilingScheme, childTileKey, offset);
                    if (useElevationRangeSource) {
                        const range = elevationRangeSource.getElevationRange(childTileKey);
                        geoBox.southWest.altitude = range.minElevation;
                        geoBox.northEast.altitude = range.maxElevation;
                        allBoundingBoxesFinal =
                            allBoundingBoxesFinal &&
                                range.calculationStatus === ElevationRangeSource_1.CalculationStatus.FinalPrecise;
                    }
                    let subTileArea = 0;
                    if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
                        const obb = new harp_geometry_1.OrientedBox3();
                        this.options.projection.projectBox(geoBox, obb);
                        if (obb.intersects(this.m_frustum)) {
                            subTileArea = 1;
                        }
                    }
                    else {
                        this.options.projection.projectBox(geoBox, tileBounds);
                        subTileArea = this.computeSubTileArea(tileBounds);
                    }
                    tileFrustumIntersectionCache.set(tileKeyAndOffset, subTileArea);
                    if (subTileArea > 0) {
                        workList.push(new TileKeyEntry(childTileKey, subTileArea, offset));
                    }
                });
            }
            tiles.push({ dataSource, visibleTiles });
        }
        return { tiles, allBoundingBoxesFinal };
    }
    // Computes the rough screen area of the supplied box.
    // TileBounds must be in world space.
    computeSubTileArea(tileBounds) {
        if ((!this.options.extendedFrustumCulling ||
            this.m_mapTileCuller.frustumIntersectsTileBox(tileBounds)) &&
            this.m_frustum.intersectsBox(tileBounds)) {
            const contour = [
                new THREE.Vector3(tileBounds.min.x, tileBounds.min.y, 0).applyMatrix4(this.m_viewProjectionMatrix),
                new THREE.Vector3(tileBounds.max.x, tileBounds.min.y, 0).applyMatrix4(this.m_viewProjectionMatrix),
                new THREE.Vector3(tileBounds.max.x, tileBounds.max.y, 0).applyMatrix4(this.m_viewProjectionMatrix),
                new THREE.Vector3(tileBounds.min.x, tileBounds.max.y, 0).applyMatrix4(this.m_viewProjectionMatrix)
            ];
            contour.push(contour[0]);
            const n = contour.length;
            let subTileArea = 0;
            for (let p = n - 1, q = 0; q < n; p = q++) {
                subTileArea += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
            }
            return Math.abs(subTileArea * 0.5);
        }
        return 0;
    }
}
exports.VisibleTileSet = VisibleTileSet;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
/**
 * Identifier of next decoder worker-service. Used to ensure uniqueness of service ids of decoders
 * dedicated to different datasources.
 */
let nextUniqueServiceId = 0;
/**
 * Decoder based on [[ConcurrentWorkerSet]].
 *
 * Decodes tiles using workers running in separate contexts (also known as `WebWorkers`):
 * - connection establishment,
 * - sends decode requests,
 * - configuration.
 */
class WorkerBasedDecoder {
    /**
     * Creates a new `WorkerBasedDecoder`.
     *
     * @param workerSet [[ConcurrentWorkerSet]] this tiler will live in.
     * @param decoderServiceType Service type identifier.
     */
    constructor(workerSet, decoderServiceType) {
        this.workerSet = workerSet;
        this.decoderServiceType = decoderServiceType;
        this.m_serviceCreated = false;
        this.workerSet.addReference();
        this.serviceId = `${this.decoderServiceType}-${nextUniqueServiceId++}`;
    }
    /**
     * Dispose of dedicated tile decoder services in workers and remove reference to underlying
     * [[ConcurrentWorkerSet]].
     */
    dispose() {
        if (this.m_serviceCreated) {
            this.workerSet.broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.DestroyService,
                targetServiceId: this.serviceId
            });
        }
        this.workerSet.removeReference();
    }
    /**
     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates
     * dedicated [[TileDecoderService]]s in all workers to serve decode requests.
     */
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.workerSet.connect(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);
            if (!this.m_serviceCreated) {
                yield this.workerSet.broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                    type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.CreateService,
                    targetServiceType: this.decoderServiceType,
                    targetServiceId: this.serviceId
                });
                this.m_serviceCreated = true;
            }
        });
    }
    /**
     * Get [[Tile]] from tile decoder service in worker.
     *
     * Invokes [[DecodeTileRequest]] on [[TileDecoderService]] running in worker pool.
     */
    decodeTile(data, tileKey, projection, requestController) {
        const tileKeyCode = tileKey.mortonCode();
        const message = {
            type: harp_datasource_protocol_1.WorkerDecoderProtocol.Requests.DecodeTileRequest,
            tileKey: tileKeyCode,
            data,
            projection: harp_datasource_protocol_1.getProjectionName(projection)
        };
        const transferList = data instanceof ArrayBuffer ? [data] : undefined;
        return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);
    }
    /**
     * Get [[TileInfo]] from tile decoder service in worker.
     *
     * Invokes [[TileInfoRequest]] on [[TileDecoderService]] running in worker pool.
     */
    getTileInfo(data, tileKey, projection, requestController) {
        const tileKeyCode = tileKey.mortonCode();
        const message = {
            type: harp_datasource_protocol_1.WorkerDecoderProtocol.Requests.TileInfoRequest,
            tileKey: tileKeyCode,
            data,
            projection: harp_datasource_protocol_1.getProjectionName(projection)
        };
        const transferList = data instanceof ArrayBuffer ? [data] : undefined;
        return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);
    }
    /**
     * Configure tile decoder service in workers.
     *
     * Broadcasts [[ConfigurationMessage]] to all [[TileDecoderService]]s running in worker pool.
     *
     * @param styleSet  new [[StyleSet]], undefined means no change
     * @param languages new list of languages
     * @param options   new options, undefined options are not changed
     */
    configure(styleSet, languages, options) {
        const message = {
            service: this.serviceId,
            type: harp_datasource_protocol_1.WorkerDecoderProtocol.DecoderMessageName.Configuration,
            styleSet,
            options,
            languages
        };
        this.workerSet.broadcastMessage(message);
    }
}
exports.WorkerBasedDecoder = WorkerBasedDecoder;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
/**
 * Identifier of next tiler worker-service. Used to ensure uniqueness of service ids of tilers
 * dedicated to different datasources.
 */
let nextUniqueServiceId = 0;
/**
 * Tiler based on [[ConcurrentWorkerSet]].
 *
 * Tiles payloads using workers running in separate contexts (also known as `WebWorkers`):
 * - connection establishment,
 * - sends tile requests,
 * - configuration.
 */
class WorkerBasedTiler {
    /**
     * Creates a new `WorkerBasedTiler`.
     *
     * @param workerSet [[ConcurrentWorkerSet]] this tiler will live in.
     * @param tilerServiceType Service type identifier.
     */
    constructor(workerSet, tilerServiceType) {
        this.workerSet = workerSet;
        this.tilerServiceType = tilerServiceType;
        this.m_serviceCreated = false;
        this.workerSet.addReference();
        this.serviceId = `${this.tilerServiceType}-${nextUniqueServiceId++}`;
    }
    /**
     * Dispose of dedicated tiler services in workers and remove reference to underlying
     * [[ConcurrentWorkerSet]].
     */
    dispose() {
        if (this.m_serviceCreated) {
            this.workerSet.broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.DestroyService,
                targetServiceId: this.serviceId
            });
        }
        this.workerSet.removeReference();
    }
    /**
     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates
     * dedicated [[TilerService]]s in all workers to serve tiling requests.
     */
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.workerSet.connect(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);
            if (!this.m_serviceCreated) {
                yield this.workerSet.broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                    type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.CreateService,
                    targetServiceType: this.tilerServiceType,
                    targetServiceId: this.serviceId
                });
                this.m_serviceCreated = true;
            }
        });
    }
    /**
     * Register index in the tiler. Indexes registered in the tiler can be later used to retrieved
     * tiled payloads using `getTile`.
     *
     * @param indexId Index identifier.
     * @param input Url to the index payload, or direct GeoJSON.
     */
    registerIndex(indexId, input) {
        const message = {
            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.RegisterIndex,
            id: indexId,
            input: input instanceof URL ? input.href : input
        };
        return this.workerSet.invokeRequest(this.serviceId, message);
    }
    /**
     * Update index in the tiler. Indexes registered in the tiler can be later used to retrieved
     * tiled payloads using `getTile`.
     *
     * @param indexId Index identifier.
     * @param input Url to the index payload, or direct GeoJSON.
     */
    updateIndex(indexId, input) {
        const message = {
            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.UpdateIndex,
            id: indexId,
            input: input instanceof URL ? input.href : input
        };
        return this.workerSet.invokeRequest(this.serviceId, message);
    }
    /**
     * Retrieves a tile for a previously registered index.
     *
     * @param indexId Index identifier.
     * @param tileKey The [[TileKey]] that identifies the tile.
     */
    getTile(indexId, tileKey) {
        const tileKeyCode = tileKey.mortonCode();
        const message = {
            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.TileRequest,
            index: indexId,
            tileKey: tileKeyCode
        };
        return this.workerSet.invokeRequest(this.serviceId, message);
    }
}
exports.WorkerBasedTiler = WorkerBasedTiler;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/LowResRenderPass.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/LowResRenderPass.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const Pass_1 = __webpack_require__(/*! ./Pass */ "./node_modules/@here/harp-mapview/lib/composing/Pass.js");
/**
 * The `LowResRenderPass` renders the scene at a lower resolution into an internal
 * `WebGLRenderTarget`, and then copies the result into the frame buffer. The size of the internal
 * buffer is determined by the current frame buffer size multiplied by `pixelRatio`.
 *
 * @note Since no anti-aliasing is applied during dynamic rendering, visual artifacts may be
 * visible.
 */
class LowResRenderPass extends Pass_1.Pass {
    /**
     * The constructor for `LowResRenderPass`. It builds an internal scene with a camera looking at
     * a quad.
     *
     * @param lowResPixelRatio The `pixelRatio` determines the resolution of the internal
     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give
     * good results. A value of `undefined` disables the low res render pass. The value should not
     * be larger than`window.devicePixelRatio`.
     */
    constructor(lowResPixelRatio) {
        super();
        this.lowResPixelRatio = lowResPixelRatio;
        this.m_renderTarget = null;
        this.m_localCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.m_quadScene = new THREE.Scene();
        this.m_quadUniforms = harp_materials_1.CopyShader.uniforms;
        this.m_quadMaterial = new harp_materials_1.CopyMaterial(this.m_quadUniforms);
        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.m_quadMaterial);
        this.m_savedWidth = 0;
        this.m_savedHeight = 0;
        this.m_quad.frustumCulled = false;
        this.m_quadScene.add(this.m_quad);
        this.m_pixelRatio = lowResPixelRatio;
    }
    /**
     * Releases all used resources.
     */
    dispose() {
        this.m_quadMaterial.dispose();
        this.m_quad.geometry.dispose();
        if (this.m_renderTarget !== null) {
            this.m_renderTarget.dispose();
            this.m_renderTarget = null;
        }
    }
    /**
     * If a value is specified, a low resolution render pass is used to render the scene into a
     * low resolution render target, before it is copied to the screen.
     *
     * A value of `undefined` disables the low res render pass. The value should not be larger than
     * `window.devicePixelRatio`.
     *
     * @default `undefined`
     */
    set pixelRatio(ratio) {
        this.m_pixelRatio = ratio;
        if (this.m_renderTarget && this.pixelRatio !== undefined) {
            this.m_renderTarget.setSize(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio));
        }
    }
    get pixelRatio() {
        return this.m_pixelRatio;
    }
    /**
     * The render function of `LowResRenderPass`. It renders the whole scene into an internal
     * `WebGLRenderTarget` instance with a lower resolution, using the passed in `WebGLRenderer`.
     * The low resolution image is then copied to the `writeBuffer`, which is `undefined` in case it
     * is the screen.
     *
     * @param renderer The ThreeJS WebGLRenderer instance to render the scene with.
     * @param scene The ThreeJS Scene instance to render the scene with.
     * @param camera The ThreeJS Camera instance to render the scene with.
     * @param writeBuffer A ThreeJS WebGLRenderTarget instance to render the scene to.
     * @param readBuffer A ThreeJS WebGLRenderTarget instance to render the scene.
     */
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        if (!this.enabled || this.pixelRatio === undefined) {
            return;
        }
        // Initiates the local render target with the read buffer's dimensions, if not available.
        if (this.m_renderTarget === null) {
            this.m_savedWidth = readBuffer.width;
            this.m_savedHeight = readBuffer.height;
            this.m_renderTarget = new THREE.WebGLRenderTarget(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio), {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                depthBuffer: true,
                stencilBuffer: true
            });
            this.m_renderTarget.texture.name = "LowResRenderPass.sample";
        }
        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;
        this.m_quadUniforms.opacity.value = 1.0;
        const oldRenderTarget = renderer.getRenderTarget();
        renderer.setRenderTarget(this.m_renderTarget);
        renderer.clear();
        // Render into the low resolution internal render target.
        renderer.render(scene, camera);
        // Render the low resolution target into the screen.
        // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`
        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
        renderer.clear();
        renderer.render(this.m_quadScene, this.m_localCamera);
        renderer.setRenderTarget(oldRenderTarget);
    }
    /**
     * Resize the internal render target to match the new size specified. The size of internal
     * buffer depends on the `pixelRatio`.
     *
     * @param width New width to apply to the render target.
     * @param height New height to apply to the render target.
     */
    setSize(width, height) {
        this.m_savedWidth = width;
        this.m_savedHeight = height;
        if (this.m_renderTarget && this.pixelRatio !== undefined) {
            this.m_renderTarget.setSize(Math.floor(width * this.pixelRatio), Math.floor(height * this.pixelRatio));
        }
    }
}
exports.LowResRenderPass = LowResRenderPass;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const Pass_1 = __webpack_require__(/*! ./Pass */ "./node_modules/@here/harp-mapview/lib/composing/Pass.js");
/**
 * This enum represents the sampling level to apply to a [[MSAARenderPass]] instance. At level 0,
 * only one sample is performed, which is like disabling the MSAA pass.
 */
var MSAASampling;
(function (MSAASampling) {
    MSAASampling[MSAASampling["Level_0"] = 0] = "Level_0";
    MSAASampling[MSAASampling["Level_1"] = 1] = "Level_1";
    MSAASampling[MSAASampling["Level_2"] = 2] = "Level_2";
    MSAASampling[MSAASampling["Level_3"] = 3] = "Level_3";
    MSAASampling[MSAASampling["Level_4"] = 4] = "Level_4";
    MSAASampling[MSAASampling["Level_5"] = 5] = "Level_5";
})(MSAASampling = exports.MSAASampling || (exports.MSAASampling = {}));
/**
 * [[MapView]]'s MSAA implementation. MSAA stands for Multi Sampling Anti-Aliasing, and its concept
 * is to provide a rendering engine with additional color values for each pixel, so they can include
 * the missing bits between them on a screen. WebGL already comes with a native MSAA implementation
 * with four samples. Because of its native nature, it is more efficient and one may not want to use
 * MapView's MSAA implementation when these four samples are satisfying. However in some situations
 * they are not: on low devices, MSAA can impact the framerate and we may desire to reduce the
 * number of samples at runtime. On the other hand, when the interaction stops, the engine also
 * stops rendering the map, and because a map relies on many line-like patterns, aliasing can then
 * turn very noticeable. In such static renders, the number of samples could be dramatically
 * increased on a last frame to render.
 */
class MSAARenderPass extends Pass_1.Pass {
    /**
     * The constructor for `MSAARenderPass`. It builds an internal scene with a camera looking at a
     * quad.
     *
     * @param m_scene The scene to render.
     * @param m_camera The camera to render the scene through.
     */
    constructor() {
        super();
        /**
         * The sampling level determines the number of samples that will be performed per frame.
         * Renders will happen `2 ^ samplingLevel` time(s). `samplingLevel` stands between `0` and `5`.
         * Therefore there can be between 1 and 32 samples.
         *
         * @default `SamplingLevel.Level_1`
         */
        this.samplingLevel = MSAASampling.Level_1;
        this.m_renderTarget = null;
        this.m_localCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.m_quadScene = new THREE.Scene();
        this.m_quadUniforms = harp_materials_1.CopyShader.uniforms;
        this.m_quadMaterial = new harp_materials_1.MSAAMaterial(this.m_quadUniforms);
        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.m_quadMaterial);
        this.m_quad.frustumCulled = false;
        this.m_quadScene.add(this.m_quad);
    }
    /**
     * Releases all used resources.
     */
    dispose() {
        if (this.m_renderTarget !== null) {
            this.m_renderTarget.dispose();
            this.m_renderTarget = null;
        }
    }
    /**
     * The render function of `MSAARenderPass`. At each call of this method, and for each sample,
     * the [[MapView]] camera provided in the `render` method is offset within the dimension of a
     * pixel on screen. It then renders the whole scene with this offset to a local
     * `WebGLRenderTarget` instance, via a `WebGLRenderer` instance. Finally the local camera
     * created in the constructor shoots the quad and renders to the write buffer or to the frame
     * buffer. The quad material's opacity is modified so the renders can accumulate in the
     * targetted buffer.
     *
     * The number of samples can be modified at runtime through the enum [[SamplingLevel]].
     *
     * If there is no further pass, the [[Pass.renderToScreen]] flag can be set to `true` to
     * output directly to the framebuffer.
     *
     * @param renderer The ThreeJS WebGLRenderer instance to render the scene with.
     * @param scene The ThreeJS Scene instance to render the scene with.
     * @param camera The ThreeJS Camera instance to render the scene with.
     * @param writeBuffer A ThreeJS WebGLRenderTarget instance to render the scene to.
     * @param readBuffer A ThreeJS WebGLRenderTarget instance to render the scene.
     */
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        if (!this.enabled) {
            return;
        }
        // Initiates the local render target with the read buffer's dimensions, if not available.
        if (this.m_renderTarget === null) {
            this.m_renderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            });
            this.m_renderTarget.texture.name = "MSAARenderPass.sample";
        }
        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;
        const offsets = MSAARenderPass.OffsetVectors[this.samplingLevel];
        const rendererClearColor = renderer.getClearColor();
        const oldClearColor = rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;
        // The method `camera.setViewOffset` will be called in the next loop. In order to maintain
        // its usability externally (like for the triple view in mosaic demo) we must cache the
        // previous values stored in `camera.view` and re-assign them at the end of the pass.
        // 1. Create a default cache object, with default dimensions the size of our read buffer.
        const oldView = {
            enabled: camera.view !== null && camera.view.enabled,
            fullWidth: readBuffer.width,
            fullHeight: readBuffer.height,
            x: 0,
            y: 0,
            width: readBuffer.width,
            height: readBuffer.height
        };
        // 2. If `camera.view` has been enabled previously, then `setViewOffset` has been called
        // externally: copy the existing `camera.view` values in the cache. Override the cache
        // object with the values provided externally.
        if (oldView.enabled && camera.view !== null) {
            oldView.fullWidth = camera.view.fullWidth;
            oldView.fullHeight = camera.view.fullHeight;
            oldView.x = camera.view.offsetX;
            oldView.y = camera.view.offsetY;
            oldView.width = camera.view.width;
            oldView.height = camera.view.height;
        }
        const oldRenderTarget = renderer.getRenderTarget();
        for (let i = 0; i < offsets.length; i++) {
            // 4. Then for each sample, call `setViewOffset` with our object. This also updates the
            // `camera.view` object in Three.js.
            const offset = offsets[i];
            camera.setViewOffset(oldView.fullWidth, oldView.fullHeight, oldView.x + offset[0] / 16, oldView.y + offset[1] / 16, oldView.width, oldView.height);
            // 5. Divide the opacity of the quad by the number of samples to accumulate on the
            // target buffer, and reduce the impact of the offset on color to reduce banding. Then
            // render.
            const uniformCenteredDistribution = -0.5 + (i + 0.5) / offsets.length;
            const sampleWeight = 1.0 / offsets.length + uniformCenteredDistribution / 32;
            this.m_quadUniforms.opacity.value = sampleWeight;
            renderer.setRenderTarget(this.m_renderTarget);
            renderer.clear();
            renderer.render(scene, camera);
            // 6. Render the quad on top of the previous renders.
            // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`
            renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
            if (i === 0) {
                renderer.setClearColor(0x000000);
                renderer.clear();
            }
            renderer.render(this.m_quadScene, this.m_localCamera);
            if (i === 0 && rendererClearColor !== undefined) {
                renderer.setClearColor(oldClearColor);
            }
        }
        renderer.setRenderTarget(oldRenderTarget);
        // 7. Restore `camera.view` as set externally (or not).
        if (camera.view !== null) {
            camera.view.enabled = oldView.enabled;
            camera.view.offsetX = oldView.x;
            camera.view.offsetY = oldView.y;
        }
    }
    /**
     * Resize the internal render target to match the new size specified.
     *
     * @param width New width to apply to the render target.
     * @param height New height to apply to the render target.
     */
    setSize(width, height) {
        if (this.m_renderTarget) {
            this.m_renderTarget.setSize(width, height);
        }
    }
}
// tslint:disable:max-line-length
/**
 * The list of offsets to apply to the camera, per sampling level, adapted from :
 *
 * @see https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
 */
// tslint:enable:max-line-length
// tslint:disable-next-line:member-ordering
MSAARenderPass.OffsetVectors = [
    [[0, 0]],
    [[4, 4], [-4, -4]],
    [[-2, -6], [6, -2], [-6, 2], [2, 6]],
    [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]],
    [
        [1, 1],
        [-1, -3],
        [-3, 2],
        [4, -1],
        [-5, -2],
        [2, 5],
        [5, 3],
        [3, -5],
        [-2, 6],
        [0, -7],
        [-4, -6],
        [-6, 4],
        [-8, 0],
        [7, -4],
        [6, 7],
        [-7, -8]
    ],
    [
        [-4, -7],
        [-7, -5],
        [-3, -5],
        [-5, -4],
        [-1, -4],
        [-2, -2],
        [-6, -1],
        [-4, 0],
        [-7, 1],
        [-1, 2],
        [-6, 3],
        [-3, 3],
        [-7, 6],
        [-3, 6],
        [-5, 7],
        [-1, 7],
        [5, -7],
        [1, -6],
        [6, -5],
        [4, -4],
        [2, -3],
        [7, -2],
        [1, -1],
        [4, -1],
        [2, 1],
        [6, 2],
        [0, 4],
        [4, 4],
        [2, 5],
        [7, 5],
        [5, 6],
        [3, 7]
    ]
];
exports.MSAARenderPass = MSAARenderPass;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/MapRenderingManager.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/MapRenderingManager.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const LowResRenderPass_1 = __webpack_require__(/*! ./LowResRenderPass */ "./node_modules/@here/harp-mapview/lib/composing/LowResRenderPass.js");
const MSAARenderPass_1 = __webpack_require__(/*! ./MSAARenderPass */ "./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js");
const Outline_1 = __webpack_require__(/*! ./Outline */ "./node_modules/@here/harp-mapview/lib/composing/Outline.js");
const Pass_1 = __webpack_require__(/*! ./Pass */ "./node_modules/@here/harp-mapview/lib/composing/Pass.js");
const UnrealBloomPass_1 = __webpack_require__(/*! ./UnrealBloomPass */ "./node_modules/@here/harp-mapview/lib/composing/UnrealBloomPass.js");
const DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL = MSAARenderPass_1.MSAASampling.Level_1;
const DEFAULT_STATIC_MSAA_SAMPLING_LEVEL = MSAARenderPass_1.MSAASampling.Level_4;
/**
 * The implementation of [[IMapRenderingManager]] to instantiate in [[MapView]] and manage the map
 * rendering.
 */
class MapRenderingManager {
    /**
     * The constructor of `MapRenderingManager`.
     *
     * @param width Width of the frame buffer.
     * @param height Height of the frame buffer.
     * @param lowResPixelRatio The `pixelRatio` determines the resolution of the internal
     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give
     * good results. A value of `undefined` disables the low res render pass. The value should not
     * be larger than`window.devicePixelRatio`.
     * @param antialiasSetting The object defining the demeanor of MSAA.
     */
    constructor(width, height, lowResPixelRatio, antialiasSettings = { msaaEnabled: false }) {
        this.bloom = {
            enabled: false,
            strength: 1.5,
            radius: 0.4,
            threshold: 0.85
        };
        this.outline = {
            enabled: false,
            thickness: 0.005,
            color: "#000000",
            ghostExtrudedPolygons: false,
            needsUpdate: false
        };
        this.vignette = {
            enabled: false,
            offset: 1.0,
            darkness: 1.0
        };
        this.sepia = {
            enabled: false,
            amount: 0.5
        };
        this.m_width = 1;
        this.m_height = 1;
        this.m_renderPass = new Pass_1.RenderPass();
        this.m_target1 = new THREE.WebGLRenderTarget(1, 1);
        this.m_target2 = new THREE.WebGLRenderTarget(1, 1);
        this.m_sepiaPass = new Pass_1.ShaderPass(harp_materials_1.SepiaShader);
        this.m_vignettePass = new Pass_1.ShaderPass(harp_materials_1.VignetteShader);
        this.m_readBuffer = new THREE.WebGLRenderTarget(width, height);
        this.m_msaaPass = new MSAARenderPass_1.MSAARenderPass();
        this.m_msaaPass.enabled =
            antialiasSettings !== undefined ? antialiasSettings.msaaEnabled === true : false;
        this.m_dynamicMsaaSamplingLevel =
            antialiasSettings.dynamicMsaaSamplingLevel === undefined
                ? DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL
                : antialiasSettings.dynamicMsaaSamplingLevel;
        this.m_staticMsaaSamplingLevel =
            antialiasSettings.staticMsaaSamplingLevel === undefined
                ? DEFAULT_STATIC_MSAA_SAMPLING_LEVEL
                : antialiasSettings.staticMsaaSamplingLevel;
        this.m_lowResPass = new LowResRenderPass_1.LowResRenderPass(lowResPixelRatio);
        this.m_lowResPass.enabled = lowResPixelRatio !== undefined;
    }
    updateOutline(options) {
        this.outline.color = options.color;
        this.outline.thickness = options.thickness;
        this.outline.ghostExtrudedPolygons = options.ghostExtrudedPolygons;
        this.outline.needsUpdate = true;
    }
    /**
     * The method to call to render the map with the `MapRenderingManager` instance. It contains the
     * chain of sub-passes that can transfer the write and read buffers, and other sheer rendering
     * conditions as disabling AA when a high DPI device is in use.
     *
     * @param renderer The ThreeJS WebGLRenderer instance to render the map with.
     * @param scene The ThreeJS Scene instance containing the map objects to render.
     * @param camera The ThreeJS Camera instance to render the scene through.
     * @param isStaticFrame Whether the frame to render is static or dynamic. Selects level of
     * antialiasing.
     */
    render(renderer, scene, camera, isStaticFrame) {
        const target = null;
        if (!isStaticFrame && this.m_lowResPass.pixelRatio !== undefined) {
            // Not designed to be combined with our own MSAA
            this.m_lowResPass.renderToScreen = true;
            this.m_lowResPass.render(renderer, scene, camera, target, this.m_readBuffer);
            return;
        }
        const usePostEffects = this.bloom.enabled ||
            this.outline.enabled ||
            this.vignette.enabled ||
            this.sepia.enabled;
        let activeTarget = null;
        // 1. If the bloom is enabled, clear the depth.
        if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {
            renderer.setRenderTarget(this.m_target1);
            renderer.clearDepth();
        }
        // 2. Render the map.
        if (this.m_msaaPass.enabled) {
            // Use a higher MSAA sampling level for static rendering.
            this.m_msaaPass.samplingLevel = isStaticFrame
                ? this.m_staticMsaaSamplingLevel
                : this.m_dynamicMsaaSamplingLevel;
            // MSAA is the only effect for the moment.
            this.m_msaaPass.renderToScreen = !usePostEffects;
            // Render to the specified target with the MSAA pass.
            this.m_msaaPass.render(renderer, scene, camera, target, this.m_readBuffer);
        }
        else {
            if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {
                activeTarget = this.m_target1;
                this.m_renderPass.render(renderer, scene, camera, this.m_target1, null);
            }
            else if (!this.outline.enabled || (this.outline.enabled && !this.bloom.enabled)) {
                renderer.render(scene, camera);
            }
        }
        // 3. Apply effects
        if (this.outline.enabled) {
            if (this.m_outlineEffect === undefined) {
                this.m_outlineEffect = new Outline_1.OutlineEffect(renderer);
            }
            if (this.outline.needsUpdate) {
                this.m_outlineEffect.color = this.outline.color;
                this.m_outlineEffect.thickness = this.outline.thickness;
                this.m_outlineEffect.ghostExtrudedPolygons = this.outline.ghostExtrudedPolygons;
                this.outline.needsUpdate = false;
            }
            const nextEffectEnabled = this.bloom.enabled || this.vignette.enabled || this.sepia.enabled;
            if (nextEffectEnabled) {
                activeTarget = this.m_target1;
            }
            renderer.setRenderTarget(nextEffectEnabled ? activeTarget : null);
            this.m_outlineEffect.render(scene, camera);
        }
        if (this.bloom.enabled) {
            if (this.m_bloomPass === undefined) {
                this.m_bloomPass = new UnrealBloomPass_1.BloomPass(new THREE.Vector2(this.m_width, this.m_height), this.bloom.strength, this.bloom.radius, this.bloom.threshold);
            }
            const nextEffectEnabled = this.vignette.enabled || this.sepia.enabled;
            this.m_bloomPass.renderToScreen = !nextEffectEnabled;
            this.m_bloomPass.radius = this.bloom.radius;
            this.m_bloomPass.strength = this.bloom.strength;
            this.m_bloomPass.threshold = this.bloom.threshold;
            this.m_bloomPass.render(renderer, scene, camera, null, activeTarget);
        }
        else if (this.m_bloomPass !== undefined) {
            this.m_bloomPass.dispose();
            this.m_bloomPass = undefined;
        }
        if (this.vignette.enabled) {
            const oldTarget = activeTarget;
            const nextEffectEnabled = this.sepia.enabled;
            this.m_vignettePass.uniforms.offset.value = this.vignette.offset;
            this.m_vignettePass.uniforms.darkness.value = this.vignette.darkness;
            this.m_vignettePass.renderToScreen = !nextEffectEnabled;
            if (nextEffectEnabled) {
                activeTarget = activeTarget === this.m_target1 ? this.m_target2 : this.m_target1;
            }
            this.m_vignettePass.render(renderer, scene, camera, activeTarget, oldTarget);
        }
        if (this.sepia.enabled) {
            this.m_sepiaPass.renderToScreen = true;
            this.m_sepiaPass.uniforms.amount.value = this.sepia.amount;
            this.m_sepiaPass.render(renderer, scene, camera, null, activeTarget);
        }
    }
    /**
     * The resize function to call on resize events to resize the render targets. It shall include
     * the resize methods of all the sub-passes used in `MapRenderingManager`.
     *
     * @param width New width to use.
     * @param height New height to use.
     */
    setSize(width, height) {
        this.m_readBuffer.setSize(width, height);
        this.m_msaaPass.setSize(width, height);
        if (this.m_bloomPass !== undefined) {
            this.m_bloomPass.setSize(width, height);
        }
        this.m_lowResPass.setSize(width, height);
        this.m_target1.setSize(width, height);
        this.m_target2.setSize(width, height);
        this.m_width = width;
        this.m_height = height;
    }
    /**
     * The `lowResPixelRatio` determines the resolution of the internal `WebGLRenderTarget`. Values
     * between 0.5 and `window.devicePixelRatio` can be tried to give  good results. A value of
     * `undefined` disables the low res render pass. The value should not be larger than
     * `window.devicePixelRatio`.
     */
    get lowResPixelRatio() {
        return this.m_lowResPass.pixelRatio;
    }
    set lowResPixelRatio(pixelRatio) {
        this.m_lowResPass.pixelRatio = pixelRatio;
        this.m_lowResPass.enabled = pixelRatio !== undefined;
    }
    /**
     * Set the level of sampling while the user interacts.
     *
     * @param samplingLevel The sampling level.
     */
    set dynamicMsaaSamplingLevel(samplingLevel) {
        this.m_dynamicMsaaSamplingLevel = samplingLevel;
    }
    /**
     * Return the sampling level defined during continuous rendering.
     */
    get dynamicMsaaSamplingLevel() {
        return this.m_dynamicMsaaSamplingLevel;
    }
    /**
     * Enable or disable the MSAA. If disabled, `MapRenderingManager` will use the renderer provided
     * in the [[MapRenderingManager.render]] method to render the scene.
     *
     * @param value If `true`, MSAA is enabled, disabled otherwise.
     */
    set msaaEnabled(value) {
        this.m_msaaPass.enabled = value;
    }
    /**
     * Return whether the MSAA is enabled.
     */
    get msaaEnabled() {
        return this.m_msaaPass.enabled;
    }
    /**
     * Set the sampling level for rendering static frames.
     *
     * @param samplingLevel The sampling level.
     */
    set staticMsaaSamplingLevel(samplingLevel) {
        this.m_staticMsaaSamplingLevel = samplingLevel;
    }
    /**
     * Return the sampling level defined for rendering static frames.
     */
    get staticMsaaSamplingLevel() {
        return this.m_staticMsaaSamplingLevel;
    }
}
exports.MapRenderingManager = MapRenderingManager;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/Outline.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/Outline.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const vertexShaderChunk = `
    uniform float outlineThickness;

    vec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {

        float thickness = outlineThickness;
        const float ratio = 1.0;
        vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );
        vec4 norm = normalize( pos - pos2 );
        return pos + norm * thickness * pos.w * ratio;

    }`;
const vertexShaderChunk2 = `
    #if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( PHYSICAL )
        #ifndef USE_ENVMAP
            vec3 objectNormal = normalize( normal );
        #endif
    #endif

    #ifdef FLIP_SIDED
        objectNormal = -objectNormal;
    #endif

    #ifdef DECLARE_TRANSFORMED
        vec3 transformed = vec3( position );
    #endif

    gl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );

    #include <fog_vertex>`;
const fragmentShader = `
    #include <common>
    #include <fog_pars_fragment>

    uniform vec3 outlineColor;
    uniform float outlineAlpha;

    void main() {

        gl_FragColor = vec4( outlineColor, outlineAlpha );

        #include <fog_fragment>

    }`;
class OutlineEffect {
    constructor(m_renderer) {
        this.m_renderer = m_renderer;
        this.enabled = true;
        this.m_defaultThickness = 0.02;
        this.m_defaultColor = new THREE.Color(0, 0, 0);
        this.m_defaultAlpha = 1;
        this.m_defaultKeepAlive = false;
        this.m_ghostExtrudedPolygons = false;
        this.m_cache = {};
        this.m_removeThresholdCount = 60;
        this.m_originalMaterials = {};
        this.m_originalOnBeforeRenders = {};
        this.m_shaderIDs = {
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical"
        };
        this.m_uniformsChunk = {
            outlineThickness: { value: this.m_defaultThickness },
            outlineColor: { value: this.m_defaultColor },
            outlineAlpha: { value: this.m_defaultAlpha }
        };
        this.autoClear = m_renderer.autoClear;
        this.domElement = m_renderer.domElement;
        this.shadowMap = m_renderer.shadowMap;
    }
    set thickness(thickness) {
        this.m_defaultThickness = thickness;
        this.m_uniformsChunk.outlineThickness.value = thickness;
        this.m_cache = {};
    }
    set color(color) {
        this.m_defaultColor.set(color);
        this.m_cache = {};
    }
    set ghostExtrudedPolygons(ghost) {
        this.m_ghostExtrudedPolygons = ghost;
    }
    clear(color, depth, stencil) {
        this.m_renderer.clear(color, depth, stencil);
    }
    getPixelRatio() {
        return this.m_renderer.getPixelRatio();
    }
    setPixelRatio(value) {
        this.m_renderer.setPixelRatio(value);
    }
    getSize(target) {
        return this.m_renderer.getSize(target);
    }
    setSize(width, height, updateStyle) {
        this.m_renderer.setSize(width, height, updateStyle);
    }
    setViewport(x, y, width, height) {
        this.m_renderer.setViewport(x, y, width, height);
    }
    setScissor(x, y, width, height) {
        this.m_renderer.setScissor(x, y, width, height);
    }
    setScissorTest(boolean) {
        this.m_renderer.setScissorTest(boolean);
    }
    setRenderTarget(renderTarget) {
        this.m_renderer.setRenderTarget(renderTarget);
    }
    render(scene, camera) {
        // Re-rendering the scene with the outline effect enables to hide the
        // extruded polygons and show only the outlines (it is a hack and should be
        // implemented another way!).
        if (this.m_ghostExtrudedPolygons) {
            if (!this.enabled) {
                this.m_renderer.render(scene, camera);
                return;
            }
            const currentAutoClear = this.m_renderer.autoClear;
            this.m_renderer.autoClear = this.autoClear;
            this.m_renderer.render(scene, camera);
            this.m_renderer.autoClear = currentAutoClear;
        }
        this.renderOutline(scene, camera);
    }
    renderOutline(scene, camera) {
        const currentAutoClear = this.m_renderer.autoClear;
        const currentSceneAutoUpdate = scene.autoUpdate;
        const currentSceneBackground = scene.background;
        const currentShadowMapEnabled = this.m_renderer.shadowMap.enabled;
        scene.autoUpdate = false;
        scene.background = null;
        this.m_renderer.autoClear = false;
        this.m_renderer.shadowMap.enabled = false;
        scene.traverse(this.setOutlineMaterial.bind(this));
        this.m_renderer.render(scene, camera);
        scene.traverse(this.restoreOriginalMaterial.bind(this));
        this.cleanupCache();
        scene.autoUpdate = currentSceneAutoUpdate;
        scene.background = currentSceneBackground;
        this.m_renderer.autoClear = currentAutoClear;
        this.m_renderer.shadowMap.enabled = currentShadowMapEnabled;
    }
    createInvisibleMaterial() {
        return new THREE.ShaderMaterial({ name: "invisible", visible: false });
    }
    createMaterial(originalMaterial) {
        const shaderID = this.m_shaderIDs[originalMaterial.type];
        let originalUniforms;
        let originalVertexShader;
        if (shaderID !== undefined) {
            const shader = THREE.ShaderLib[shaderID];
            originalUniforms = shader.uniforms;
            originalVertexShader = shader.vertexShader;
        }
        else if (originalMaterial.isRawShaderMaterial === true) {
            originalUniforms = originalMaterial.uniforms;
            originalVertexShader = originalMaterial.vertexShader;
            if (!/attribute\s+vec3\s+position\s*;/.test(originalVertexShader) ||
                !/attribute\s+vec3\s+normal\s*;/.test(originalVertexShader)) {
                return this.createInvisibleMaterial();
            }
        }
        else if (originalMaterial.isShaderMaterial === true) {
            originalUniforms = originalMaterial.uniforms;
            originalVertexShader = originalMaterial.vertexShader;
        }
        else {
            return this.createInvisibleMaterial();
        }
        const uniforms = Object.assign({}, originalUniforms, this.m_uniformsChunk);
        const vertexShader = originalVertexShader
            // put vertexShaderChunk right before "void main() {...}"
            .replace(/void\s+main\s*\(\s*\)/, vertexShaderChunk + "\nvoid main()")
            // put vertexShaderChunk2 the end of "void main() {...}"
            // Note: here assums originalVertexShader ends with "}" of "void main() {...}"
            .replace(/\}\s*$/, vertexShaderChunk2 + "\n}")
            // remove any light related lines
            // Note: here is very sensitive to originalVertexShader
            // TODO: consider safer way
            .replace(/#include\s+<[\w_]*light[\w_]*>/g, "");
        const defines = {};
        if (!/vec3\s+transformed\s*=/.test(originalVertexShader) &&
            !/#include\s+<begin_vertex>/.test(originalVertexShader)) {
            defines.DECLARE_TRANSFORMED = true;
        }
        return new THREE.ShaderMaterial({
            defines,
            uniforms,
            vertexShader,
            fragmentShader,
            side: THREE.BackSide,
            //wireframe: true,
            skinning: false,
            morphTargets: false,
            morphNormals: false,
            fog: false
        });
    }
    getOutlineMaterialFromCache(originalMaterial) {
        let data = this.m_cache[originalMaterial.uuid];
        if (data === undefined) {
            data = {
                material: this.createMaterial(originalMaterial),
                used: true,
                keepAlive: this.m_defaultKeepAlive,
                count: 0
            };
            this.m_cache[originalMaterial.uuid] = data;
        }
        data.used = true;
        return data.material;
    }
    getOutlineMaterial(originalMaterial) {
        const outlineMaterial = this.getOutlineMaterialFromCache(originalMaterial);
        this.m_originalMaterials[outlineMaterial.uuid] = originalMaterial;
        this.updateOutlineMaterial(outlineMaterial, originalMaterial);
        return outlineMaterial;
    }
    setOutlineMaterial(object) {
        if (object.material === undefined) {
            return;
        }
        if (Array.isArray(object.material)) {
            for (let i = 0, il = object.material.length; i < il; i++) {
                object.material[i] = this.getOutlineMaterial(object.material[i]);
            }
        }
        else {
            object.material = this.getOutlineMaterial(object
                .material);
        }
        this.m_originalOnBeforeRenders[object.uuid] = object.onBeforeRender;
        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, this.onBeforeRender.bind(this));
    }
    restoreOriginalMaterial(object) {
        if (object.material === undefined) {
            return;
        }
        if (Array.isArray(object.material)) {
            for (let i = 0, il = object.material.length; i < il; i++) {
                object.material[i] = this.m_originalMaterials[object.material[i].uuid];
            }
        }
        else {
            object.material = this.m_originalMaterials[object.material.uuid];
        }
        object.onBeforeRender = this.m_originalOnBeforeRenders[object.uuid];
    }
    onBeforeRender(renderer, scene, camera, geometry, material, group) {
        const originalMaterial = this.m_originalMaterials[material.uuid];
        // just in case
        if (originalMaterial === undefined) {
            return;
        }
        this.updateUniforms(material, originalMaterial);
    }
    updateUniforms(material, originalMaterial) {
        const outlineParameters = originalMaterial.userData.outlineParameters;
        material.uniforms.outlineAlpha.value = originalMaterial.opacity;
        if (outlineParameters !== undefined) {
            if (outlineParameters.thickness !== undefined) {
                material.uniforms.outlineThickness.value = outlineParameters.thickness;
            }
            if (outlineParameters.color !== undefined) {
                material.uniforms.outlineColor.value.fromArray(outlineParameters.color);
            }
            if (outlineParameters.alpha !== undefined) {
                material.uniforms.outlineAlpha.value = outlineParameters.alpha;
            }
        }
    }
    updateOutlineMaterial(material, originalMaterial) {
        if (material.name === "invisible") {
            return;
        }
        const outlineParameters = originalMaterial.userData.outlineParameters;
        material.skinning = originalMaterial.skinning;
        material.morphTargets = originalMaterial.morphTargets;
        material.morphNormals = originalMaterial.morphNormals;
        material.fog = originalMaterial.fog;
        if (outlineParameters !== undefined) {
            material.visible =
                originalMaterial.visible === false
                    ? false
                    : outlineParameters.visible !== undefined
                        ? outlineParameters.visible
                        : true;
            material.transparent =
                outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0
                    ? true
                    : originalMaterial.transparent;
            if (outlineParameters.keepAlive !== undefined) {
                this.m_cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;
            }
        }
        else {
            material.transparent = originalMaterial.transparent;
            material.visible = originalMaterial.visible;
        }
        if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) {
            material.visible = false;
        }
    }
    cleanupCache() {
        let keys;
        // clear originialMaterials
        keys = Object.keys(this.m_originalMaterials);
        for (let i = 0, il = keys.length; i < il; i++) {
            this.m_originalMaterials[keys[i]] = undefined;
        }
        // clear originalOnBeforeRenders
        keys = Object.keys(this.m_originalOnBeforeRenders);
        for (let i = 0, il = keys.length; i < il; i++) {
            this.m_originalOnBeforeRenders[keys[i]] = undefined;
        }
        // remove unused outlineMaterial from cache
        keys = Object.keys(this.m_cache);
        for (const key of keys) {
            if (this.m_cache[key].used === false) {
                this.m_cache[key].count++;
                if (this.m_cache[key].keepAlive === false &&
                    this.m_cache[key].count > this.m_removeThresholdCount) {
                    delete this.m_cache[key];
                }
            }
            else {
                this.m_cache[key].used = false;
                this.m_cache[key].count = 0;
            }
        }
    }
}
exports.OutlineEffect = OutlineEffect;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/Pass.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/Pass.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * The base class to extend for further passes in [[MapView]], like the [[MSAARenderPass]], possibly
 * a text pass, an AO effect etc. `Pass` provides the core logic for both :
 * - render passes (proper scene renders),
 * - and shader passes (quad renders, i.e. effects added on top of the render output as a
 * postprocess).
 *
 * Even some shader passes still actually fall within the render pass category as they need to
 * re-render the scene to then deduce an effect, such as masking, AO, DoF etc. Others just need the
 * previous input image to apply a shader on top of it, as for bloom or NVIDIA's FXAA for example.
 * These only are proper shader passes.
 */
class Pass {
    constructor() {
        this.enabled = false;
        this.renderToScreen = false;
        // tslint:enable:no-unused-variable
    }
    // tslint:disable-next-line:no-unused-variable
    setSize(width, height) {
        // Implemented in sub-classes.
    }
    // tslint:disable:no-unused-variable
    render(renderer, scene, camera, writeBuffer, readBuffer, delta) {
        // Implemented in sub-classes.
    }
}
exports.Pass = Pass;
/**
 * The pass that does a default normal scene rendering for further post-effects.
 */
class RenderPass extends Pass {
    constructor() {
        super();
    }
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
        renderer.render(scene, camera);
    }
}
exports.RenderPass = RenderPass;
/**
 * The base class to extend for post-effects on the final render (like Vignette, Sepia, color
 * correction...)
 */
class ShaderPass extends Pass {
    constructor(shader, textureID = "tDiffuse") {
        super();
        this.textureID = textureID;
        if (shader instanceof THREE.ShaderMaterial) {
            this.uniforms = shader.uniforms;
            this.material = shader;
        }
        else {
            this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
            this.material = new THREE.ShaderMaterial({
                defines: Object.assign({}, shader.defines),
                uniforms: this.uniforms,
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader
            });
        }
        this.fsQuad = new FullScreenQuad(this.material);
    }
    render(renderer, scene, camera, writeBuffer, readBuffer, delta) {
        if (this.uniforms[this.textureID]) {
            this.uniforms[this.textureID].value = readBuffer.texture;
        }
        this.fsQuad.material = this.material;
        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
        this.fsQuad.render(renderer);
    }
}
exports.ShaderPass = ShaderPass;
class FullScreenQuad {
    constructor(material) {
        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const geometry = new THREE.PlaneBufferGeometry(2, 2);
        this.m_mesh = new THREE.Mesh(geometry, material);
    }
    get material() {
        return this.m_mesh.material;
    }
    set material(value) {
        this.m_mesh.material = value;
    }
    render(renderer) {
        renderer.render(this.m_mesh, this.m_camera);
    }
}


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/UnrealBloomPass.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/UnrealBloomPass.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const Pass_1 = __webpack_require__(/*! ./Pass */ "./node_modules/@here/harp-mapview/lib/composing/Pass.js");
const BlurDirectionX = new THREE.Vector2(1.0, 0.0);
const BlurDirectionY = new THREE.Vector2(0.0, 1.0);
/**
 * The TS version of ThreeJS's UnrealBloomPass.
 */
class BloomPass extends Pass_1.Pass {
    constructor(resolution, strength, radius, threshold) {
        super();
        this.resolution = new THREE.Vector2(256, 256);
        this.m_renderTargetsHorizontal = [];
        this.m_renderTargetsVertical = [];
        this.m_nMips = 5;
        this.m_separableBlurMaterials = [];
        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.m_scene = new THREE.Scene();
        this.m_basic = new THREE.MeshBasicMaterial();
        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2));
        this.m_bloomTintColors = [
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1)
        ];
        this.strength = strength;
        this.radius = radius;
        this.threshold = threshold;
        this.resolution = resolution;
        this.m_quad.frustumCulled = false;
        this.m_scene.add(this.m_quad);
        const pars = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat
        };
        let resx = Math.round(this.resolution.x / 2);
        let resy = Math.round(this.resolution.y / 2);
        this.m_renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);
        this.m_renderTargetBright.texture.name = "UnrealBloomPass.bright";
        this.m_renderTargetBright.texture.generateMipmaps = false;
        for (let i = 0; i < this.m_nMips; i++) {
            const renderTargetHorizonal = new THREE.WebGLRenderTarget(resx, resy, pars);
            renderTargetHorizonal.texture.name = "UnrealBloomPass.h" + i;
            renderTargetHorizonal.texture.generateMipmaps = false;
            this.m_renderTargetsHorizontal.push(renderTargetHorizonal);
            const renderTargetVertical = new THREE.WebGLRenderTarget(resx, resy, pars);
            renderTargetVertical.texture.name = "UnrealBloomPass.v" + i;
            renderTargetVertical.texture.generateMipmaps = false;
            this.m_renderTargetsVertical.push(renderTargetVertical);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
        this.m_highPassUniforms = THREE.UniformsUtils.clone(harp_materials_1.LuminosityHighPassShader.uniforms);
        // tslint:disable:no-string-literal
        this.m_highPassUniforms["luminosityThreshold"].value = threshold;
        this.m_highPassUniforms["smoothWidth"].value = 0.01;
        this.m_materialHighPassFilter = new THREE.ShaderMaterial({
            uniforms: this.m_highPassUniforms,
            vertexShader: harp_materials_1.LuminosityHighPassShader.vertexShader,
            fragmentShader: harp_materials_1.LuminosityHighPassShader.fragmentShader,
            defines: {}
        });
        // Gaussian Blur Materials
        const kernelSizeArray = [3, 5, 7, 9, 11];
        resx = Math.round(this.resolution.x / 2);
        resy = Math.round(this.resolution.y / 2);
        for (let i = 0; i < this.m_nMips; i++) {
            this.m_separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));
            this.m_separableBlurMaterials[i].uniforms["texSize"].value = new THREE.Vector2(resx, resy);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
        // Composite material
        this.m_compositeMaterial = this.getCompositeMaterial(this.m_nMips);
        this.m_compositeMaterial.uniforms["blurTexture1"].value = this.m_renderTargetsVertical[0].texture;
        this.m_compositeMaterial.uniforms["blurTexture2"].value = this.m_renderTargetsVertical[1].texture;
        this.m_compositeMaterial.uniforms["blurTexture3"].value = this.m_renderTargetsVertical[2].texture;
        this.m_compositeMaterial.uniforms["blurTexture4"].value = this.m_renderTargetsVertical[3].texture;
        this.m_compositeMaterial.uniforms["blurTexture5"].value = this.m_renderTargetsVertical[4].texture;
        this.m_compositeMaterial.uniforms["bloomStrength"].value = strength;
        this.m_compositeMaterial.uniforms["bloomRadius"].value = 0.1;
        this.m_compositeMaterial.needsUpdate = true;
        const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];
        this.m_compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
        this.m_compositeMaterial.uniforms["bloomTintColors"].value = this.m_bloomTintColors;
        this.m_copyUniforms = THREE.UniformsUtils.clone(harp_materials_1.CopyShader.uniforms);
        this.m_copyUniforms["opacity"].value = 1.0;
        // tslint:enable:no-string-literal
        this.m_materialCopy = new THREE.ShaderMaterial({
            uniforms: this.m_copyUniforms,
            vertexShader: harp_materials_1.CopyShader.vertexShader,
            fragmentShader: harp_materials_1.CopyShader.fragmentShader,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            depthWrite: false,
            transparent: true
        });
    }
    dispose() {
        for (const rt of this.m_renderTargetsHorizontal) {
            rt.dispose();
        }
        for (const rt of this.m_renderTargetsVertical) {
            rt.dispose();
        }
        this.m_renderTargetBright.dispose();
    }
    setSize(width, height) {
        let resx = Math.round(width / 2);
        let resy = Math.round(height / 2);
        this.m_renderTargetBright.setSize(resx, resy);
        for (let i = 0; i < this.m_nMips; i++) {
            this.m_renderTargetsHorizontal[i].setSize(resx, resy);
            this.m_renderTargetsVertical[i].setSize(resx, resy);
            // tslint:disable-next-line:no-string-literal
            this.m_separableBlurMaterials[i].uniforms["texSize"].value = new THREE.Vector2(resx, resy);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
    }
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        // tslint:disable:no-string-literal
        // Render input to screen
        if (this.renderToScreen) {
            this.m_quad.material = this.m_basic;
            this.m_basic.map = readBuffer.texture;
            renderer.setRenderTarget(null);
            renderer.clear();
            renderer.render(this.m_scene, this.m_camera);
        }
        // 1. Extract bright areas
        this.m_highPassUniforms["tDiffuse"].value = readBuffer.texture;
        this.m_highPassUniforms["luminosityThreshold"].value = this.threshold;
        this.m_quad.material = this.m_materialHighPassFilter;
        renderer.setRenderTarget(this.m_renderTargetBright);
        renderer.clear();
        renderer.render(this.m_scene, this.m_camera);
        // 2. Blur all the mips progressively
        let inputRenderTarget = this.m_renderTargetBright;
        for (let i = 0; i < this.m_nMips; i++) {
            this.m_quad.material = this.m_separableBlurMaterials[i];
            this.m_separableBlurMaterials[i].uniforms["colorTexture"].value =
                inputRenderTarget.texture;
            this.m_separableBlurMaterials[i].uniforms["direction"].value = BlurDirectionX;
            renderer.setRenderTarget(this.m_renderTargetsHorizontal[i]);
            renderer.clear();
            renderer.render(this.m_scene, this.m_camera);
            this.m_separableBlurMaterials[i].uniforms["colorTexture"].value = this.m_renderTargetsHorizontal[i].texture;
            this.m_separableBlurMaterials[i].uniforms["direction"].value = BlurDirectionY;
            renderer.setRenderTarget(this.m_renderTargetsVertical[i]);
            renderer.clear();
            renderer.render(this.m_scene, this.m_camera);
            inputRenderTarget = this.m_renderTargetsVertical[i];
        }
        // Composite all the mips
        this.m_quad.material = this.m_compositeMaterial;
        this.m_compositeMaterial.uniforms["bloomStrength"].value = this.strength;
        this.m_compositeMaterial.uniforms["bloomRadius"].value = this.radius;
        this.m_compositeMaterial.uniforms["bloomTintColors"].value = this.m_bloomTintColors;
        renderer.setRenderTarget(this.m_renderTargetsHorizontal[0]);
        renderer.clear();
        renderer.render(this.m_scene, this.m_camera);
        // Blend it additively over the input texture
        this.m_quad.material = this.m_materialCopy;
        this.m_copyUniforms["tDiffuse"].value = this.m_renderTargetsHorizontal[0].texture;
        if (this.renderToScreen) {
            renderer.setRenderTarget(null);
            renderer.render(this.m_scene, this.m_camera);
        }
        else {
            renderer.setRenderTarget(readBuffer);
            renderer.render(this.m_scene, this.m_camera);
        }
        // tslint:enable:no-string-literal
    }
    getSeperableBlurMaterial(kernelRadius) {
        return new THREE.ShaderMaterial({
            defines: {
                KERNEL_RADIUS: kernelRadius,
                SIGMA: kernelRadius
            },
            uniforms: {
                colorTexture: { value: null },
                texSize: { value: new THREE.Vector2(0.5, 0.5) },
                direction: { value: new THREE.Vector2(0.5, 0.5) }
            },
            vertexShader: `varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }`,
            fragmentShader: `#include <common>
            varying vec2 vUv;
            uniform sampler2D colorTexture;
            uniform vec2 texSize;
            uniform vec2 direction;

            float gaussianPdf(in float x, in float sigma) {
                return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
            }
            void main() {\n\
                vec2 invSize = 1.0 / texSize;
                float fSigma = float(SIGMA);
                float weightSum = gaussianPdf(0.0, fSigma);
                vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
                for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
                    float x = float(i);
                    float w = gaussianPdf(x, fSigma);
                    vec2 uvOffset = direction * invSize * x;
                    vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
                    vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
                    diffuseSum += (sample1 + sample2) * w;
                    weightSum += 2.0 * w;
                }
                gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
            }`
        });
    }
    getCompositeMaterial(nMips) {
        return new THREE.ShaderMaterial({
            defines: {
                NUM_MIPS: nMips
            },
            uniforms: {
                blurTexture1: { value: null },
                blurTexture2: { value: null },
                blurTexture3: { value: null },
                blurTexture4: { value: null },
                blurTexture5: { value: null },
                dirtTexture: { value: null },
                bloomStrength: { value: 1.0 },
                bloomFactors: { value: null },
                bloomTintColors: { value: null },
                bloomRadius: { value: 0.0 }
            },
            vertexShader: `varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }`,
            fragmentShader: `varying vec2 vUv;
                uniform sampler2D blurTexture1;
                uniform sampler2D blurTexture2;
                uniform sampler2D blurTexture3;
                uniform sampler2D blurTexture4;
                uniform sampler2D blurTexture5;
                uniform sampler2D dirtTexture;
                uniform float bloomStrength;
                uniform float bloomRadius;
                uniform float bloomFactors[NUM_MIPS];
                uniform vec3 bloomTintColors[NUM_MIPS];

                float lerpBloomFactor(const in float factor) {
                    float mirrorFactor = 1.2 - factor;
                    return mix(factor, mirrorFactor, bloomRadius);
                }

                void main() {
                    gl_FragColor = bloomStrength * (
lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
                }`
        });
    }
}
exports.BloomPass = BloomPass;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var MapRenderingManager_1 = __webpack_require__(/*! ./MapRenderingManager */ "./node_modules/@here/harp-mapview/lib/composing/MapRenderingManager.js");
exports.MapRenderingManager = MapRenderingManager_1.MapRenderingManager;
var Pass_1 = __webpack_require__(/*! ./Pass */ "./node_modules/@here/harp-mapview/lib/composing/Pass.js");
exports.Pass = Pass_1.Pass;
var MSAARenderPass_1 = __webpack_require__(/*! ./MSAARenderPass */ "./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js");
exports.MSAARenderPass = MSAARenderPass_1.MSAARenderPass;
exports.MSAASampling = MSAARenderPass_1.MSAASampling;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileDataAccessor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileDataAccessor.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const TileGeometry_1 = __webpack_require__(/*! ./TileGeometry */ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js");
const logger = harp_utils_1.LoggerManager.instance.create("TileDataAccessor");
/**
 * An accessor for all geometries in a tile. This class uses a client-provided [[ITileDataVisitor]]
 * to visit all objects, based on filtering options specified by both, the `TileDataAccessor` and
 * the visitor itself.
 */
class TileDataAccessor {
    /**
     * Constructs a `TileDataAccessor` instance.
     *
     * @param tile The tile to access.
     * @param visitor The visitor.
     * @param options Options for the tile.
     */
    constructor(tile, visitor, options) {
        this.tile = tile;
        this.visitor = visitor;
        this.m_wantsPoints = true;
        this.m_wantsLines = true;
        this.m_wantsAreas = true;
        this.m_wantsObject3D = true;
        const wantsAll = options.wantsAll === true;
        this.m_wantsPoints = wantsAll || !(options.wantsPoints === false);
        this.m_wantsLines = wantsAll || !(options.wantsLines === false);
        this.m_wantsAreas = wantsAll || !(options.wantsAreas === false);
        this.m_wantsObject3D = wantsAll || !(options.wantsObject3D === false);
    }
    /**
     * Calls the visitor on all objects in the tile.
     */
    visitAll() {
        const objects = this.tile.objects;
        for (const object of objects) {
            this.visitObject(object);
        }
    }
    /**
     * Visits a single object. This function should normally be called during visiting.
     *
     * @param object The object to visit.
     */
    visitObject(object) {
        const featureData = object.userData !== undefined
            ? object.userData.feature
            : undefined;
        // early opt out if there is no feature data, or if the feature data has only a single id
        // and the visitor wants to ignore that featureId
        if (featureData === undefined ||
            (featureData.ids !== undefined &&
                featureData.ids.length === 1 &&
                !this.visitor.wantsFeature(featureData.ids[0]))) {
            return;
        }
        const geometryType = featureData.geometryType;
        if (geometryType === undefined) {
            logger.warn("#visitObject: visiting object failed, no geometryType", object);
            return;
        }
        harp_utils_1.assert(featureData.ids !== undefined, "featureData.ids missing");
        harp_utils_1.assert(Array.isArray(featureData.ids), "featureData.ids is not an array");
        harp_utils_1.assert(featureData.starts !== undefined, "featureData.starts missing");
        harp_utils_1.assert(Array.isArray(featureData.starts), "featureData.starts is not an array");
        if (featureData.ids !== undefined && featureData.starts !== undefined) {
            harp_utils_1.assert(featureData.ids.length === featureData.starts.length, "featureData.ids and featureData.starts have unequal length");
        }
        switch (geometryType) {
            case harp_datasource_protocol_1.GeometryType.Point:
            case harp_datasource_protocol_1.GeometryType.Text:
                if (!this.m_wantsPoints) {
                    return;
                }
                break;
            case harp_datasource_protocol_1.GeometryType.SolidLine:
            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
            case harp_datasource_protocol_1.GeometryType.TextPath:
                if (!this.m_wantsLines) {
                    return;
                }
                break;
            case harp_datasource_protocol_1.GeometryType.Polygon:
            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                if (!this.m_wantsAreas) {
                    return;
                }
                break;
            case harp_datasource_protocol_1.GeometryType.Object3D:
                if (!this.m_wantsObject3D) {
                    return;
                }
                break;
            default:
                logger.warn("#visitObject: invalid geometryType");
        }
        if (object.type !== "Mesh") {
            logger.warn("#visitObject: visiting object failed, not of type 'Mesh'", object);
            return;
        }
        const mesh = object;
        this.visitMesh(mesh, featureData);
    }
    /**
     * Gets the `BufferGeometry` from the specified object. This function requires the
     * attribute `position` in `BufferGeometry` to be set.
     *
     * @param object The object from which to get the geometry.
     * @returns the geometry of the object, or `undefined`.
     */
    getBufferGeometry(object) {
        const geometry = object.geometry;
        if (geometry.type !== "BufferGeometry") {
            logger.warn("#visitObject: object does not have BufferGeometry");
            return undefined;
        }
        const bufferGeometry = geometry;
        // we know its a BufferAttribute because it is a BufferGeometry
        const position = bufferGeometry.getAttribute("position");
        if (!position) {
            logger.warn("#visitLines: BufferGeometry has no position attribute");
            return undefined;
        }
        return bufferGeometry;
    }
    /**
     * Obtains an accessor for the nonindexed geometry. This function may return `undefined`
     * if the accessor is not implemented.
     *
     * @param geometryType The type of geometry.
     * @param object The object for which to access the attributes and geometry.
     * @param bufferGeometry The object's `BufferGeometry`.
     * @returns an accessor for a specified object, if available.
     */
    getGeometryAccessor(geometryType, object, bufferGeometry) {
        switch (geometryType) {
            case harp_datasource_protocol_1.GeometryType.Point:
            case harp_datasource_protocol_1.GeometryType.Text:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.SolidLine:
            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
            case harp_datasource_protocol_1.GeometryType.TextPath:
                return new TileGeometry_1.BufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
            case harp_datasource_protocol_1.GeometryType.Polygon:
            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.Object3D:
                return new TileGeometry_1.BufferedGeometryObject3dAccessor(object, geometryType, bufferGeometry);
            default:
                logger.warn("#getGeometryAccessor: invalid geometryType");
        }
        return undefined;
    }
    /**
     * Obtains an accessor for the indexed geometry. This function may return `undefined`
     * if the accessor is not implemented.
     *
     * @param geometryType The type of geometry.
     * @param object The object for which to access the attributes and geometry.
     * @param bufferGeometry The object's `BufferGeometry`.
     * @returns an accessor for a specified object, if available.
     */
    getIndexedGeometryAccessor(geometryType, object, bufferGeometry) {
        switch (geometryType) {
            case harp_datasource_protocol_1.GeometryType.Point:
            case harp_datasource_protocol_1.GeometryType.Text:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.SolidLine:
            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
            case harp_datasource_protocol_1.GeometryType.TextPath:
                return new TileGeometry_1.IndexedBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
            case harp_datasource_protocol_1.GeometryType.Polygon:
            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.Object3D:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            default:
                logger.warn("#getIndexedGeometryAccessor: invalid geometryType");
        }
        return undefined;
    }
    /**
     * Visit the object.
     *
     * @param meshObject Object of type `Mesh`.
     * @param featureData Dataset stored along with the object.
     */
    visitMesh(meshObject, featureData) {
        const { ids, starts } = featureData;
        const geometryType = featureData.geometryType;
        // make linter happy: we already know that these both are valid
        if (ids === undefined || starts === undefined || geometryType === undefined) {
            return;
        }
        let geometryAccessor;
        for (let featureIndex = 0; featureIndex < ids.length; featureIndex++) {
            const featureId = ids[featureIndex];
            if (!this.visitor.wantsFeature(featureId)) {
                continue;
            }
            const featureStart = starts[featureIndex];
            let featureEnd = -1;
            // lazy creation of accessor, in case featureId was not wanted...
            if (geometryAccessor === undefined) {
                const bufferGeometry = this.getBufferGeometry(meshObject);
                if (bufferGeometry === undefined) {
                    continue;
                }
                if (bufferGeometry.index !== null) {
                    geometryAccessor = this.getIndexedGeometryAccessor(geometryType, meshObject, bufferGeometry);
                }
                else {
                    geometryAccessor = this.getGeometryAccessor(geometryType, meshObject, bufferGeometry);
                }
                if (geometryAccessor === undefined) {
                    logger.warn("#visitObject: no accessor geometryType", geometryType);
                    continue;
                }
            }
            featureEnd =
                featureIndex < starts.length - 1
                    ? starts[featureIndex + 1]
                    : geometryAccessor.getCount();
            // setup/update the accessor for the new range of the object
            geometryAccessor.setRange(featureStart, featureEnd);
            switch (geometryType) {
                case harp_datasource_protocol_1.GeometryType.Point:
                case harp_datasource_protocol_1.GeometryType.Text:
                    this.visitor.visitPoint(featureId);
                    break;
                case harp_datasource_protocol_1.GeometryType.SolidLine:
                case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
                case harp_datasource_protocol_1.GeometryType.TextPath:
                    harp_utils_1.assert(TileGeometry_1.isLineAccessor(geometryAccessor));
                    this.visitor.visitLine(featureId, geometryAccessor);
                    break;
                case harp_datasource_protocol_1.GeometryType.Polygon:
                case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                    this.visitor.visitArea(featureId);
                    break;
                case harp_datasource_protocol_1.GeometryType.Object3D:
                    harp_utils_1.assert(TileGeometry_1.isObject3dAccessor(geometryAccessor));
                    this.visitor.visitObject3D(featureId, geometryAccessor);
                    break;
                default:
                    logger.warn("#visitObject: invalid geometryType");
            }
        }
    }
}
exports.TileDataAccessor = TileDataAccessor;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_lines_1 = __webpack_require__(/*! @here/harp-lines */ "./node_modules/@here/harp-lines/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const logger = harp_utils_1.LoggerManager.instance.create("TileGeometry");
/**
 * Helper function to check if an accessor is of type `ILineAccessor`.
 *
 * @param arg `true` if `arg` is `ILineAccessor`.
 */
function isLineAccessor(arg) {
    /**
     * Get vertices from the object.
     *
     * @param mode Specifies which part of the vertices should be returned.
     */
    return typeof arg.isLineAccessor === "function" && arg.isLineAccessor() === true;
}
exports.isLineAccessor = isLineAccessor;
/**
 * Helper function to check if an accessor is of type `IObject3dAccessor`.
 *
 * @param arg `true` if `arg` is `IObject3dAccessor`.
 */
function isObject3dAccessor(arg) {
    return typeof arg.isObject3dAccessor === "function" && arg.isObject3dAccessor() === true;
}
exports.isObject3dAccessor = isObject3dAccessor;
/**
 * Geometry accessor for both indexed and nonindexed `BufferedGeometry`.
 */
class BufferedGeometryAccessorBase {
    constructor(object, geometryType, bufferGeometry) {
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
        this.start = -1;
        this.end = -1;
        this.startCapSize = 0;
        this.endCapSize = 0;
        harp_utils_1.assert(!!object);
        if (bufferGeometry.type !== "BufferGeometry") {
            logger.error("IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong " + "type");
        }
        harp_utils_1.assert(bufferGeometry.type === "BufferGeometry", "IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong type");
        // we know its a BufferAttribute because it is a BufferGeometry
        this.position = this.bufferGeometry.getAttribute("position");
        this.itemSize = this.position.itemSize;
        if (!this.position) {
            logger.warn("BufferedGeometryAccessor#constructor: BufferGeometry has no position " +
                "attribute");
        }
        if (this.position.array.constructor !== Float32Array) {
            logger.warn("BufferedGeometryAccessor#constructor: BufferGeometry.position: " +
                "unsupported ArrayBuffer");
        }
    }
    /**
     * Get the number of accessible geometries in this buffer.
     *
     * @returns Number of primitives in this geometry.
     */
    getCount() {
        return this.position.count;
    }
    /**
     * Get `renderOrder` of object.
     *
     * @returns `renderOrder` of the object.
     */
    get renderOrder() {
        return this.object.renderOrder;
    }
    setRange(start, end, startCapSize = 0, endCapSize = 0) {
        harp_utils_1.assert(start >= 0);
        harp_utils_1.assert(end >= 0);
        harp_utils_1.assert(start <= end);
        this.start = start;
        this.end = end;
        this.startCapSize = startCapSize;
        this.endCapSize = endCapSize;
    }
    /**
     * Get one or more colors from materials.
     */
    get color() {
        /**
         * TODO: Get color(s) from vertex colors
         */
        const getColor = (material) => {
            const meshMaterial = material;
            if (meshMaterial.type === "MeshBasicMaterial" ||
                meshMaterial.type === "MeshStandardMaterial") {
                return meshMaterial.color;
            }
            else if (meshMaterial.type === "RawShaderMaterial") {
                const rawShaderMaterial = material;
                if (rawShaderMaterial.name === "SolidLineMaterial") {
                    return rawShaderMaterial.uniforms.diffuse.value;
                }
                logger.warn("BufferedGeometryAccessor#color: unknown shader material name", rawShaderMaterial.name);
            }
            else {
                logger.warn("BufferedGeometryAccessor#color: unknown material type", meshMaterial.type);
            }
            return undefined;
        };
        if (Array.isArray(this.object.material)) {
            const results = new Array();
            const materials = this.object.material;
            for (const material of materials) {
                results.push(getColor(material));
            }
            return results;
        }
        else {
            return getColor(this.object.material);
        }
    }
}
exports.BufferedGeometryAccessorBase = BufferedGeometryAccessorBase;
/**
 * Abstract base class of an accessor for nonindexed geometry.
 */
class BufferedGeometryAccessor extends BufferedGeometryAccessorBase {
    /**
     * Create an object of type `BufferedGeometryAccessor`
     *
     * @param object - mesh object
     * @param geometryType - type of geometry to be used
     * @param bufferGeometry - which buffer geometry to use
     * @param stride - geometry stride length
     */
    constructor(object, geometryType, bufferGeometry, stride) {
        super(object, geometryType, bufferGeometry);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
        this.stride = stride;
    }
    clear() {
        harp_utils_1.assert(this.checkSetUp(), "BufferedGeometryAccessor not setup");
        const positionsArray = this.position.array;
        const start = this.start * this.itemSize;
        const end = this.end * this.itemSize;
        for (let i = start; i < end; i++) {
            positionsArray[i] = 0;
        }
        this.position.needsUpdate = true;
    }
    getVertices() {
        harp_utils_1.assert(this.checkSetUp(), "BufferedGeometryAccessor not setup");
        const start = this.start;
        const end = this.end;
        return this.position.array.subarray(start * this.itemSize, end * this.itemSize);
    }
    checkSetUp() {
        return (this.position !== undefined &&
            this.start !== undefined &&
            this.end !== undefined &&
            this.start >= 0 &&
            this.end <= this.position.count &&
            this.start <= this.end);
    }
}
exports.BufferedGeometryAccessor = BufferedGeometryAccessor;
/**
 * Accessor for nonindexed line geometry.
 */
class BufferedGeometryLineAccessor extends BufferedGeometryAccessor {
    constructor(object, geometryType, bufferGeometry) {
        super(object, geometryType, bufferGeometry, 3);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
    }
    isLineAccessor() {
        return true;
    }
    get width() {
        //TODO: There is no implementation of such a line, yet...
        harp_utils_1.assert(this.checkSetUp(), "RoBufferedGeometryLineAccessor not setup");
        return undefined;
    }
}
exports.BufferedGeometryLineAccessor = BufferedGeometryLineAccessor;
/**
 * Accessor for nonindexed unspecified (`Object3D`) geometry.
 */
class BufferedGeometryObject3dAccessor extends BufferedGeometryAccessor {
    constructor(object, geometryType, bufferGeometry) {
        super(object, geometryType, bufferGeometry, 1);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
    }
    isObject3dAccessor() {
        return true;
    }
    getVertices() {
        return super.getVertices();
    }
}
exports.BufferedGeometryObject3dAccessor = BufferedGeometryObject3dAccessor;
/**
 * Abstract base class of indexed geometry.
 */
class IndexedBufferedGeometryAccessor extends BufferedGeometryAccessorBase {
    /**
     * Creates an abstract class `IndexedBufferedGeometryAccessor`.
     *
     * @param object - mesh to be used
     * @param geometryType - type of geometry
     * @param bufferGeometry - geometry used
     * @param start
     * @param end
     */
    constructor(object, geometryType, bufferGeometry, 
    // tslint:disable-next-line:no-unused-variable
    start, 
    // tslint:disable-next-line:no-unused-variable
    end) {
        super(object, geometryType, bufferGeometry);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
        this.indices = this.bufferGeometry.index.array;
        if (!this.indices) {
            logger.warn("IndexedBufferedGeometryAccessor#constructor: BufferGeometry has no " + "index");
            harp_utils_1.assert(!!this.indices);
        }
        else {
            if (!(this.indices instanceof Uint32Array)) {
                logger.warn("IndexedBufferedGeometryAccessor#constructor: BufferGeometry index " +
                    "has wrong type");
                harp_utils_1.assert(this.indices instanceof Uint32Array);
            }
        }
    }
    /**
     * Returns number of primitives, which is not known in this base class, so we return the number
     * of indices.
     *
     * @returns The number of indices in the geometry.
     */
    getCount() {
        return this.indices.length;
    }
    checkSetUp() {
        return (!!this.indices &&
            this.start !== undefined &&
            this.end !== undefined &&
            this.start >= 0 &&
            this.end <= this.indices.length &&
            this.start <= this.end);
    }
}
exports.IndexedBufferedGeometryAccessor = IndexedBufferedGeometryAccessor;
/**
 * Accessor for lines in an indexed geometry.
 */
class IndexedBufferedGeometryLineAccessor extends IndexedBufferedGeometryAccessor {
    constructor(object, geometryType, bufferGeometry) {
        super(object, geometryType, bufferGeometry, 3);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
    }
    isLineAccessor() {
        return true;
    }
    /**
     * Reconstructs line width from triangulated geometry.
     *
     * @returns Line width.
     */
    get width() {
        harp_utils_1.assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
        if (this.geometryType === harp_datasource_protocol_1.GeometryType.ExtrudedLine) {
            const start = this.start + this.startCapSize;
            const positionArray = this.position.array;
            return harp_lines_1.reconstructLineWidth(positionArray, start);
        }
        return undefined;
    }
    clear() {
        harp_utils_1.assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
        const start = this.start;
        const end = this.end;
        for (let i = start; i < end; i++) {
            this.indices[i] = 0;
        }
        this.bufferGeometry.index.needsUpdate = true;
    }
    getVertices() {
        harp_utils_1.assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
        const itemSize = this.itemSize;
        const start = this.start;
        const end = this.end;
        const result = new Float32Array((end - start) * itemSize);
        const positionArray = this.position.array;
        if (itemSize === 2) {
            for (let i = start, j = 0; i < end; i++, j += itemSize) {
                const index = this.indices[i];
                result[j + 0] = positionArray[index * itemSize + 0];
                result[j + 1] = positionArray[index * itemSize + 1];
            }
        }
        if (itemSize === 3) {
            for (let i = start, j = 0; i < end; i++, j += itemSize) {
                const index = this.indices[i];
                result[j + 0] = positionArray[index * itemSize + 0];
                result[j + 1] = positionArray[index * itemSize + 1];
                result[j + 2] = positionArray[index * itemSize + 2];
            }
        }
        else {
            for (let i = start, j = 0; i < end; i++, j++) {
                const index = this.indices[i];
                for (let k = 0; k < itemSize; k++) {
                    result[j * itemSize + k] = positionArray[index * itemSize + k];
                }
            }
        }
        return result;
    }
}
exports.IndexedBufferedGeometryLineAccessor = IndexedBufferedGeometryLineAccessor;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
// tslint:disable:max-line-length
const SphericalGeometrySubdivisionModifier_1 = __webpack_require__(/*! @here/harp-geometry/lib/SphericalGeometrySubdivisionModifier */ "./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "./node_modules/@here/harp-text-canvas/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const AnimatedExtrusionHandler_1 = __webpack_require__(/*! ../AnimatedExtrusionHandler */ "./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js");
const ColorCache_1 = __webpack_require__(/*! ../ColorCache */ "./node_modules/@here/harp-mapview/lib/ColorCache.js");
const DecodedTileHelpers_1 = __webpack_require__(/*! ../DecodedTileHelpers */ "./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js");
const DepthPrePass_1 = __webpack_require__(/*! ../DepthPrePass */ "./node_modules/@here/harp-mapview/lib/DepthPrePass.js");
const TextElement_1 = __webpack_require__(/*! ../text/TextElement */ "./node_modules/@here/harp-mapview/lib/text/TextElement.js");
const TextElementsRenderer_1 = __webpack_require__(/*! ../text/TextElementsRenderer */ "./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js");
const TextStyleCache_1 = __webpack_require__(/*! ../text/TextStyleCache */ "./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js");
/**
 * The SORT_WEIGHT_PATH_LENGTH constants control how the priority of the labels are computed based
 * on the length of the label strings.
 *
 * Consequently, the [[Technique]]s priority is slightly modified while generating
 * [[TextElement]]s from the [[DecodedTile]], to get a more meaningful priority and stable results.
 */
/**
 * Gives [[TextElement]]s with longer paths a higher priority.
 */
const SORT_WEIGHT_PATH_LENGTH = 0.1;
/**
 * Support class to create geometry for a [[Tile]] from a [[DecodedTile]].
 */
class TileGeometryCreator {
    /**
     * Prepare decoded tile for geometry creation.
     *
     * @param decodedTile The decodedTile containing the actual tile map data.
     */
    initDecodedTile(_decodedTile) {
        //
    }
    /**
     * Called after the `Tile` has been decoded.
     *
     * @param tile The [[Tile]] to process.
     * @param decodedTile The decodedTile containing the actual tile map data.
     */
    createAllGeometries(tile, decodedTile) {
        tile.clear();
        this.preparePois(tile, decodedTile);
        this.createTextElements(tile, decodedTile);
        this.createObjects(tile, decodedTile);
    }
    /**
     * Adds a THREE object to the root of the tile. Sets the owning tiles datasource.name and the
     * tileKey in the `userData` property of the object, such that the tile it belongs to can be
     * identified during picking.
     *
     * @param tile The [[Tile]] to add the object to.
     * @param object The object to add to the root of the tile.
     * @param geometryKind The kind of object. Can be used for filtering.
     */
    registerTileObject(tile, object) {
        const userData = object.userData || {};
        userData.tileKey = tile.tileKey;
        userData.dataSource = tile.dataSource.name;
    }
    /**
     * Splits the text paths that contain sharp corners.
     *
     * @param tile The [[Tile]] to process paths on.
     * @param textPathGeometries The original path geometries that may have defects.
     */
    prepareTextPaths(tile, textPathGeometries) {
        const processedPaths = new Array();
        const MAX_CORNER_ANGLE = Math.PI / 8;
        const newPaths = textPathGeometries.slice();
        // maximum reuse of variables to reduce allocations
        const p0 = new THREE.Vector2();
        const p1 = new THREE.Vector2();
        const previousTangent = new THREE.Vector2();
        while (newPaths.length > 0) {
            const textPath = newPaths.pop();
            if (textPath === undefined) {
                break;
            }
            let splitIndex = -1;
            for (let i = 0; i < textPath.path.length - 3; i += 3) {
                p0.set(textPath.path[i], textPath.path[i + 1]);
                p1.set(textPath.path[i + 3], textPath.path[i + 4]);
                const tangent = p1.sub(p0).normalize();
                if (i > 0) {
                    const theta = Math.atan2(previousTangent.x * tangent.y - tangent.x * previousTangent.y, tangent.dot(previousTangent));
                    if (Math.abs(theta) > MAX_CORNER_ANGLE) {
                        splitIndex = i;
                        break;
                    }
                }
                previousTangent.set(tangent.x, tangent.y);
            }
            if (splitIndex > 0) {
                // split off the valid first path points with a clone of the path
                const firstTextPath = {
                    path: textPath.path.slice(0, splitIndex + 3),
                    text: textPath.text,
                    // Used for placement priorities only, can be kept although it could also be
                    // recomputed
                    pathLengthSqr: textPath.pathLengthSqr,
                    technique: textPath.technique,
                    featureId: textPath.featureId
                };
                processedPaths.push(firstTextPath);
                // setup a second part with the rest of the path points and process again
                const secondTextPath = {
                    path: textPath.path.slice(splitIndex),
                    text: textPath.text,
                    // Used for placement priorities only, can be kept although it could also be
                    // recomputed
                    pathLengthSqr: textPath.pathLengthSqr,
                    technique: textPath.technique,
                    featureId: textPath.featureId
                };
                newPaths.push(secondTextPath);
            }
            else {
                processedPaths.push(textPath);
            }
        }
        return processedPaths;
    }
    /**
     * Creates [[TextElement]] objects from the decoded tile and list of materials specified. The
     * priorities of the [[TextElement]]s are updated to simplify label placement.
     *
     * @param tile The [[Tile]] to create the testElements on.
     * @param decodedTile The [[DecodedTile]].
     */
    createTextElements(tile, decodedTile) {
        const mapView = tile.mapView;
        const displayZoomLevel = Math.floor(mapView.zoomLevel);
        if (decodedTile.textPathGeometries !== undefined) {
            tile.preparedTextPaths = this.prepareTextPaths(tile, decodedTile.textPathGeometries);
            // Compute maximum street length (squared). Longer streets should be labelled first,
            // they have a higher chance of being placed in case the number of text elements is
            // limited.
            let maxPathLengthSqr = 0;
            for (const textPath of tile.preparedTextPaths) {
                const technique = decodedTile.techniques[textPath.technique];
                if (!harp_datasource_protocol_1.isTextTechnique(technique)) {
                    continue;
                }
                if (textPath.pathLengthSqr > maxPathLengthSqr) {
                    maxPathLengthSqr = textPath.pathLengthSqr;
                }
            }
            for (const textPath of tile.preparedTextPaths) {
                const technique = decodedTile.techniques[textPath.technique];
                if (!harp_datasource_protocol_1.isTextTechnique(technique)) {
                    continue;
                }
                const path = [];
                for (let i = 0; i < textPath.path.length; i += 3) {
                    path.push(new THREE.Vector3(textPath.path[i], textPath.path[i + 1], textPath.path[i + 2]));
                }
                // Make sorting stable and make pathLengthSqr a differentiator for placement.
                const priority = harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.priority, displayZoomLevel), 0) +
                    (maxPathLengthSqr > 0
                        ? (SORT_WEIGHT_PATH_LENGTH * textPath.pathLengthSqr) / maxPathLengthSqr
                        : 0);
                const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(textPath.text), path, this.getRenderStyle(tile, technique), this.getLayoutStyle(tile, technique), priority, technique.xOffset !== undefined ? technique.xOffset : 0.0, technique.yOffset !== undefined ? technique.yOffset : 0.0, textPath.featureId, technique.style, harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, displayZoomLevel), harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, displayZoomLevel));
                textElement.minZoomLevel =
                    technique.minZoomLevel !== undefined
                        ? technique.minZoomLevel
                        : mapView.minZoomLevel;
                textElement.maxZoomLevel =
                    technique.maxZoomLevel !== undefined
                        ? technique.maxZoomLevel
                        : mapView.maxZoomLevel;
                textElement.distanceScale =
                    technique.distanceScale !== undefined
                        ? technique.distanceScale
                        : TextElementsRenderer_1.DEFAULT_TEXT_DISTANCE_SCALE;
                textElement.mayOverlap = technique.mayOverlap === true;
                textElement.reserveSpace = technique.reserveSpace !== false;
                tile.addTextElement(textElement);
            }
        }
        if (decodedTile.textGeometries !== undefined) {
            for (const text of decodedTile.textGeometries) {
                if (text.technique === undefined || text.stringCatalog === undefined) {
                    continue;
                }
                const technique = decodedTile.techniques[text.technique];
                if (!harp_datasource_protocol_1.isTextTechnique(technique)) {
                    continue;
                }
                const positions = new THREE.BufferAttribute(new Float32Array(text.positions.buffer), text.positions.itemCount);
                const numPositions = positions.count;
                if (numPositions < 1) {
                    continue;
                }
                const priority = harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.priority, displayZoomLevel), 0);
                for (let i = 0; i < numPositions; ++i) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    const label = text.stringCatalog[text.texts[i]];
                    if (label === undefined) {
                        // skip missing labels
                        continue;
                    }
                    const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), new THREE.Vector3(x, y, z), this.getRenderStyle(tile, technique), this.getLayoutStyle(tile, technique), priority, technique.xOffset || 0.0, technique.yOffset || 0.0, text.featureId, technique.style);
                    textElement.minZoomLevel =
                        technique.minZoomLevel !== undefined
                            ? technique.minZoomLevel
                            : mapView.minZoomLevel;
                    textElement.maxZoomLevel =
                        technique.maxZoomLevel !== undefined
                            ? technique.maxZoomLevel
                            : mapView.maxZoomLevel;
                    textElement.mayOverlap = technique.mayOverlap === true;
                    textElement.reserveSpace = technique.reserveSpace !== false;
                    textElement.fadeNear = harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, displayZoomLevel);
                    textElement.fadeFar = harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, displayZoomLevel);
                    tile.addTextElement(textElement);
                }
            }
        }
    }
    /**
     * Creates `Tile` objects from the decoded tile and list of materials specified.
     *
     * @param tile The [[Tile]] to create the geometry on.
     * @param decodedTile The [[DecodedTile]].
     */
    createObjects(tile, decodedTile) {
        const materials = [];
        const mapView = tile.mapView;
        const dataSource = tile.dataSource;
        const displayZoomLevel = Math.floor(mapView.zoomLevel);
        const objects = tile.objects;
        if (dataSource.addTileBackground) {
            this.addGroundPlane(tile);
        }
        for (const srcGeometry of decodedTile.geometries) {
            const groups = srcGeometry.groups;
            const groupCount = groups.length;
            for (let groupIndex = 0; groupIndex < groupCount;) {
                const group = groups[groupIndex++];
                const start = group.start;
                const techniqueIndex = group.technique;
                const technique = decodedTile.techniques[techniqueIndex];
                let count = group.count;
                // compress consecutive groups
                for (; groupIndex < groupCount && groups[groupIndex].technique === techniqueIndex; ++groupIndex) {
                    if (start + count !== groups[groupIndex].start) {
                        break;
                    }
                    count += groups[groupIndex].count;
                }
                const ObjectCtor = DecodedTileHelpers_1.getObjectConstructor(technique);
                if (ObjectCtor === undefined) {
                    continue;
                }
                let material = materials[techniqueIndex];
                if (material === undefined) {
                    const onMaterialUpdated = (texture) => {
                        dataSource.requestUpdate();
                        if (texture !== undefined) {
                            tile.addOwnedTexture(texture);
                        }
                    };
                    material = DecodedTileHelpers_1.createMaterial({
                        technique,
                        level: displayZoomLevel,
                        fog: mapView.scene.fog !== null
                    }, onMaterialUpdated);
                    if (material === undefined) {
                        continue;
                    }
                    materials[techniqueIndex] = material;
                }
                // Modify the standard textured shader to support height-based coloring.
                if (harp_datasource_protocol_1.isTerrainTechnique(technique) &&
                    technique.heightBasedColors !== undefined &&
                    technique.displacementMap !== undefined) {
                    material.onBeforeCompile = (shader) => {
                        shader.fragmentShader = shader.fragmentShader.replace("#include <map_pars_fragment>", `#include <map_pars_fragment>
    uniform sampler2D displacementMap;
    uniform float displacementScale;
    uniform float displacementBias;`);
                        shader.fragmentShader = shader.fragmentShader.replace("#include <map_fragment>", `#ifdef USE_MAP
    float minElevation = ${harp_geoutils_1.EarthConstants.MIN_ELEVATION.toFixed(1)};
    float maxElevation = ${harp_geoutils_1.EarthConstants.MAX_ELEVATION.toFixed(1)};
    float elevationRange = maxElevation - minElevation;

    float disp = texture2D( displacementMap, vUv ).x * displacementScale + displacementBias;
    vec4 texelColor = texture2D( map, vec2((disp - minElevation) / elevationRange, 0.0) );
    texelColor = mapTexelToLinear( texelColor );
    diffuseColor *= texelColor;
#endif`);
                        // We remove the displacement map from manipulating the vertices, it is
                        // however still required for the pixel shader, so it can't be directly
                        // removed.
                        shader.vertexShader = shader.vertexShader.replace("#include <displacementmap_vertex>", "");
                    };
                }
                const bufferGeometry = new THREE.BufferGeometry();
                srcGeometry.vertexAttributes.forEach((vertexAttribute) => {
                    const buffer = DecodedTileHelpers_1.getBufferAttribute(vertexAttribute);
                    bufferGeometry.addAttribute(vertexAttribute.name, buffer);
                });
                if (srcGeometry.interleavedVertexAttributes !== undefined) {
                    srcGeometry.interleavedVertexAttributes.forEach((attr) => {
                        const ArrayCtor = harp_datasource_protocol_1.getArrayConstructor(attr.type);
                        const buffer = new THREE.InterleavedBuffer(new ArrayCtor(attr.buffer), attr.stride);
                        attr.attributes.forEach((interleavedAttr) => {
                            const attribute = new THREE.InterleavedBufferAttribute(buffer, interleavedAttr.itemSize, interleavedAttr.offset, false);
                            bufferGeometry.addAttribute(interleavedAttr.name, attribute);
                        });
                    });
                }
                if (srcGeometry.index) {
                    bufferGeometry.setIndex(DecodedTileHelpers_1.getBufferAttribute(srcGeometry.index));
                }
                if (!bufferGeometry.getAttribute("normal") && harp_datasource_protocol_1.needsVertexNormals(technique)) {
                    bufferGeometry.computeVertexNormals();
                }
                bufferGeometry.addGroup(start, count);
                if (harp_datasource_protocol_1.isSolidLineTechnique(technique) || harp_datasource_protocol_1.isDashedLineTechnique(technique)) {
                    const lineMaterial = material;
                    lineMaterial.uniforms.opacity.value = material.opacity;
                    if (technique.clipping !== false &&
                        tile.projection.type === harp_geoutils_1.ProjectionType.Planar) {
                        const tileSize = lineMaterial.uniforms.tileSize;
                        const size = new THREE.Vector3();
                        tile.boundingBox.getSize(size);
                        tileSize.value.x = size.x;
                        tileSize.value.y = size.y;
                        lineMaterial.defines.TILE_CLIP = 1;
                    }
                    if (bufferGeometry.getAttribute("color")) {
                        lineMaterial.defines.USE_COLOR = 1;
                    }
                }
                // Add polygon offset to the extruded buildings and to the fill area to avoid depth
                // problems when rendering edges.
                const hasExtrudedOutlines = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && srcGeometry.edgeIndex !== undefined;
                const hasFillOutlines = harp_datasource_protocol_1.isFillTechnique(technique) && srcGeometry.edgeIndex !== undefined;
                if (hasExtrudedOutlines || hasFillOutlines) {
                    material.polygonOffset = true;
                    material.polygonOffsetFactor = 0.75;
                    material.polygonOffsetUnits = 4.0;
                }
                // Add the solid line outlines as a separate object.
                const hasSolidLinesOutlines = harp_datasource_protocol_1.isSolidLineTechnique(technique) && technique.secondaryWidth !== undefined;
                const object = new ObjectCtor(bufferGeometry, material);
                object.frustumCulled = false;
                object.renderOrder = technique.renderOrder;
                if (group.renderOrderOffset !== undefined) {
                    object.renderOrder += group.renderOrderOffset;
                }
                if (srcGeometry.uuid !== undefined) {
                    object.userData.geometryId = srcGeometry.uuid;
                }
                if ((harp_datasource_protocol_1.isCirclesTechnique(technique) || harp_datasource_protocol_1.isSquaresTechnique(technique)) &&
                    technique.enablePicking !== undefined) {
                    // tslint:disable-next-line:max-line-length
                    object.enableRayTesting = technique.enablePicking;
                }
                if (harp_datasource_protocol_1.isLineTechnique(technique) || harp_datasource_protocol_1.isSegmentsTechnique(technique)) {
                    if (harp_datasource_protocol_1.isInterpolatedProperty(technique.color)) {
                        const fadingParams = this.getFadingParams(displayZoomLevel, technique);
                        harp_materials_1.FadingFeature.addRenderHelper(object, fadingParams.fadeNear, fadingParams.fadeFar, false, false, (renderer, mat) => {
                            const lineMaterial = mat;
                            lineMaterial.color.set(harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.color, mapView.zoomLevel), "#000000"));
                        });
                    }
                }
                // Lines renderOrder fix: Render them as transparent objects, but make sure they end
                // up in the opaque rendering queue (by disabling transparency onAfterRender, and
                // enabling it onBeforeRender).
                if (harp_datasource_protocol_1.isSolidLineTechnique(technique) || harp_datasource_protocol_1.isDashedLineTechnique(technique)) {
                    const fadingParams = this.getFadingParams(displayZoomLevel, technique);
                    harp_materials_1.FadingFeature.addRenderHelper(object, fadingParams.fadeNear, fadingParams.fadeFar, true, false, (renderer, mat) => {
                        const lineMaterial = mat;
                        const metricUnits = harp_datasource_protocol_1.getPropertyValue(technique.metricUnit, tile.tileKey.level);
                        const unitFactor = metricUnits === "Pixel" ? mapView.pixelToWorld * 0.5 : 1.0;
                        lineMaterial.color.set(harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.color, mapView.zoomLevel), "#000000"));
                        lineMaterial.lineWidth =
                            harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.lineWidth, mapView.zoomLevel), harp_materials_1.SolidLineMaterial.DEFAULT_WIDTH) * unitFactor;
                        // Do the same for dashSize and gapSize for dashed lines.
                        if (harp_datasource_protocol_1.isDashedLineTechnique(technique)) {
                            const dashedLineMaterial = lineMaterial;
                            dashedLineMaterial.dashSize =
                                harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.dashSize, mapView.zoomLevel), harp_materials_1.DashedLineMaterial.DEFAULT_DASH_SIZE) * unitFactor;
                            dashedLineMaterial.gapSize =
                                harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.gapSize, mapView.zoomLevel), harp_materials_1.DashedLineMaterial.DEFAULT_GAP_SIZE) * unitFactor;
                        }
                    });
                }
                if (harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {
                    // extruded lines are normal meshes, and need transparency only when fading or
                    // dynamic properties is defined.
                    if (technique.fadeFar !== undefined ||
                        harp_datasource_protocol_1.isInterpolatedProperty(technique.color)) {
                        const fadingParams = this.getFadingParams(displayZoomLevel, technique);
                        harp_materials_1.FadingFeature.addRenderHelper(object, fadingParams.fadeNear, fadingParams.fadeFar, true, true, harp_datasource_protocol_1.isInterpolatedProperty(technique.color)
                            ? (renderer, mat) => {
                                const extrudedMaterial = mat;
                                extrudedMaterial.color.set(harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.color, mapView.zoomLevel), "#000000"));
                            }
                            : undefined);
                    }
                }
                this.addFeatureData(srcGeometry, technique, object);
                this.addGeometryObjInfos(srcGeometry, object);
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) || harp_datasource_protocol_1.isFillTechnique(technique)) {
                    // filled polygons are normal meshes, and need transparency only when fading or
                    // dynamic properties is defined.
                    const hasDynamicColor = harp_datasource_protocol_1.isInterpolatedProperty(technique.color) ||
                        (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) &&
                            harp_datasource_protocol_1.isInterpolatedProperty(technique.emissive));
                    if (technique.fadeFar !== undefined || hasDynamicColor) {
                        const fadingParams = this.getFadingParams(displayZoomLevel, technique);
                        harp_materials_1.FadingFeature.addRenderHelper(object, fadingParams.fadeNear, fadingParams.fadeFar, true, true, hasDynamicColor
                            ? (renderer, mat) => {
                                const polygonMaterial = mat;
                                polygonMaterial.color.set(harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.color, mapView.zoomLevel), "#000000"));
                                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
                                    const standardMat = mat;
                                    standardMat.emissive.set(harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.emissive, mapView.zoomLevel), "#000000"));
                                }
                            }
                            : undefined);
                    }
                }
                const extrudedObjects = [];
                const animatedExtrusionHandler = mapView.animatedExtrusionHandler;
                let extrusionAnimationEnabled = false;
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) &&
                    animatedExtrusionHandler !== undefined) {
                    let animateExtrusionValue = harp_datasource_protocol_1.getPropertyValue(technique.animateExtrusion, displayZoomLevel);
                    if (animateExtrusionValue !== undefined) {
                        animateExtrusionValue =
                            typeof animateExtrusionValue === "boolean"
                                ? animateExtrusionValue
                                : typeof animateExtrusionValue === "number"
                                    ? animateExtrusionValue !== 0
                                    : false;
                    }
                    extrusionAnimationEnabled =
                        animateExtrusionValue !== undefined &&
                            animatedExtrusionHandler.forceEnabled === false
                            ? animateExtrusionValue
                            : animatedExtrusionHandler.enabled;
                }
                const renderDepthPrePass = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && DepthPrePass_1.isRenderDepthPrePassEnabled(technique);
                if (renderDepthPrePass) {
                    const depthPassMesh = DepthPrePass_1.createDepthPrePassMesh(object);
                    objects.push(depthPassMesh);
                    if (extrusionAnimationEnabled) {
                        extrudedObjects.push({
                            object: depthPassMesh,
                            materialFeature: true
                        });
                    }
                    DepthPrePass_1.setDepthPrePassStencil(depthPassMesh, object);
                }
                this.registerTileObject(tile, object);
                objects.push(object);
                // Add the extruded building edges as a separate geometry.
                if (hasExtrudedOutlines) {
                    const edgeGeometry = new THREE.BufferGeometry();
                    edgeGeometry.addAttribute("position", bufferGeometry.getAttribute("position"));
                    const colorAttribute = bufferGeometry.getAttribute("color");
                    if (colorAttribute !== undefined) {
                        edgeGeometry.addAttribute("color", colorAttribute);
                    }
                    const extrusionAttribute = bufferGeometry.getAttribute("extrusionAxis");
                    if (extrusionAttribute !== undefined) {
                        edgeGeometry.addAttribute("extrusionAxis", extrusionAttribute);
                    }
                    edgeGeometry.setIndex(DecodedTileHelpers_1.getBufferAttribute(srcGeometry.edgeIndex));
                    // Read the uniforms from the technique values (and apply the default values).
                    const extrudedPolygonTechnique = technique;
                    const fadingParams = this.getPolygonFadingParams(displayZoomLevel, extrudedPolygonTechnique);
                    // Configure the edge material based on the theme values.
                    const materialParams = {
                        color: fadingParams.color,
                        colorMix: fadingParams.colorMix,
                        fadeNear: fadingParams.lineFadeNear,
                        fadeFar: fadingParams.lineFadeFar
                    };
                    const edgeMaterial = new harp_materials_1.EdgeMaterial(materialParams);
                    const edgeObj = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                    // Set the correct render order.
                    edgeObj.renderOrder = object.renderOrder + 0.1;
                    harp_materials_1.FadingFeature.addRenderHelper(edgeObj, fadingParams.lineFadeNear, fadingParams.lineFadeFar, false, false, harp_datasource_protocol_1.isInterpolatedProperty(extrudedPolygonTechnique.lineColor)
                        ? (renderer, mat) => {
                            edgeMaterial.color.set(harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(extrudedPolygonTechnique.lineColor, mapView.zoomLevel), "#000000"));
                        }
                        : undefined);
                    if (extrusionAnimationEnabled) {
                        extrudedObjects.push({
                            object: edgeObj,
                            materialFeature: false
                        });
                    }
                    this.registerTileObject(tile, edgeObj);
                    objects.push(edgeObj);
                }
                // animate the extrusion of buildings
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && extrusionAnimationEnabled) {
                    extrudedObjects.push({
                        object,
                        materialFeature: true
                    });
                    const extrusionAnimationDuration = technique.animateExtrusionDuration !== undefined &&
                        animatedExtrusionHandler.forceEnabled === false
                        ? technique.animateExtrusionDuration
                        : animatedExtrusionHandler.duration;
                    tile.animatedExtrusionTileHandler = new AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler(tile, extrudedObjects, extrusionAnimationDuration);
                    mapView.animatedExtrusionHandler.add(tile.animatedExtrusionTileHandler);
                }
                // Add the fill area edges as a separate geometry.
                if (hasFillOutlines) {
                    const outlineGeometry = new THREE.BufferGeometry();
                    outlineGeometry.addAttribute("position", bufferGeometry.getAttribute("position"));
                    outlineGeometry.setIndex(DecodedTileHelpers_1.getBufferAttribute(srcGeometry.edgeIndex));
                    const fillTechnique = technique;
                    const fadingParams = this.getPolygonFadingParams(displayZoomLevel, fillTechnique);
                    // Configure the edge material based on the theme values.
                    const materialParams = {
                        color: fadingParams.color,
                        colorMix: fadingParams.colorMix,
                        fadeNear: fadingParams.lineFadeNear,
                        fadeFar: fadingParams.lineFadeFar
                    };
                    const outlineMaterial = new harp_materials_1.EdgeMaterial(materialParams);
                    const outlineObj = new THREE.LineSegments(outlineGeometry, outlineMaterial);
                    outlineObj.renderOrder = object.renderOrder + 0.1;
                    harp_materials_1.FadingFeature.addRenderHelper(outlineObj, fadingParams.lineFadeNear, fadingParams.lineFadeFar, true, false, harp_datasource_protocol_1.isInterpolatedProperty(fillTechnique.lineColor)
                        ? (renderer, mat) => {
                            const edgeMaterial = mat;
                            edgeMaterial.color.set(harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(fillTechnique.lineColor, mapView.zoomLevel), "#000000"));
                        }
                        : undefined);
                    this.registerTileObject(tile, outlineObj);
                    objects.push(outlineObj);
                }
                // Add the fill area edges as a separate geometry.
                if (hasSolidLinesOutlines) {
                    const outlineTechnique = technique;
                    const outlineMaterial = material.clone();
                    const outlineColor = ColorCache_1.ColorCache.instance.getColor(harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(outlineTechnique.secondaryColor, displayZoomLevel), "#000000"));
                    outlineMaterial.uniforms.diffuse.value = outlineColor;
                    const outlineObj = new ObjectCtor(bufferGeometry, outlineMaterial);
                    outlineObj.renderOrder =
                        outlineTechnique.secondaryRenderOrder !== undefined
                            ? outlineTechnique.secondaryRenderOrder
                            : technique.renderOrder - 0.0000001;
                    if (group.renderOrderOffset !== undefined) {
                        outlineObj.renderOrder += group.renderOrderOffset;
                    }
                    const fadingParams = this.getFadingParams(displayZoomLevel, technique);
                    harp_materials_1.FadingFeature.addRenderHelper(outlineObj, fadingParams.fadeNear, fadingParams.fadeFar, true, false, (renderer, mat) => {
                        const lineMaterial = mat;
                        const metricUnits = harp_datasource_protocol_1.getPropertyValue(outlineTechnique.metricUnit, tile.tileKey.level);
                        const unitFactor = metricUnits === "Pixel" ? mapView.pixelToWorld * 0.5 : 1.0;
                        lineMaterial.color.set(harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(outlineTechnique.secondaryColor, mapView.zoomLevel), "#000000"));
                        lineMaterial.lineWidth =
                            harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(outlineTechnique.secondaryWidth, mapView.zoomLevel), harp_materials_1.SolidLineMaterial.DEFAULT_WIDTH) * unitFactor;
                    });
                    this.registerTileObject(tile, outlineObj);
                    objects.push(outlineObj);
                }
            }
        }
    }
    /**
     * Prepare the [[Tile]]s pois. Uses the [[PoiManager]] in [[MapView]].
     */
    preparePois(tile, decodedTile) {
        if (decodedTile.poiGeometries !== undefined) {
            tile.mapView.poiManager.addPois(tile, decodedTile);
        }
    }
    /**
     * Gets the appropriate [[TextRenderStyle]] to use for a label. Depends heavily on the label's
     * [[Technique]] and the current zoomLevel.
     *
     * @param technique Label's technique.
     * @param techniqueIdx Label's technique index.
     */
    getRenderStyle(tile, technique) {
        const mapView = tile.mapView;
        const dataSource = tile.dataSource;
        const zoomLevel = mapView.zoomLevel;
        const cacheId = TextStyleCache_1.computeStyleCacheId(dataSource.name, technique, Math.floor(zoomLevel));
        let renderStyle = mapView.textRenderStyleCache.get(cacheId);
        if (renderStyle === undefined) {
            const defaultRenderParams = mapView.textElementsRenderer !== undefined
                ? mapView.textElementsRenderer.defaultStyle.renderParams
                : {
                    fontSize: {
                        unit: harp_text_canvas_1.FontUnit.Pixel,
                        size: 32,
                        backgroundSize: 8
                    }
                };
            const hexColor = harp_datasource_protocol_1.getPropertyValue(technique.color, Math.floor(zoomLevel));
            if (hexColor !== undefined) {
                TileGeometryCreator.m_colorMap.set(cacheId, ColorCache_1.ColorCache.instance.getColor(hexColor));
            }
            const hexBgColor = harp_datasource_protocol_1.getPropertyValue(technique.backgroundColor, Math.floor(zoomLevel));
            if (hexBgColor !== undefined) {
                TileGeometryCreator.m_colorMap.set(cacheId + "_bg", ColorCache_1.ColorCache.instance.getColor(hexBgColor));
            }
            const renderParams = {
                fontName: harp_utils_1.getOptionValue(technique.fontName, defaultRenderParams.fontName),
                fontSize: {
                    unit: harp_text_canvas_1.FontUnit.Pixel,
                    size: harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.size, Math.floor(zoomLevel)), defaultRenderParams.fontSize.size),
                    backgroundSize: harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.backgroundSize, Math.floor(zoomLevel)), defaultRenderParams.fontSize.backgroundSize)
                },
                fontStyle: technique.fontStyle === "Regular" ||
                    technique.fontStyle === "Bold" ||
                    technique.fontStyle === "Italic" ||
                    technique.fontStyle === "BoldItalic"
                    ? harp_text_canvas_1.FontStyle[technique.fontStyle]
                    : defaultRenderParams.fontStyle,
                fontVariant: technique.fontVariant === "Regular" ||
                    technique.fontVariant === "AllCaps" ||
                    technique.fontVariant === "SmallCaps"
                    ? harp_text_canvas_1.FontVariant[technique.fontVariant]
                    : defaultRenderParams.fontVariant,
                rotation: harp_utils_1.getOptionValue(technique.rotation, defaultRenderParams.rotation),
                color: harp_utils_1.getOptionValue(TileGeometryCreator.m_colorMap.get(cacheId), defaultRenderParams.color),
                backgroundColor: harp_utils_1.getOptionValue(TileGeometryCreator.m_colorMap.get(cacheId + "_bg"), defaultRenderParams.backgroundColor),
                opacity: harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.opacity, Math.floor(zoomLevel)), defaultRenderParams.opacity),
                backgroundOpacity: harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.backgroundOpacity, Math.floor(zoomLevel)), defaultRenderParams.backgroundOpacity)
            };
            const themeRenderParams = mapView.textElementsRenderer !== undefined
                ? mapView.textElementsRenderer.getTextElementStyle(technique.style)
                    .renderParams
                : {};
            renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign({}, themeRenderParams, renderParams));
            mapView.textRenderStyleCache.set(cacheId, renderStyle);
        }
        return renderStyle;
    }
    /**
     * Gets the appropriate [[TextRenderStyle]] to use for a label. Depends heavily on the label's
     * [[Technique]] and the current zoomLevel.
     *
     * @param tile The [[Tile]] to process.
     * @param technique Label's technique.
     */
    getLayoutStyle(tile, technique) {
        const mapView = tile.mapView;
        const dataSource = tile.dataSource;
        const zoomLevel = mapView.zoomLevel;
        const cacheId = TextStyleCache_1.computeStyleCacheId(dataSource.name, technique, Math.floor(zoomLevel));
        let layoutStyle = mapView.textLayoutStyleCache.get(cacheId);
        if (layoutStyle === undefined) {
            const defaultLayoutParams = mapView.textElementsRenderer !== undefined
                ? mapView.textElementsRenderer.defaultStyle.layoutParams
                : {};
            const layoutParams = {
                tracking: harp_utils_1.getOptionValue(technique.tracking, defaultLayoutParams.tracking),
                leading: harp_utils_1.getOptionValue(technique.leading, defaultLayoutParams.leading),
                maxLines: harp_utils_1.getOptionValue(technique.maxLines, defaultLayoutParams.maxLines),
                lineWidth: harp_utils_1.getOptionValue(technique.lineWidth, defaultLayoutParams.lineWidth),
                canvasRotation: harp_utils_1.getOptionValue(technique.canvasRotation, defaultLayoutParams.canvasRotation),
                lineRotation: harp_utils_1.getOptionValue(technique.lineRotation, defaultLayoutParams.lineRotation),
                wrappingMode: technique.wrappingMode === "None" ||
                    technique.wrappingMode === "Character" ||
                    technique.wrappingMode === "Word"
                    ? harp_text_canvas_1.WrappingMode[technique.wrappingMode]
                    : defaultLayoutParams.wrappingMode,
                horizontalAlignment: technique.hAlignment === "Left" ||
                    technique.hAlignment === "Center" ||
                    technique.hAlignment === "Right"
                    ? harp_text_canvas_1.HorizontalAlignment[technique.hAlignment]
                    : defaultLayoutParams.horizontalAlignment,
                verticalAlignment: technique.vAlignment === "Above" ||
                    technique.vAlignment === "Center" ||
                    technique.vAlignment === "Below"
                    ? harp_text_canvas_1.VerticalAlignment[technique.vAlignment]
                    : defaultLayoutParams.verticalAlignment
            };
            const themeLayoutParams = mapView.textElementsRenderer !== undefined
                ? mapView.textElementsRenderer.getTextElementStyle(technique.style)
                    .layoutParams
                : {};
            layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign({}, themeLayoutParams, layoutParams));
            mapView.textLayoutStyleCache.set(cacheId, layoutStyle);
        }
        return layoutStyle;
    }
    /**
     * Creates and add a background plane for the tile.
     */
    addGroundPlane(tile) {
        const mapView = tile.mapView;
        const dataSource = tile.dataSource;
        const projection = tile.projection;
        const color = dataSource.tileBackgroundColor === undefined
            ? mapView.clearColor
            : dataSource.tileBackgroundColor;
        if (tile.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            const { east, west, north, south } = tile.geoBox;
            const sourceProjection = dataSource.getTilingScheme().projection;
            const g = new THREE.Geometry();
            g.vertices.push(sourceProjection.projectPoint(new harp_geoutils_1.GeoCoordinates(south, west), new THREE.Vector3()), sourceProjection.projectPoint(new harp_geoutils_1.GeoCoordinates(south, east), new THREE.Vector3()), sourceProjection.projectPoint(new harp_geoutils_1.GeoCoordinates(north, west), new THREE.Vector3()), sourceProjection.projectPoint(new harp_geoutils_1.GeoCoordinates(north, east), new THREE.Vector3()));
            g.faces.push(new THREE.Face3(0, 1, 2), new THREE.Face3(2, 1, 3));
            const modifier = new SphericalGeometrySubdivisionModifier_1.SphericalGeometrySubdivisionModifier(THREE.Math.degToRad(10), sourceProjection);
            modifier.modify(g);
            g.vertices.forEach(v => {
                projection.reprojectPoint(sourceProjection, v, v);
                v.sub(tile.center);
            });
            const material = new harp_materials_1.MapMeshBasicMaterial({
                color,
                visible: dataSource.tileBackgroundIsVisible
            });
            const bufferGeometry = new THREE.BufferGeometry();
            bufferGeometry.fromGeometry(g);
            const mesh = new THREE.Mesh(bufferGeometry, material);
            mesh.renderOrder = Number.MIN_SAFE_INTEGER;
            this.registerTileObject(tile, mesh);
            tile.objects.push(mesh);
        }
        else {
            // Add a ground plane to the tile.
            const planeSize = new THREE.Vector3();
            tile.boundingBox.getSize(planeSize);
            const groundPlane = this.createPlane(planeSize.x, planeSize.y, tile.center, color, dataSource.tileBackgroundIsVisible);
            this.registerTileObject(tile, groundPlane);
            tile.objects.push(groundPlane);
        }
    }
    /**
     * Create a simple flat plane for a [[Tile]].
     *
     * @param {number} width Width of plane.
     * @param {number} height Height of plane.
     * @param {THREE.Vector3} planeCenter Center of plane.
     * @param {number} colorHex Color of the plane mesh.
     * @param {boolean} isVisible `True` to make the mesh visible.
     * @returns {THREE.Mesh} The created plane.
     */
    createPlane(width, height, planeCenter, colorHex, isVisible) {
        const geometry = new THREE.PlaneGeometry(width, height, 1);
        // TODO cache the material HARP-4207
        const material = new harp_materials_1.MapMeshBasicMaterial({
            color: colorHex,
            visible: isVisible
        });
        const plane = new THREE.Mesh(geometry, material);
        plane.position.copy(planeCenter);
        // Render before everything else
        plane.renderOrder = Number.MIN_SAFE_INTEGER;
        return plane;
    }
    /**
     * Pass the feature data on to the object, so it can be used in picking
     * `MapView.intersectMapObjects()`. Do not pass the feature data if the technique is a
     * dashed-line or a solid-line, because the line picking functionality for the lines is not
     * object based, but tile based.
     *
     * @param srcGeometry The original [[Geometry]].
     * @param technique The corresponding [[Technique]].
     * @param object The object to pass info to.
     */
    addFeatureData(srcGeometry, technique, object) {
        if (((srcGeometry.featureIds !== undefined && srcGeometry.featureIds.length > 0) ||
            harp_datasource_protocol_1.isCirclesTechnique(technique) ||
            harp_datasource_protocol_1.isSquaresTechnique(technique)) &&
            !harp_datasource_protocol_1.isSolidLineTechnique(technique) &&
            !harp_datasource_protocol_1.isDashedLineTechnique(technique)) {
            const featureData = {
                geometryType: srcGeometry.type,
                ids: srcGeometry.featureIds,
                starts: srcGeometry.featureStarts
            };
            object.userData.feature = featureData;
            if (srcGeometry.objInfos !== undefined) {
                object.userData.feature.objInfos = srcGeometry.objInfos;
            }
        }
    }
    addGeometryObjInfos(srcGeometry, object) {
        if (srcGeometry.objInfos !== undefined && Object.keys(object.userData).length === 0) {
            object.userData = srcGeometry.objInfos;
        }
    }
    /**
     * Gets the fading parameters for several kinds of objects.
     */
    getFadingParams(displayZoomLevel, technique) {
        const fadeNear = technique.fadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, displayZoomLevel)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR;
        const fadeFar = technique.fadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, displayZoomLevel)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR;
        return {
            fadeNear,
            fadeFar
        };
    }
    /**
     * Gets the fading parameters for several kinds of objects.
     */
    getPolygonFadingParams(displayZoomLevel, technique) {
        let color;
        let colorMix = harp_materials_1.EdgeMaterial.DEFAULT_COLOR_MIX;
        if (technique.lineColor !== undefined) {
            color = harp_datasource_protocol_1.getPropertyValue(technique.lineColor, displayZoomLevel);
            if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
                const extrudedPolygonTechnique = technique;
                colorMix =
                    extrudedPolygonTechnique.lineColorMix !== undefined
                        ? extrudedPolygonTechnique.lineColorMix
                        : harp_materials_1.EdgeMaterial.DEFAULT_COLOR_MIX;
            }
        }
        const fadeNear = technique.fadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, displayZoomLevel)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR;
        const fadeFar = technique.fadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, displayZoomLevel)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR;
        const lineFadeNear = technique.lineFadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.lineFadeNear, displayZoomLevel)
            : fadeNear;
        const lineFadeFar = technique.lineFadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.lineFadeFar, displayZoomLevel)
            : fadeFar;
        if (color === undefined) {
            color = harp_materials_1.EdgeMaterial.DEFAULT_COLOR;
        }
        return {
            color,
            colorMix,
            fadeNear,
            fadeFar,
            lineFadeNear,
            lineFadeFar
        };
    }
}
/**
 * Cache for named colors.
 */
TileGeometryCreator.m_colorMap = new Map();
exports.TileGeometryCreator = TileGeometryCreator;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryLoader.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileGeometryLoader.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const Statistics_1 = __webpack_require__(/*! ../Statistics */ "./node_modules/@here/harp-mapview/lib/Statistics.js");
const TileGeometryCreator_1 = __webpack_require__(/*! ./TileGeometryCreator */ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js");
/**
 * Simplest implementation of a [[TileGeometryLoader]]. It loads all geometry in a single step.
 */
class SimpleTileGeometryLoader {
    constructor(m_tile) {
        this.m_tile = m_tile;
        this.m_isFinished = false;
    }
    get tile() {
        return this.m_tile;
    }
    get isFinished() {
        return this.m_isFinished;
    }
    get basicGeometryLoaded() {
        return this.m_tile.hasGeometry;
    }
    get allGeometryLoaded() {
        return this.m_isFinished;
    }
    setDecodedTile(decodedTile) {
        this.m_decodedTile = this.m_tile.decodedTile;
    }
    update() {
        if (this.m_decodedTile === undefined && this.m_tile.decodedTile !== undefined) {
            this.setDecodedTile(this.m_tile.decodedTile);
            this.prepareForRender();
            this.finish();
        }
    }
    dispose() {
        this.m_decodedTile = undefined;
    }
    finish() {
        this.m_tile.removeDecodedTile();
        this.m_isFinished = true;
    }
    /**
     * Called by [[VisibleTileSet]] to mark that [[Tile]] is visible and it should prepare geometry.
     */
    prepareForRender() {
        // If the tile is not ready for display, or if it has become invisible while being loaded,
        // for example by moving the camera, the tile is not finished and its geometry is not
        // created. This is an optimization for fast camera movements and zooms.
        const tile = this.tile;
        const decodedTile = this.m_decodedTile;
        this.m_decodedTile = undefined;
        if (decodedTile === undefined || tile.disposed || !tile.isVisible) {
            return;
        }
        setTimeout(() => {
            const stats = Statistics_1.PerformanceStatistics.instance;
            // If the tile has become invisible while being loaded, for example by moving the
            // camera, the tile is not finished and its geometry is not created. This is an
            // optimization for fast camera movements and zooms.
            if (!tile.isVisible) {
                // Dispose the tile from the visible set, so it can be reloaded properly next time
                // it is needed.
                tile.mapView.visibleTileSet.disposeTile(tile);
                if (stats.enabled) {
                    stats.currentFrame.addMessage(
                    // tslint:disable-next-line: max-line-length
                    `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row} DISCARDED - invisible`);
                }
                return;
            }
            let now = 0;
            if (stats.enabled) {
                now = harp_utils_1.PerformanceTimer.now();
            }
            const geometryCreator = new TileGeometryCreator_1.TileGeometryCreator();
            geometryCreator.initDecodedTile(decodedTile);
            geometryCreator.createAllGeometries(tile, decodedTile);
            if (stats.enabled) {
                const geometryCreationTime = harp_utils_1.PerformanceTimer.now() - now;
                const currentFrame = stats.currentFrame;
                currentFrame.addValue("geometry.geometryCreationTime", geometryCreationTime);
                currentFrame.addValue("geometryCount.numGeometries", decodedTile.geometries.length);
                currentFrame.addValue("geometryCount.numTechniques", decodedTile.techniques.length);
                currentFrame.addValue("geometryCount.numPoiGeometries", decodedTile.poiGeometries !== undefined ? decodedTile.poiGeometries.length : 0);
                currentFrame.addValue("geometryCount.numTextGeometries", decodedTile.textGeometries !== undefined ? decodedTile.textGeometries.length : 0);
                currentFrame.addValue("geometryCount.numTextPathGeometries", decodedTile.textPathGeometries !== undefined
                    ? decodedTile.textPathGeometries.length
                    : 0);
                currentFrame.addMessage(
                // tslint:disable-next-line: max-line-length
                `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row}`);
            }
            this.finish();
            tile.dataSource.requestUpdate();
        }, 0);
    }
}
exports.SimpleTileGeometryLoader = SimpleTileGeometryLoader;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryManager.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileGeometryManager.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const TileGeometryLoader_1 = __webpack_require__(/*! ./TileGeometryLoader */ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryLoader.js");
/**
 * Base class for all [[TileGeometryManager]]s.
 */
class TileGeometryManagerBase {
    /**
     * Creates an instance of `TileGeometryManagerBase` with a reference to the [[MapView]].
     */
    constructor(mapView) {
        this.mapView = mapView;
    }
}
exports.TileGeometryManagerBase = TileGeometryManagerBase;
/**
 * Implements the simplest for of [[TileGeometryManager]]. Uses a [[SimpleTileGeometryLoader]] to
 * load the geometries of the [[Tile]].
 */
class SimpleTileGeometryManager extends TileGeometryManagerBase {
    /**
     * Creates an instance of `SimpleTileGeometryManager` with a reference to the [[MapView]].
     */
    constructor(mapView) {
        super(mapView);
    }
    initTile(tile) {
        tile.tileGeometryLoader = new TileGeometryLoader_1.SimpleTileGeometryLoader(tile);
    }
    updateTiles(tiles) {
        for (const tile of tiles) {
            const geometryLoader = tile.tileGeometryLoader;
            if (geometryLoader !== undefined) {
                geometryLoader.update();
            }
        }
    }
}
exports.SimpleTileGeometryManager = SimpleTileGeometryManager;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/image/Image.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/image/Image.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ImageItem;
(function (ImageItem) {
    /**
     * Missing Typedoc
     */
    function isLoading(imageItem) {
        return imageItem.loadingPromise !== undefined;
    }
    ImageItem.isLoading = isLoading;
})(ImageItem = exports.ImageItem || (exports.ImageItem = {}));


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/image/ImageCache.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/image/ImageCache.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const logger = harp_utils_1.LoggerManager.instance.create("ImageCache");
/**
 * Combines an [[ImageItem]] with a list of [[MapViews]] that reference it.
 */
class ImageCacheItem {
    /**
     * Instantiates `ImageCacheItem`.
     *
     * @param imageItem The [[ImageItem]] referenced by the associated [[MapView]]s instances.
     * @param mapView An optional first [[MapView]] referencing the [[ImageItem]].
     */
    constructor(imageItem, mapView) {
        this.imageItem = imageItem;
        /**
         * The list of [[MapView]]s referencing the [[ImageItem]].
         */
        this.mapViews = [];
        if (mapView !== undefined) {
            this.mapViews.push(mapView);
        }
    }
}
/**
 * `ImageCache` is a singleton, so it can be used with multiple MapViews on a single page. This
 * allows to have an image loaded only once for multiple views. THREE is doing something similar,
 * but does not allow to share images that have been loaded from a canvas (which we may need to do
 * if we use SVG images for textures).
 *
 * One application that makes our own cache necessary is the generation of our own textures from
 * data that is not an URL.
 *
 * The `ImageCache` can be improved by adding satistics for memory footprint as well.
 */
class ImageCache {
    constructor() {
        this.m_images = new Map();
    }
    /**
     * Returns the singleton `instance` of the `ImageCache`.
     */
    static get instance() {
        if (ImageCache.m_instance === undefined) {
            ImageCache.m_instance = new ImageCache();
        }
        return ImageCache.m_instance;
    }
    /**
     * Dispose the singleton object. Not normally implemented for singletons, but good for
     * debugging.
     */
    static dispose() {
        ImageCache.m_instance = undefined;
    }
    /**
     * Add an image definition to the global cache. Useful when the image data is already loaded.
     *
     * @param mapView Specifiy which [[MapView]] requests the image.
     * @param url URL of image.
     * @param imageData Optional [ImageData]] containing the image content.
     */
    registerImage(mapView, url, imageData) {
        let imageCacheItem = this.findImageCacheItem(url);
        if (imageCacheItem !== undefined) {
            if (mapView !== undefined && imageCacheItem.mapViews.indexOf(mapView) < 0) {
                imageCacheItem.mapViews.push(mapView);
            }
            return imageCacheItem.imageItem;
        }
        imageCacheItem = this.findImageCacheItem(url);
        if (imageCacheItem !== undefined) {
            if (mapView !== undefined && imageCacheItem.mapViews.indexOf(mapView) < 0) {
                imageCacheItem.mapViews.push(mapView);
            }
            return imageCacheItem.imageItem;
        }
        const mapViews = [];
        if (mapView !== undefined) {
            mapViews.push(mapView);
        }
        imageCacheItem = {
            imageItem: {
                url,
                imageData,
                loaded: false
            },
            mapViews
        };
        this.m_images.set(url, imageCacheItem);
        return imageCacheItem.imageItem;
    }
    /**
     * Add an image definition, and optionally start loading the content.
     *
     * @param mapView [[MapView]] requesting the image.
     * @param url URL of image.
     * @param startLoading Optional flag. If `true` the image will be loaded in the background.
     */
    addImage(mapView, url, startLoading = true) {
        const imageItem = this.registerImage(mapView, url, undefined);
        if (imageItem !== undefined && startLoading === true) {
            return this.loadImage(imageItem);
        }
        return imageItem;
    }
    /**
     * Find [[ImageItem]] for the specified URL.
     *
     * @param url URL of image.
     * @returns `ImageItem` for the URL if the URL is registered, `undefined` otherwise.
     */
    findImage(url) {
        const imageItem = this.m_images.get(url);
        if (imageItem !== undefined) {
            return imageItem.imageItem;
        }
        return undefined;
    }
    /**
     * Clear all [[ImageItem]]s belonging to a [[MapView]]. May remove cached items if no
     * [[MapView]] are registered anymore.
     *
     * @param mapView MapView to remove all [[ImageItem]]s from.
     */
    clear(mapView) {
        const itemsToRemove = [];
        this.m_images.forEach(imageItem => {
            const mapViewIndex = imageItem.mapViews.indexOf(mapView);
            if (mapViewIndex >= 0) {
                imageItem.mapViews.splice(mapViewIndex, 1);
            }
            if (imageItem.mapViews.length === 0) {
                itemsToRemove.push(imageItem.imageItem.url);
            }
        });
        for (const keyToDelete of itemsToRemove) {
            this.m_images.delete(keyToDelete);
        }
    }
    /**
     * Clear all [[ImageItem]]s from all [[MapView]]s.
     */
    clearAll() {
        this.m_images = new Map();
    }
    /**
     * Returns the number of all cached [[ImageItem]]s.
     */
    get size() {
        return this.m_images.size;
    }
    /**
     * Load an [[ImageItem]]. If the loading process is already running, it returns the current
     * promise.
     *
     * @param imageItem `ImageItem` containing the URL to load image from.
     * @returns An [[ImageItem]] if the image has already been loaded, a promise otherwise.
     */
    loadImage(imageItem) {
        if (imageItem.imageData !== undefined) {
            return imageItem;
        }
        if (imageItem.loadingPromise !== undefined) {
            return imageItem.loadingPromise;
        }
        const imageLoader = new THREE.ImageLoader();
        imageItem.loadingPromise = new Promise(resolve => {
            logger.log(`Loading image: ${imageItem.url}`);
            imageLoader.load(imageItem.url, image => {
                logger.log(`... finished loading image: ${imageItem.url}`);
                this.renderImage(imageItem, image)
                    .then(() => {
                    imageItem.loadingPromise = undefined;
                    resolve(imageItem);
                })
                    .catch(ex => {
                    logger.error(`... loading image failed: ${imageItem.url} : ${ex}`);
                    resolve(undefined);
                });
            }, 
            // Loading events no longer supported
            undefined, errorEvent => {
                logger.error(`... loading image failed: ${imageItem.url} : ${errorEvent}`);
                imageItem.loadingPromise = undefined;
                resolve(undefined);
            });
        });
        return imageItem.loadingPromise;
    }
    /**
     * Find the cached [[ImageItem]] by URL.
     *
     * @param url URL of image.
     */
    findImageCacheItem(url) {
        return this.m_images.get(url);
    }
    /**
     * Render the `ImageItem` by using `createImageBitmap()` or by rendering the image into a
     * [[HTMLCanvasElement]].
     *
     * @param imageItem [[ImageItem]] to assign image data to.
     * @param image [[HTMLImageElement]] to
     */
    renderImage(imageItem, image) {
        return new Promise((resolve, reject) => {
            // use createImageBitmap if it is available. It should be available in webworkers as
            // well
            if (typeof createImageBitmap === "function") {
                const options = {
                    premultiplyAlpha: "default",
                    imageOrientation: "flipY"
                };
                logger.log(`Creating bitmap image: ${imageItem.url}`);
                createImageBitmap(image, 0, 0, image.width, image.height, options)
                    .then(imageBitmap => {
                    logger.log(`... finished creating bitmap image: ${imageItem.url}`);
                    imageItem.loadingPromise = undefined;
                    imageItem.imageData = imageBitmap;
                    imageItem.loaded = true;
                    resolve(imageBitmap);
                })
                    .catch(ex => {
                    logger.error(`... loading image failed: ${imageItem.url} : ${ex}`);
                    resolve(undefined);
                });
            }
            else {
                try {
                    if (typeof document === "undefined") {
                        logger.error("Error: document is not available, cannot generate image");
                        reject(new Error("ImageCache#renderImage: document is not available, cannot " +
                            "render image to create texture"));
                    }
                    // TODO: Extract the rendering to the canvas part and make it configurable for
                    // the client, so it does not rely on the `document`.
                    // use the image, e.g. draw part of it on a canvas
                    const canvas = document.createElement("canvas");
                    canvas.width = image.width;
                    canvas.height = image.height;
                    const context = canvas.getContext("2d");
                    if (context !== null) {
                        logger.log(
                        // tslint:disable-next-line: max-line-length
                        `... finished creating bitmap image in canvas: ${imageItem.url} ${image}`);
                        context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
                        const imageData = context.getImageData(0, 0, image.width, image.height);
                        imageItem.imageData = imageData;
                        imageItem.loaded = true;
                        resolve(imageData);
                    }
                    else {
                        logger.error(`renderImage: no context found`);
                        reject(new Error(`ImageCache#renderImage: no context found`));
                    }
                }
                catch (ex) {
                    logger.error(`renderImage failed: ${ex}`);
                    imageItem.imageData = undefined;
                    imageItem.loaded = true;
                    reject(new Error(`ImageCache#renderImage failed: ${ex}`));
                }
            }
        });
    }
}
exports.ImageCache = ImageCache;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ImageCache_1 = __webpack_require__(/*! ./ImageCache */ "./node_modules/@here/harp-mapview/lib/image/ImageCache.js");
/**
 * Cache images wrapped into [[ImageItem]]s for a [[MapView]]. An image may have multiple names in
 * a theme, the `MapViewImageCache` will take care of that. Registering multiple images with the
 * same name is invalid.
 *
 * The `MapViewImageCache` uses a global [[ImageCache]] to actually store (and generate) the
 * image data.
 */
class MapViewImageCache {
    /**
     * The constructor for `MapViewImageCache`.
     *
     * @param mapView a [[MapView]] instance.
     */
    constructor(mapView) {
        this.mapView = mapView;
        this.m_name2Url = new Map();
        this.m_url2Name = new Map();
    }
    /**
     * Register an existing image by name.
     *
     * @param name Name of the image from [[Theme]].
     * @param url URL of image.
     * @param image Optional [[ImageData]] of image.
     */
    registerImage(name, url, image) {
        if (name !== undefined) {
            if (this.hasName(name)) {
                throw new Error("duplicate name in cache");
            }
            const oldNames = this.m_url2Name.get(url);
            if (oldNames !== undefined) {
                if (oldNames.indexOf(name) < 0) {
                    oldNames.push(name);
                }
            }
            else {
                this.m_url2Name.set(url, [name]);
            }
            this.m_name2Url.set(name, url);
        }
        const imageItem = ImageCache_1.ImageCache.instance.findImage(url);
        if (imageItem === undefined) {
            return ImageCache_1.ImageCache.instance.registerImage(this.mapView, url, image);
        }
        return imageItem;
    }
    /**
     * Add an image and optionally start loading it. Once done, the [[ImageData]] or [[ImageBitmap]]
     * will be stored in the [[ImageItem]].
     *
     * @param name Name of image from [[Theme]].
     * @param url URL of image.
     * @param startLoading Optional. Pass `true` to start loading the image in the background.
     */
    addImage(name, url, startLoading = true) {
        const imageItem = this.registerImage(name, url, undefined);
        if (startLoading === true) {
            return ImageCache_1.ImageCache.instance.loadImage(imageItem);
        }
        return imageItem;
    }
    /**
     * Find [[ImageItem]] by its name.
     *
     * @param name Name of image.
     */
    findImageByName(name) {
        const url = this.m_name2Url.get(name);
        if (url === undefined) {
            return undefined;
        }
        return ImageCache_1.ImageCache.instance.findImage(url);
    }
    /**
     * Find [[ImageItem]] by URL.
     *
     * @param url Url of image.
     */
    findImageByUrl(url) {
        return ImageCache_1.ImageCache.instance.findImage(url);
    }
    /**
     * Load an [[ImageItem]]. Returns a promise or a loaded [[ImageItem]].
     *
     * @param imageItem ImageItem to load.
     */
    loadImage(imageItem) {
        return ImageCache_1.ImageCache.instance.loadImage(imageItem);
    }
    /**
     * Remove all [[ImageItem]]s from the cache. Also removes all [[ImageItem]]s that belong to this
     * [[MapView]] from the global [[ImageCache]].
     */
    clear() {
        ImageCache_1.ImageCache.instance.clear(this.mapView);
        this.m_name2Url = new Map();
        this.m_url2Name = new Map();
    }
    /**
     * Returns number of image names stored in the cache.
     */
    get numberOfNames() {
        return this.m_name2Url.size;
    }
    /**
     * Returns number of image URLs in the cache.
     */
    get numberOfUrls() {
        return this.m_url2Name.size;
    }
    /**
     * Return `true` if an image with the given name is known.
     *
     * @param name Name of the image.
     */
    hasName(name) {
        return this.m_name2Url.get(name) !== undefined;
    }
    /**
     * Return `true` if an image with the given URL is known.
     * @param url URL of image.
     */
    hasUrl(url) {
        return this.m_url2Name.get(url) !== undefined;
    }
    /**
     * Return the names under which an image with the given URL is saved.
     */
    findNames(url) {
        return this.m_url2Name.get(url);
    }
}
exports.MapViewImageCache = MapViewImageCache;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/BoxBuffer.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/BoxBuffer.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const PixelPicker_1 = __webpack_require__(/*! ./PixelPicker */ "./node_modules/@here/harp-mapview/lib/poi/PixelPicker.js");
/**
 * Initial number of boxes in BoxBuffer.
 */
const START_BOX_BUFFER_SIZE = 0;
/**
 * Maximum number of boxes in BoxBuffer.
 */
const MAX_BOX_BUFFER_SIZE = 32 * 1024;
/**
 * Number of vertices per box/glyph element: 4 corners.
 */
const NUM_VERTICES_PER_ELEMENT = 4;
/**
 * Number of indices added per box/glyph: 2 triangles, 6 indices.
 */
const NUM_INDICES_PER_ELEMENT = 6;
/**
 * Number of values per position.
 */
const NUM_POSITION_VALUES_PER_VERTEX = 3;
/**
 * Number of values per color.
 */
const NUM_COLOR_VALUES_PER_VERTEX = 4;
/**
 * Number of values per UV.
 */
const NUM_UV_VALUES_PER_VERTEX = 4;
/**
 * Number of values per index.
 */
const NUM_INDEX_VALUES_PER_VERTEX = 1;
/**
 * Number of bytes for float in an Float32Array.
 */
const NUM_BYTES_PER_FLOAT = 4;
/**
 * Number of bytes for integer number in an UInt32Array.
 */
const NUM_BYTES_PER_INT32 = 4;
/**
 * SubClass of [[THREE.Mesh]] to identify meshes that have been created by [[BoxBuffer]] and
 * [[TextBuffer]]. Add the isEmpty flag to quickly test for empty meshes.
 */
class BoxBufferMesh extends THREE.Mesh {
    constructor(geometry, material) {
        super(geometry, material);
        this.type = "BoxBufferMesh";
    }
    /**
     * A mesh that has no positions and indices set is defined to be empty.
     *
     * @returns `True` if no indices have been added to the mesh.
     */
    get isEmpty() {
        return this.geometry !== undefined
            ? this.geometry.index.count === 0
            : true;
    }
}
exports.BoxBufferMesh = BoxBufferMesh;
/**
 * Buffer for (untransformed) `Box2` objects. Can be used to create a single geometry for screen-
 * aligned boxes, like POIs.
 */
class BoxBuffer {
    /**
     * Creates a new `BoxBuffer`.
     *
     * @param material Material to be used for [[Mesh]] of this `BoxBuffer`.
     * @param renderOrder Optional renderOrder of this buffer.
     * @param startElementCount Initial number of elements this `BoxBuffer` can hold.
     * @param maxElementCount Maximum number of elements this `BoxBuffer` can hold.
     */
    constructor(material, renderOrder = 0, startElementCount = START_BOX_BUFFER_SIZE, maxElementCount = MAX_BOX_BUFFER_SIZE) {
        this.material = material;
        this.renderOrder = renderOrder;
        this.startElementCount = startElementCount;
        this.maxElementCount = maxElementCount;
        this.m_size = 0;
        this.resizeBuffer(startElementCount);
        this.pickInfos = new Array();
    }
    /**
     * Duplicate this `BoxBuffer` with same material and renderOrder.
     *
     * @returns A clone of this `BoxBuffer`.
     */
    clone() {
        return new BoxBuffer(this.material, this.renderOrder);
    }
    /**
     * Dispose of the geometry.
     */
    dispose() {
        if (this.geometry !== undefined) {
            this.geometry.dispose();
            this.geometry = undefined;
        }
        this.internalMesh = undefined;
    }
    /**
     * Return the current number of elements the buffer can hold.
     */
    get size() {
        return this.m_size;
    }
    /**
     * Clear's the `BoxBuffer` attribute buffers.
     */
    reset() {
        if (this.positionAttribute !== undefined) {
            this.positionAttribute.count = 0;
            this.colorAttribute.count = 0;
            this.uvAttribute.count = 0;
            this.indexAttribute.count = 0;
            this.pickInfos.length = 0;
        }
    }
    /**
     * Returns `true` if this `BoxBuffer` can hold the specified amount of glyphs. If the buffer
     * can only add the glyph by increasing the buffer size, the resize() method is called, which
     * will then create a new geometry for the mesh.
     *
     * @param glyphCount Number of glyphs to be added to the buffer.
     * @returns `true` if the element (box or glyph) can be added to the buffer, `false` otherwise.
     */
    canAddElements(glyphCount = 1) {
        const indexAttribute = this.indexAttribute;
        if (indexAttribute.count + glyphCount * NUM_INDICES_PER_ELEMENT >=
            indexAttribute.array.length) {
            // Too many elements for the current buffer, check if we can resize the buffer.
            if (indexAttribute.array.length >= this.maxElementCount * NUM_INDICES_PER_ELEMENT) {
                return false;
            }
            const newSize = Math.min(this.maxElementCount, this.size === 0 ? 256 : this.size * 2);
            this.resize(newSize);
        }
        return true;
    }
    /**
     * Returns this `BoxBuffer`'s attribute [[State]].
     */
    saveState() {
        const state = {
            positionAttributeCount: this.positionAttribute.count,
            colorAttributeCount: this.colorAttribute.count,
            uvAttributeCount: this.uvAttribute.count,
            indexAttributeCount: this.indexAttribute.count,
            pickInfoCount: this.pickInfos.length
        };
        return state;
    }
    /**
     * Store this `BoxBuffer`'s attribute [[State]] to a previously stored one.
     *
     * @param state [[State]] struct describing a previous attribute state.
     */
    restoreState(state) {
        this.positionAttribute.count = state.positionAttributeCount;
        this.colorAttribute.count = state.colorAttributeCount;
        this.uvAttribute.count = state.uvAttributeCount;
        this.indexAttribute.count = state.indexAttributeCount;
        this.pickInfos.length = state.pickInfoCount;
    }
    /**
     * Adds a new box to this `BoxBuffer`.
     *
     * @param screenBox [[Math2D.Box]] holding screen coordinates for this box.
     * @param uvBox [[Math2D.UvBox]] holding uv coordinates for this box.
     * @param color Box's color.
     * @param opacity Box's opacity.
     * @param distance Box's distance to camera.
     * @param pickInfo Box's picking information.
     */
    addBox(screenBox, uvBox, color, opacity, distance, pickInfo) {
        if (!this.canAddElements()) {
            return false;
        }
        const { s0, t0, s1, t1 } = uvBox;
        const { x, y, w, h } = screenBox;
        const r = Math.round(color.r * 255);
        const g = Math.round(color.g * 255);
        const b = Math.round(color.b * 255);
        const a = Math.round(opacity * 255);
        const positionAttribute = this.positionAttribute;
        const colorAttribute = this.colorAttribute;
        const uvAttribute = this.uvAttribute;
        const indexAttribute = this.indexAttribute;
        const baseVertex = positionAttribute.count;
        const baseIndex = indexAttribute.count;
        positionAttribute.setXYZ(baseVertex, x, y, distance);
        positionAttribute.setXYZ(baseVertex + 1, x + w, y, distance);
        positionAttribute.setXYZ(baseVertex + 2, x, y + h, distance);
        positionAttribute.setXYZ(baseVertex + 3, x + w, y + h, distance);
        colorAttribute.setXYZW(baseVertex, r, g, b, a);
        colorAttribute.setXYZW(baseVertex + 1, r, g, b, a);
        colorAttribute.setXYZW(baseVertex + 2, r, g, b, a);
        colorAttribute.setXYZW(baseVertex + 3, r, g, b, a);
        uvAttribute.setXY(baseVertex, s0, t0);
        uvAttribute.setXY(baseVertex + 1, s1, t0);
        uvAttribute.setXY(baseVertex + 2, s0, t1);
        uvAttribute.setXY(baseVertex + 3, s1, t1);
        indexAttribute.setX(baseIndex, baseVertex);
        indexAttribute.setX(baseIndex + 1, baseVertex + 1);
        indexAttribute.setX(baseIndex + 2, baseVertex + 2);
        indexAttribute.setX(baseIndex + 3, baseVertex + 2);
        indexAttribute.setX(baseIndex + 4, baseVertex + 1);
        indexAttribute.setX(baseIndex + 5, baseVertex + 3);
        positionAttribute.count += NUM_VERTICES_PER_ELEMENT;
        colorAttribute.count += NUM_VERTICES_PER_ELEMENT;
        uvAttribute.count += NUM_VERTICES_PER_ELEMENT;
        indexAttribute.count += NUM_INDICES_PER_ELEMENT;
        this.pickInfos.push(pickInfo);
        return true;
    }
    /**
     * Updates a [[BufferGeometry]] object to reflect the changes in this `TextBuffer`'s attribute
     * data.
     */
    updateBufferGeometry() {
        const positionAttribute = this.positionAttribute;
        const colorAttribute = this.colorAttribute;
        const uvAttribute = this.uvAttribute;
        const indexAttribute = this.indexAttribute;
        if (positionAttribute.count > 0) {
            positionAttribute.needsUpdate = true;
            positionAttribute.updateRange.offset = 0;
            positionAttribute.updateRange.count =
                positionAttribute.count * NUM_VERTICES_PER_ELEMENT;
        }
        if (colorAttribute.count > 0) {
            colorAttribute.needsUpdate = true;
            colorAttribute.updateRange.offset = 0;
            colorAttribute.updateRange.count = colorAttribute.count * NUM_VERTICES_PER_ELEMENT;
        }
        if (uvAttribute.count > 0) {
            uvAttribute.needsUpdate = true;
            uvAttribute.updateRange.offset = 0;
            uvAttribute.updateRange.count = uvAttribute.count * NUM_VERTICES_PER_ELEMENT;
        }
        if (indexAttribute.count > 0) {
            indexAttribute.needsUpdate = true;
            indexAttribute.updateRange.offset = 0;
            indexAttribute.updateRange.count = indexAttribute.count;
        }
        if (this.geometry !== undefined) {
            this.geometry.clearGroups();
            this.geometry.addGroup(0, this.indexAttribute.count);
        }
    }
    /**
     * Check if the buffer is empty. If it is empty, the memory usage is minimized to reduce
     * footprint.
     */
    cleanUp() {
        // If there is nothing in this buffer, resize it, it may never be used again.
        if (this.indexAttribute.count === 0 && this.size > START_BOX_BUFFER_SIZE) {
            this.clearAttributes();
        }
    }
    /**
     * Determine if the mesh is empty.
     */
    get isEmpty() {
        return this.internalMesh.isEmpty;
    }
    /**
     * Get the [[Mesh]] object. The geometry instance of the mesh may change if the buffers are
     * resized. The mesh, once created, will not change, so it can always be added to the scene.
     */
    get mesh() {
        if (this.internalMesh === undefined) {
            this.resize();
        }
        return this.internalMesh;
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * boxes are found, the order of the results is unspecified.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickCallback Callback to be called for every picked element.
     * @param imageData Image data to test if the pixel is transparent
     */
    pickBoxes(screenPosition, pickCallback, imageData) {
        const n = this.pickInfos.length;
        const pickInfos = this.pickInfos;
        const positions = this.positionAttribute;
        const screenX = screenPosition.x;
        const screenY = screenPosition.y;
        const canvas = document.createElement("canvas");
        for (let pickInfoIndex = 0; pickInfoIndex < n; pickInfoIndex++) {
            const positionIndex = pickInfoIndex * NUM_VERTICES_PER_ELEMENT;
            const minX = positions.getX(positionIndex);
            if (screenX < minX) {
                continue;
            }
            const maxX = positions.getX(positionIndex + 1);
            if (screenX > maxX) {
                continue;
            }
            const minY = positions.getY(positionIndex);
            if (screenY < minY) {
                continue;
            }
            const maxY = positions.getY(positionIndex + 2);
            if (screenY > maxY) {
                continue;
            }
            const box = new harp_utils_1.Math2D.Box(minX, minY, maxX - minX, maxY - minY);
            if (imageData !== undefined &&
                pickInfos[pickInfoIndex].poiInfo !== undefined &&
                pickInfos[pickInfoIndex].poiInfo.uvBox !== undefined &&
                this.isPixelTransparent(imageData, screenX, screenY, box, pickInfos[pickInfoIndex].poiInfo.uvBox, canvas)) {
                continue;
            }
            if (pickInfos[pickInfoIndex] !== undefined) {
                pickCallback(pickInfos[pickInfoIndex]);
            }
        }
    }
    /**
     * Creates a new [[Geometry]] object from all the attribute data stored in this `BoxBuffer`.
     * The [[Mesh]] object may be created if it is not initialized already.
     *
     * @param newSize Optional number of elements to resize the buffer to.
     * @param forceResize Optional flag to force a resize even if new size is smaller than before.
     */
    resize(newSize, forceResize) {
        if (this.geometry !== undefined) {
            this.geometry.dispose();
        }
        this.geometry = new THREE.BufferGeometry();
        if (newSize !== undefined && (forceResize === true || newSize > this.size)) {
            this.resizeBuffer(newSize);
        }
        this.geometry.addAttribute("position", this.positionAttribute);
        this.geometry.addAttribute("color", this.colorAttribute);
        this.geometry.addAttribute("uv", this.uvAttribute);
        this.geometry.setIndex(this.indexAttribute);
        this.geometry.addGroup(0, this.indexAttribute.count);
        if (this.internalMesh === undefined) {
            this.internalMesh = new BoxBufferMesh(this.geometry, this.material);
            this.internalMesh.renderOrder = this.renderOrder;
        }
        else {
            this.internalMesh.geometry = this.geometry;
        }
        return this.internalMesh;
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `BoxBuffer`.
     *
     * @param info The info object to increment with the values from this `BoxBuffer`.
     */
    updateMemoryUsage(info) {
        const numBytes = this.positionAttribute.count * NUM_POSITION_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +
            this.colorAttribute.count * NUM_COLOR_VALUES_PER_VERTEX +
            this.uvAttribute.count * NUM_UV_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +
            this.indexAttribute.count * NUM_BYTES_PER_INT32; // May be UInt16, so we overestimate
        info.heapSize += numBytes;
        info.gpuSize += numBytes;
    }
    /**
     * Check if a pixel is transparent or not.
     *
     * @param imageData Data containing the pixels.
     * @param xScreenPos X position of the pixel.
     * @param yScreenPos Y position of the pixel.
     * @param box Bounding box of the image in screen coordinates.
     * @param uvBox Uv box referred to the given bounding box.
     * @param canvas Canvas element that will be used to draw the image, in case the imageData is an
     *      ImageBitmap
     */
    isPixelTransparent(imageData, xScreenPos, yScreenPos, box, uvBox, canvas) {
        let pixelIsTransparent = false;
        const { u, v } = PixelPicker_1.screenToUvCoordinates(xScreenPos, yScreenPos, box, uvBox);
        const imageWidth = imageData.width;
        const x = imageWidth * u;
        const imageHeight = imageData.height;
        const y = imageHeight * v;
        const pixel = PixelPicker_1.getPixelFromImage(x, y, imageData, canvas);
        if (pixel !== undefined && pixel[3] === 0) {
            pixelIsTransparent = true;
        }
        return pixelIsTransparent;
    }
    /**
     * Remove current attributes and arrays. Minimizes memory footprint.
     */
    clearAttributes() {
        this.positionAttribute = undefined;
        this.colorAttribute = undefined;
        this.uvAttribute = undefined;
        this.indexAttribute = undefined;
        this.resize(START_BOX_BUFFER_SIZE, true);
    }
    /**
     * Resize the attribute buffers. New value must be larger than the previous one.
     *
     * @param newSize New number of elements in the buffer. Number has to be larger than the
     *      previous size.
     */
    resizeBuffer(newSize) {
        const newPositionArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_POSITION_VALUES_PER_VERTEX);
        if (this.positionAttribute !== undefined && this.positionAttribute.array.length > 0) {
            const positionAttributeCount = this.positionAttribute.count;
            newPositionArray.set(this.positionAttribute.array);
            this.positionAttribute.setArray(newPositionArray);
            this.positionAttribute.count = positionAttributeCount;
        }
        else {
            this.positionAttribute = new THREE.BufferAttribute(newPositionArray, NUM_POSITION_VALUES_PER_VERTEX);
            this.positionAttribute.count = 0;
            this.positionAttribute.setDynamic(true);
        }
        const newColorArray = new Uint8Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_COLOR_VALUES_PER_VERTEX);
        if (this.colorAttribute !== undefined) {
            const colorAttributeCount = this.colorAttribute.count;
            newColorArray.set(this.colorAttribute.array);
            this.colorAttribute.setArray(newColorArray);
            this.colorAttribute.count = colorAttributeCount;
        }
        else {
            this.colorAttribute = new THREE.BufferAttribute(newColorArray, NUM_COLOR_VALUES_PER_VERTEX, true);
            this.colorAttribute.count = 0;
            this.colorAttribute.setDynamic(true);
        }
        const newUvArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_UV_VALUES_PER_VERTEX);
        if (this.uvAttribute !== undefined) {
            const uvAttributeCount = this.uvAttribute.count;
            newUvArray.set(this.uvAttribute.array);
            this.uvAttribute.setArray(newUvArray);
            this.uvAttribute.count = uvAttributeCount;
        }
        else {
            this.uvAttribute = new THREE.BufferAttribute(newUvArray, NUM_UV_VALUES_PER_VERTEX);
            this.uvAttribute.count = 0;
            this.uvAttribute.setDynamic(true);
        }
        const numIndexValues = newSize * NUM_INDICES_PER_ELEMENT * NUM_INDEX_VALUES_PER_VERTEX;
        const newIndexArray = numIndexValues > 65535
            ? new Uint32Array(numIndexValues)
            : new Uint16Array(numIndexValues);
        if (this.indexAttribute !== undefined) {
            const indexAttributeCount = this.indexAttribute.count;
            newIndexArray.set(this.indexAttribute.array);
            this.indexAttribute.setArray(newIndexArray);
            this.indexAttribute.count = indexAttributeCount;
        }
        else {
            this.indexAttribute = new THREE.BufferAttribute(newIndexArray, NUM_INDEX_VALUES_PER_VERTEX);
            this.indexAttribute.count = 0;
            this.indexAttribute.setDynamic(true);
        }
        this.m_size = newSize;
    }
}
exports.BoxBuffer = BoxBuffer;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PixelPicker.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PixelPicker.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
/**
 * It returns an array containing the channel colors for the pixel at the given coordinates.
 *
 * @param xPos X value of the pixel.
 * @param yPos Y value of the pixel.
 * @param imageData Data containing the pixels.
 * @param canvas Canvas element that will be used to draw the image, in case the imageData is an
 * ImageBitmap
 */
function getPixelFromImage(xPos, yPos, imageData, canvas) {
    let pickedColor;
    const isImageBitmap = (imgData) => {
        return imgData.close !== undefined;
    };
    if (isImageBitmap(imageData)) {
        if (canvas === undefined) {
            canvas = document.createElement("canvas");
        }
        pickedColor = getPixelFromImageBitmap(imageData, xPos, yPos, canvas);
    }
    else {
        const pixelsData = imageData;
        const stride = pixelsData.data.length / (pixelsData.height * pixelsData.width);
        pickedColor = getPixelFromImageData(pixelsData, xPos, yPos, stride);
    }
    return pickedColor;
}
exports.getPixelFromImage = getPixelFromImage;
/**
 * Given the x and y position in screen coordinates inside the target box, it map them to the UV
 * coordinates.
 * @param screenX X value in screen coordinates.
 * @param screenY Y value in screen coordinates.
 * @param box Bounding box in screen coordinates.
 * @param uvBox Uv box referred to the given bounding box.
 */
function screenToUvCoordinates(screenX, screenY, box, uvBox) {
    const minX = box.x;
    const maxX = box.x + box.w;
    const minY = box.y;
    const maxY = box.y + box.h;
    const u = harp_utils_1.MathUtils.lerp(screenX, minX, maxX, uvBox.s0, uvBox.s1);
    const v = harp_utils_1.MathUtils.lerp(screenY, minY, maxY, uvBox.t0, uvBox.t1);
    return { u, v };
}
exports.screenToUvCoordinates = screenToUvCoordinates;
/**
 * It returns an Uint8ClampedArray containing the color channel values for the given pixel
 * coordinates. It returns undefined if the given coordinates are out of range.
 *
 * @param image Bitmap image in which the pixels are stored.
 * @param xPos X value of the pixel.
 * @param yPos Y value of the pixel.
 * @param canvas HTML Canvas element on which the image is drawn.
 */
function getPixelFromImageBitmap(image, xPos, yPos, canvas) {
    if (xPos > image.width || xPos < 0 || yPos > image.height || yPos < 0) {
        return undefined;
    }
    let pixelData;
    canvas.width = image.width;
    canvas.height = image.height;
    const context = canvas.getContext("2d");
    if (context !== null) {
        context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
        pixelData = context.getImageData(xPos, yPos, 1, 1).data;
    }
    return pixelData;
}
exports.getPixelFromImageBitmap = getPixelFromImageBitmap;
/**
 * It returns an Uint8ClampedArray containing the color channel values for the given pixel
 * coordinates. It returns undefined if the given coordinates are out of range.
 *
 * @param image Image data in which the pixels are stored.
 * @param xPos X value of the pixel.
 * @param yPos Y value of the pixel.
 * @param stride The stride value of the image data.
 */
function getPixelFromImageData(imgData, xPos, yPos, stride) {
    const getPixel = (imageData, index, strd) => {
        const i = index * strd;
        const d = imageData.data;
        const pixel = new Uint8ClampedArray(strd);
        for (let s = 0; s < strd; s++) {
            pixel[0] = d[i + s];
        }
        return pixel;
    };
    if (xPos > imgData.width || xPos < 0 || yPos > imgData.height || yPos < 0) {
        return undefined;
    }
    return getPixel(imgData, yPos * imgData.width + xPos, stride);
}
exports.getPixelFromImageData = getPixelFromImageData;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/Poi.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/Poi.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This enum defines the possible origin points for an image.
 */
var ImageOrigin;
(function (ImageOrigin) {
    ImageOrigin[ImageOrigin["TopLeft"] = 0] = "TopLeft";
    ImageOrigin[ImageOrigin["BottomLeft"] = 1] = "BottomLeft";
})(ImageOrigin = exports.ImageOrigin || (exports.ImageOrigin = {}));
/**
 * Defines a part (or all) of an image as a texture.
 */
class IconTexture {
    /**
     * The constructor of an `IconTexture`.
     *
     * @param image An [[ImageItem]] instance.
     * @param options The rendering parameters.
     */
    constructor(image) {
        this.image = image;
    }
}
exports.IconTexture = IconTexture;
// export enum TextAlign {
//     Center,
//     Left,
//     Right,
//     // ??? expands lines to have same length.
//     Justify
// }
// export interface LayoutOptions {
//     paddingH?: number;
//     paddingV: number;
//     transFormCenterX?: number;
//     transFormCenterY?: number;
//     rotation?: number;
//     /** Set to `true` to enlarge the box after rotation to include all rotated corners. */
//     rotationEnlargesBox: boolean;
// }
// export interface TextOptions {
//     bgColor?: THREE.Color;
//     wrapWords?: boolean;
//     maxNumLines?: number;
//     maxWidth?: number;
//     /** Replace with ellipsis if wider than maxWidth. */
//     addEllipsis?: boolean;
//     /** Handle right-to-left texts */
//     isRightToLeft?: boolean;
//     textAlignH?: AlignH; // = AlignH.Center;
//     textAlignV?: AlignV; // = AlignV.Center;
// }
// export class IconLabel {
//     constructor(text: string, options: LayoutOptions | TextOptions) {}
//     /**
//      * Setup a box with size and padding.
//      *
//      * @param box Target box to set up.
//      */
//     getBox(box: THREE.Box2) {}
//     /**
//      * Compute width and height from text and font.
//      */
//     computeBox() {}
//     /**
//      * Generate the glyphs and keep them in a buffer. Generates a fixed layout.
//      */
//     prepareRendering() {}
// }
// export enum AlignH {
//     Center,
//     Left,
//     Right
// }
// export enum AlignV {
//     Center,
//     Top,
//     Bottom
// }
// export enum AnchorTarget {
//     /** Anchor point relative to Icon */
//     Icon,
//     /** Anchor point is transform center of icon */
//     IconCenter,
//     /** Anchor point relative to Icon including padding */
//     IconBox,
//     /** Anchor point relative to Label */
//     Label,
//     /** Anchor point relative to combination of Icon and Label */
//     Box
// }
// export class AnchorPosition {
//     targetH: AnchorTarget = AnchorTarget.Icon;
//     targetV: AnchorTarget = AnchorTarget.Icon;
//     alignH: AlignH = AlignH.Center;
//     alignV: AlignV = AlignV.Center;
// }
// export enum IconPinMode {
//     /** Pinned down, anchor point is the same at all angles. */
//     PinDown,
//     /**
//      * Icon stands up. "StreetLevel"-style. The anchor point moves to the bottom of the icon when
//      * the view direction gets parallel to the ground.
//      */
//     StandUp
// }
// export interface IconScaleOptions {
//     depthScale?: boolean;
//     minimumScale?: number;
// }
// export interface IconOptions {
//     useScreenSpace?: boolean; // = true
//     priority?: number;
//     scaleOptions?: IconScaleOptions;
//     /** Optional offset in screen space */
//     screenOffsetX?: number;
//     screenOffsetY?: number;
//     /** Optional 3D height above terrain. */
//     heightAboveGround?: number;
// }
// export class SimplePoiIcon {
//     constructor(
//         readonly pos: THREE.Vector3,
//         readonly image ?: IconTexture,
//         options ?: IconOptions
//     ) { }
// }
// export class PoiIcon {
//     constructor(
//         readonly pos: THREE.Vector3,
//         readonly image?: IconTexture,
//         readonly label?: IconLabel,
//         options?: IconOptions
//     ) {}
// }
// export interface PoiOptions {
//     featureId?: number;
//     minZoomLevel?: number;
// }
// export class SimplePoi {
//     private m_featureId?: number;
//     private m_minZoomLevel: number = 0;
//     constructor(readonly icon: SimplePoiIcon, options?: PoiOptions) {
//         if (options !== undefined) {
//             this.m_featureId = options.featureId;
//             this.m_minZoomLevel = options.minZoomLevel !== undefined ? options.minZoomLevel : 0;
//         }
//     }
// }
// export class Poi {
//     /** store multiple icons, one for every LOD */
//     private m_icons: PoiIcon[] = [];
//     private m_lod = 0;
//     private m_featureId?: number;
//     private m_minZoomLevel: number = 0;
//     constructor(icon: PoiIcon, options?: PoiOptions) {
//         this.m_icons.push(icon);
//         if (options !== undefined) {
//             this.m_featureId = options.featureId;
//             this.m_minZoomLevel = options.minZoomLevel !== undefined ? options.minZoomLevel : 0;
//         }
//     }
//     icon(): PoiIcon | undefined {
//         return this.m_icons[this.m_lod];
//     }
//     /**
//      * Select the level of detail that should be used.
//      *
//      * @param levelOfDetail Level of detail to render.
//      */
//     selectIcon(levelOfDetail: number) {}
// }


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PoiManager.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PoiManager.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "./node_modules/@here/harp-text-canvas/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const ColorCache_1 = __webpack_require__(/*! ../ColorCache */ "./node_modules/@here/harp-mapview/lib/ColorCache.js");
const TextElement_1 = __webpack_require__(/*! ../text/TextElement */ "./node_modules/@here/harp-mapview/lib/text/TextElement.js");
const TextElementsRenderer_1 = __webpack_require__(/*! ../text/TextElementsRenderer */ "./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js");
const TextStyleCache_1 = __webpack_require__(/*! ../text/TextStyleCache */ "./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js");
const logger = harp_utils_1.LoggerManager.instance.create("PoiManager");
/**
 * POI manager class, responsible for loading the [[PoiGeometry]] objects from the [[DecodedTile]],
 * and preparing them for rendering. Also loads and manages the texture atlases for the icons.
 */
class PoiManager {
    /**
     * The constructor of the `PoiManager`.
     *
     * @param mapView The [[MapView]] instance that should display the POIs.
     */
    constructor(mapView) {
        this.mapView = mapView;
        this.m_imageTextures = new Map();
        this.m_poiShieldGroups = new Map();
        this.m_colorMap = new Map();
    }
    static notifyMissingPoiTable(poiTableName, poiTable) {
        // Warn about a missing POI table name, but only once.
        if (poiTableName === undefined) {
            poiTableName = "undefined";
        }
        if (PoiManager.m_missingPoiTableName.get(poiTableName) === undefined) {
            PoiManager.m_missingPoiTableName.set(poiTableName, true);
            if (poiTable !== undefined && !poiTable.loadedOk) {
                logger.error(`updatePoiFromPoiTable: Could not load POI table '${poiTableName}'!`);
            }
            else {
                logger.error(`updatePoiFromPoiTable: No POI table with name '${poiTableName}' found!`);
            }
        }
    }
    static notifyMissingPoi(poiName, poiTableName) {
        // Warn about a missing POI name, but only once.
        if (poiName === undefined) {
            poiName = "undefined";
        }
        const key = `${poiTableName}[${poiName}]`;
        if (PoiManager.m_missingPoiName.get(key) === undefined) {
            PoiManager.m_missingPoiName.set(key, true);
            logger.warn(`updatePoiFromPoiTable: ` +
                `Cannot find POI info for '${poiName}' in table '${poiTableName}'.`);
        }
    }
    /**
     * Add all POIs from a decoded tile and store them as [[TextElement]]s in the [[Tile]].
     *
     * Also handles LineMarkers, which is a recurring marker along a line (road).
     *
     * @param tile Tile to add POIs to.
     * @param decodedTile DecodedTile containing the raw [[PoiGeometry]] objects describing the
     *  POIs.
     */
    addPois(tile, decodedTile) {
        const poiGeometries = harp_utils_1.assertExists(decodedTile.poiGeometries);
        for (const poiGeometry of poiGeometries) {
            harp_utils_1.assert(poiGeometry.technique !== undefined);
            const techniqueIndex = harp_utils_1.assertExists(poiGeometry.technique);
            const technique = decodedTile.techniques[techniqueIndex];
            if (!harp_datasource_protocol_1.isLineMarkerTechnique(technique) && !harp_datasource_protocol_1.isPoiTechnique(technique)) {
                continue;
            }
            // The POI may be in the data, and there may be a Technique, but the technique may
            // specify to not show it.
            if (technique.showOnMap === false) {
                continue;
            }
            const positions = new THREE.BufferAttribute(new Float32Array(poiGeometry.positions.buffer), poiGeometry.positions.itemCount);
            if (harp_datasource_protocol_1.isLineMarkerTechnique(technique) && positions.count > 0) {
                this.addLineMarker(tile, poiGeometry, technique, techniqueIndex, positions);
            }
            else {
                const poiTechnique = technique;
                let imageTextureName = poiTechnique.imageTexture;
                if (poiGeometry.stringCatalog === undefined) {
                    continue;
                }
                const poiTableName = poiTechnique.poiTable;
                let poiName = poiTechnique.poiName;
                for (let i = 0; i < positions.count; ++i) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    harp_utils_1.assert(poiGeometry.texts.length > i);
                    let text = poiGeometry.stringCatalog[poiGeometry.texts[i]];
                    if (text === undefined) {
                        text = "";
                    }
                    if (poiGeometry.stringCatalog !== undefined) {
                        if (poiGeometry.imageTextures !== undefined &&
                            poiGeometry.imageTextures[i] >= 0) {
                            harp_utils_1.assert(poiGeometry.imageTextures.length > i);
                            imageTextureName =
                                poiGeometry.stringCatalog[poiGeometry.imageTextures[i]];
                        }
                        else {
                            imageTextureName = poiTechnique.imageTexture;
                        }
                        if (poiTableName !== undefined) {
                            // The POI name to be used is taken from the data, since it will
                            // specify the name of the texture to use.
                            // The POI name in the technique may override the POI name from the
                            // data.
                            poiName =
                                poiTechnique.poiName === undefined
                                    ? imageTextureName
                                    : poiTechnique.poiName;
                            imageTextureName = undefined;
                        }
                    }
                    const textElement = this.checkCreateTextElement(tile, text, technique, techniqueIndex, imageTextureName, poiTableName, poiName, 0, poiGeometry.featureId, x, y, z, tile.tileKey.level);
                    if (textElement !== undefined) {
                        tile.addTextElement(textElement);
                    }
                }
            }
        }
    }
    /**
     * Load the texture atlas that defines the segments of the texture that should be used for
     * specific icons. Creates an [[ImageTexture]] for every element in the atlas, such that it can
     * be addressed in the theme file.
     *
     * @param imageName Name of the image from the theme (NOT the url!).
     * @param atlas URL of the JSON file defining the texture atlas.
     */
    addTextureAtlas(imageName, atlas) {
        fetch(atlas)
            .then(response => {
            if (!response.ok) {
                throw new Error(`addTextureAtlas: Cannot load textureAtlas: ${response.statusText}`);
            }
            return response.json();
        })
            .then((jsonAtlas) => {
            if (jsonAtlas === undefined) {
                logger.info(`addTextureAtlas: TextureAtlas empty: ${atlas}`);
                return;
            }
            try {
                logger.log(`addTextureAtlas: Loading textureAtlas '${atlas}' for image '${imageName}'`);
                for (const textureName of Object.getOwnPropertyNames(jsonAtlas)) {
                    const imageTextureDef = jsonAtlas[textureName];
                    const imageTexture = {
                        name: textureName,
                        image: imageName,
                        xOffset: imageTextureDef.x,
                        yOffset: imageTextureDef.y,
                        width: imageTextureDef.width,
                        height: imageTextureDef.height
                    };
                    this.addImageTexture(imageTexture);
                }
            }
            catch (ex) {
                logger.error(`addTextureAtlas: Failed to load textureAtlas ` + `'${atlas}' : ${ex}`);
            }
            this.mapView.update();
        })
            .catch((reason) => {
            logger.error(`addTextureAtlas: Failed to load textureAtlas '${atlas}' : ${reason}`);
        });
    }
    /**
     * Add an [[ImageTexture]] such that it is available as a named entity for techniques in theme
     * files.
     *
     * @param imageTexture [[ImageTexture]] that should be available for POIs.
     */
    addImageTexture(imageTexture) {
        if (imageTexture.name === undefined) {
            logger.error("addImageTexture: Name required", imageTexture);
            return;
        }
        if (this.m_imageTextures.get(imageTexture.name) !== undefined) {
            logger.warn(`addImageTexture: Name already used: ${imageTexture.name}` + ` (overriding it)`);
        }
        this.m_imageTextures.set(imageTexture.name, imageTexture);
    }
    /**
     * Return the [[ImageTexture]] registered under the specified name.
     *
     * @param name Name of the [[ImageTexture]].
     */
    getImageTexture(name) {
        return this.m_imageTextures.get(name);
    }
    /**
     * Update the [[TextElement]] with the information taken from the [[PoiTable]] which is
     * referenced in the [[PoiInfo]] of the pointLabel.
     *
     * If the requested [[PoiTable]] is not available yet, the function returns `false`.
     * If the [[PoiTable]] is not defined, or if the references POI has no entry in
     * the [[PoiTable]], no action is taken, and the function returns `false`.
     *
     * If the [[PoiTable]] has been processed, it returns `true`, indicating that this function
     * doesn't have to be called again.
     *
     * @param pointLabel The [[TextElement]] to update.
     *
     * @returns `true` if the [[PoiTable]] has been processed, and the function does not have to be
     *          called again.
     */
    updatePoiFromPoiTable(pointLabel) {
        const poiInfo = pointLabel.poiInfo;
        // PoiTable requires poiName to be defined otherwise mapping via PoiTable is
        // not possible, such as table key is not defined.
        if (poiInfo === undefined ||
            poiInfo.poiTableName === undefined ||
            poiInfo.poiName === undefined) {
            return true;
        }
        // Try to acquire PoiTable
        const poiTableName = poiInfo.poiTableName;
        const poiTable = this.mapView.poiTableManager.getPoiTable(poiTableName);
        // Check if PoiTable is found, but its still loading.
        if (poiTable !== undefined && poiTable.isLoading) {
            // The PoiTable is still loading, we have to try again.
            return false;
        }
        // PoiTable not found or can not be loaded.
        if (poiTable === undefined || !poiTable.loadedOk) {
            PoiManager.notifyMissingPoiTable(poiTableName, poiTable);
            return true;
        }
        // Try to acquire PoiTableEntry.
        const poiName = poiInfo.poiName;
        const poiTableEntry = poiTable.getEntry(poiName);
        if (poiTableEntry === undefined) {
            PoiManager.notifyMissingPoi(poiName, poiTableName);
            return true;
        }
        if (poiTableEntry.iconName !== undefined && poiTableEntry.iconName.length > 0) {
            let imageTexture = poiTableEntry.iconName;
            const poiTechnique = poiInfo.technique;
            if (typeof poiTechnique.imageTexturePrefix === "string") {
                imageTexture = poiTechnique.imageTexturePrefix + imageTexture;
            }
            if (typeof poiTechnique.imageTexturePostfix === "string") {
                imageTexture = imageTexture + poiTechnique.imageTexturePostfix;
            }
            poiInfo.imageTextureName = imageTexture;
        }
        pointLabel.visible =
            poiTableEntry.visible !== undefined ? poiTableEntry.visible : pointLabel.visible;
        pointLabel.priority =
            poiTableEntry.priority !== undefined ? poiTableEntry.priority : pointLabel.priority;
        poiInfo.iconMinZoomLevel =
            poiTableEntry.iconMinLevel !== undefined
                ? poiTableEntry.iconMinLevel
                : poiInfo.iconMinZoomLevel;
        poiInfo.iconMaxZoomLevel =
            poiTableEntry.iconMaxLevel !== undefined
                ? poiTableEntry.iconMaxLevel
                : poiInfo.iconMaxZoomLevel;
        poiInfo.textMinZoomLevel =
            poiTableEntry.textMinLevel !== undefined
                ? poiTableEntry.textMinLevel
                : poiInfo.textMinZoomLevel;
        poiInfo.textMaxZoomLevel =
            poiTableEntry.textMaxLevel !== undefined
                ? poiTableEntry.textMaxLevel
                : poiInfo.textMaxZoomLevel;
        pointLabel.updateMinMaxZoomLevelsFromPoiInfo();
        return true;
    }
    /**
     * Clear internal state. Applicable when switching themes.
     */
    clear() {
        this.m_imageTextures.clear();
        this.m_poiShieldGroups.clear();
    }
    /**
     * Add the LineMarker as a POI with a series of positions. Make sure that the LineMarkers
     * having the same visual all get their `shieldGroupIndex` set appropriately, so it can be taken
     * care of later that not too many of them are rendered (obey `minDistance` attribute).
     */
    addLineMarker(tile, poiGeometry, technique, techniqueIdx, positions) {
        let imageTexture = technique.imageTexture;
        let text;
        if (poiGeometry.stringCatalog !== undefined && poiGeometry.imageTextures !== undefined) {
            imageTexture = poiGeometry.stringCatalog[poiGeometry.imageTextures[0]];
            text = poiGeometry.stringCatalog[poiGeometry.texts[0]];
        }
        if (text === undefined) {
            text = "";
        }
        // let the combined image texture name (name of image in atlas, not the URL) and
        // text of the shield be the group key
        const groupKey = String(imageTexture) + "-" + text;
        let shieldGroupIndex = this.m_poiShieldGroups.get(groupKey);
        if (shieldGroupIndex === undefined) {
            shieldGroupIndex = this.m_poiShieldGroups.size;
            this.m_poiShieldGroups.set(groupKey, shieldGroupIndex);
        }
        // Debugging help to identify the group of a shield :
        // text = groupKey + ": " + text;
        const positionArray = [];
        for (let i = 0; i < positions.count; i += 3) {
            positionArray.push(new THREE.Vector3(positions.getX(i), positions.getY(i), positions.getZ(i)));
        }
        const textElement = this.checkCreateTextElement(tile, text, technique, techniqueIdx, imageTexture, undefined, // TBD for road shields
        undefined, shieldGroupIndex, poiGeometry.featureId, positionArray, undefined, undefined, tile.tileKey.level);
        if (textElement !== undefined) {
            // If the poi icon is rendered, the label that shows its text should also be rendered.
            // The distance rule of the icon should apply, not the one for text (only) labels.
            textElement.ignoreDistance = true;
            tile.addTextElement(textElement);
        }
    }
    /**
     * Create the [[TextElement]] for a POI. Even if the POI has no text, it is required that there
     * is a [[TextElement]], since POIs are hooked onto [[TextElement]]s for sorting.(Sorted by
     * priority attribute).
     */
    checkCreateTextElement(tile, text, technique, techniqueIdx, imageTextureName, poiTableName, poiName, shieldGroupIndex, featureId, x, y, z, storageLevel) {
        let textElement;
        // need some text for now
        if (text === undefined) {
            text = "";
        }
        if (text !== undefined) {
            const priority = technique.priority !== undefined ? technique.priority : 0;
            const positions = Array.isArray(x)
                ? x
                : new THREE.Vector3(x, y, z);
            const displayZoomLevel = this.mapView.zoomLevel;
            textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(text), positions, this.getRenderStyle(tile.dataSource.name, technique), this.getLayoutStyle(tile.dataSource.name, technique), harp_datasource_protocol_1.getPropertyValue(priority, displayZoomLevel), technique.xOffset !== undefined ? technique.xOffset : 0.0, technique.yOffset !== undefined ? technique.yOffset : 0.0, featureId, technique.style, harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, displayZoomLevel), harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, displayZoomLevel));
            textElement.mayOverlap = technique.textMayOverlap === true;
            textElement.reserveSpace = technique.textReserveSpace !== false;
            textElement.alwaysOnTop = technique.alwaysOnTop === true;
            const textIsOptional = technique.textIsOptional === true;
            const iconIsOptional = technique.iconIsOptional !== false;
            const renderTextDuringMovements = !(technique.renderTextDuringMovements === false);
            const iconMayOverlap = technique.iconMayOverlap === undefined
                ? textElement.textMayOverlap
                : technique.iconMayOverlap === true;
            const iconReserveSpace = technique.iconReserveSpace === undefined
                ? textElement.textReservesSpace
                : technique.iconReserveSpace !== false;
            const distanceScale = technique.distanceScale !== undefined
                ? technique.distanceScale
                : TextElementsRenderer_1.DEFAULT_TEXT_DISTANCE_SCALE;
            // imageTextureName may be undefined if a poiTable is used.
            if (imageTextureName === undefined && poiTableName !== undefined) {
                imageTextureName = "";
            }
            else if (imageTextureName !== undefined && poiTableName !== undefined) {
                logger.warn("Possible duplicate POI icon definition via imageTextureName and poiTable!");
            }
            if (imageTextureName !== undefined) {
                textElement.poiInfo = {
                    technique,
                    imageTextureName,
                    poiTableName,
                    poiName,
                    shieldGroupIndex,
                    textElement,
                    textIsOptional,
                    iconIsOptional,
                    renderTextDuringMovements,
                    mayOverlap: iconMayOverlap,
                    reserveSpace: iconReserveSpace,
                    featureId,
                    iconMinZoomLevel: technique.iconMinZoomLevel,
                    iconMaxZoomLevel: technique.iconMaxZoomLevel,
                    textMinZoomLevel: technique.textMinZoomLevel,
                    textMaxZoomLevel: technique.textMaxZoomLevel
                };
                textElement.updateMinMaxZoomLevelsFromPoiInfo();
            }
            else {
                // Select the smaller/larger one of the two min/max values, because the TextElement
                // is a container for both.
                if (textElement.minZoomLevel === undefined) {
                    textElement.minZoomLevel = technique.textMinZoomLevel;
                }
                if (textElement.maxZoomLevel === undefined) {
                    textElement.maxZoomLevel = technique.textMaxZoomLevel;
                }
            }
            textElement.distanceScale = distanceScale;
        }
        return textElement;
    }
    getRenderStyle(dataSourceName, technique) {
        const cacheId = TextStyleCache_1.computeStyleCacheId(dataSourceName, technique, Math.floor(this.mapView.zoomLevel));
        let renderStyle = this.mapView.textRenderStyleCache.get(cacheId);
        if (renderStyle === undefined) {
            const defaultRenderParams = this.mapView.textElementsRenderer.defaultStyle
                .renderParams;
            const hexColor = harp_datasource_protocol_1.getPropertyValue(technique.color, Math.floor(this.mapView.zoomLevel));
            if (hexColor !== undefined) {
                this.m_colorMap.set(cacheId, ColorCache_1.ColorCache.instance.getColor(hexColor));
            }
            const hexBgColor = harp_datasource_protocol_1.getPropertyValue(technique.backgroundColor, Math.floor(this.mapView.zoomLevel));
            if (hexBgColor !== undefined) {
                this.m_colorMap.set(cacheId + "_bg", ColorCache_1.ColorCache.instance.getColor(hexBgColor));
            }
            const renderParams = {
                fontName: harp_utils_1.getOptionValue(technique.fontName, defaultRenderParams.fontName),
                fontSize: {
                    unit: harp_text_canvas_1.FontUnit.Pixel,
                    size: harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.size, Math.floor(this.mapView.zoomLevel)), defaultRenderParams.fontSize.size),
                    backgroundSize: harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.backgroundSize, Math.floor(this.mapView.zoomLevel)), defaultRenderParams.fontSize.backgroundSize)
                },
                fontStyle: technique.fontStyle === "Regular" ||
                    technique.fontStyle === "Bold" ||
                    technique.fontStyle === "Italic" ||
                    technique.fontStyle === "BoldItalic"
                    ? harp_text_canvas_1.FontStyle[technique.fontStyle]
                    : defaultRenderParams.fontStyle,
                fontVariant: technique.fontVariant === "Regular" ||
                    technique.fontVariant === "AllCaps" ||
                    technique.fontVariant === "SmallCaps"
                    ? harp_text_canvas_1.FontVariant[technique.fontVariant]
                    : defaultRenderParams.fontVariant,
                rotation: harp_utils_1.getOptionValue(technique.rotation, defaultRenderParams.rotation),
                color: harp_utils_1.getOptionValue(this.m_colorMap.get(cacheId), defaultRenderParams.color),
                backgroundColor: harp_utils_1.getOptionValue(this.m_colorMap.get(cacheId + "_bg"), defaultRenderParams.backgroundColor),
                opacity: harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.opacity, Math.floor(this.mapView.zoomLevel)), defaultRenderParams.opacity),
                backgroundOpacity: harp_utils_1.getOptionValue(harp_datasource_protocol_1.getPropertyValue(technique.backgroundOpacity, Math.floor(this.mapView.zoomLevel)), defaultRenderParams.backgroundOpacity)
            };
            const themeRenderParams = this.mapView.textElementsRenderer !== undefined
                ? this.mapView.textElementsRenderer.getTextElementStyle(technique.style)
                    .renderParams
                : {};
            renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign({}, themeRenderParams, renderParams));
            this.mapView.textRenderStyleCache.set(cacheId, renderStyle);
        }
        return renderStyle;
    }
    getLayoutStyle(dataSourceName, technique) {
        const cacheId = TextStyleCache_1.computeStyleCacheId(dataSourceName, technique, Math.floor(this.mapView.zoomLevel));
        let layoutStyle = this.mapView.textLayoutStyleCache.get(cacheId);
        if (layoutStyle === undefined) {
            const defaultLayoutParams = this.mapView.textElementsRenderer.defaultStyle
                .layoutParams;
            const layoutParams = {
                tracking: harp_utils_1.getOptionValue(technique.tracking, defaultLayoutParams.tracking),
                leading: harp_utils_1.getOptionValue(technique.leading, defaultLayoutParams.leading),
                maxLines: harp_utils_1.getOptionValue(technique.maxLines, defaultLayoutParams.maxLines),
                lineWidth: harp_utils_1.getOptionValue(technique.lineWidth, defaultLayoutParams.lineWidth),
                canvasRotation: harp_utils_1.getOptionValue(technique.canvasRotation, defaultLayoutParams.canvasRotation),
                lineRotation: harp_utils_1.getOptionValue(technique.lineRotation, defaultLayoutParams.lineRotation),
                wrappingMode: technique.wrappingMode === "None" ||
                    technique.wrappingMode === "Character" ||
                    technique.wrappingMode === "Word"
                    ? harp_text_canvas_1.WrappingMode[technique.wrappingMode]
                    : defaultLayoutParams.wrappingMode,
                horizontalAlignment: technique.hAlignment === "Left" ||
                    technique.hAlignment === "Center" ||
                    technique.hAlignment === "Right"
                    ? harp_text_canvas_1.HorizontalAlignment[technique.hAlignment]
                    : defaultLayoutParams.horizontalAlignment,
                verticalAlignment: technique.vAlignment === "Above" ||
                    technique.vAlignment === "Center" ||
                    technique.vAlignment === "Below"
                    ? harp_text_canvas_1.VerticalAlignment[technique.vAlignment]
                    : defaultLayoutParams.verticalAlignment
            };
            const themeLayoutParams = this.mapView.textElementsRenderer !== undefined
                ? this.mapView.textElementsRenderer.getTextElementStyle(technique.style)
                    .layoutParams
                : {};
            layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign({}, themeLayoutParams, layoutParams));
            this.mapView.textLayoutStyleCache.set(cacheId, layoutStyle);
        }
        return layoutStyle;
    }
}
// Keep track of the missing POI table names, but only warn once.
PoiManager.m_missingPoiTableName = new Map();
PoiManager.m_missingPoiName = new Map();
exports.PoiManager = PoiManager;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PoiRenderer.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PoiRenderer.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const ColorCache_1 = __webpack_require__(/*! ../ColorCache */ "./node_modules/@here/harp-mapview/lib/ColorCache.js");
const BoxBuffer_1 = __webpack_require__(/*! ./BoxBuffer */ "./node_modules/@here/harp-mapview/lib/poi/BoxBuffer.js");
const Poi_1 = __webpack_require__(/*! ./Poi */ "./node_modules/@here/harp-mapview/lib/poi/Poi.js");
const logger = harp_utils_1.LoggerManager.instance.create("PoiRenderer");
const INVALID_RENDER_BATCH = -1;
const tempPos = new THREE.Vector3(0);
/**
 * The `PoiRenderBufferBatch` contains the geometry and the material for all POIs that share the
 * same icon image ([[ImageTexture]]). If the image is the same, all the objects in this batch can
 * share the same material, which makes them renderable in the same draw call, whatever the number
 * of actual objects (WebGL limits apply!).
 *
 * There is a `PoiRenderBufferBatch` for every icon in a texture atlas, since the size of the icon
 * in the atlas as well as the texture coordinates are specified in the `PoiRenderBufferBatch`.
 */
class PoiRenderBufferBatch {
    /**
     * Create the `PoiRenderBufferBatch`.
     *
     * @param mapView The [[MapView]] instance.
     * @param scene The three.js scene to add the POIs to.
     * @param imageItem The icon that will have his material shared.
     * @param renderOrder RenderOrder of the batch geometry's [[Mesh]].
     */
    constructor(mapView, scene, imageItem, renderOrder) {
        this.mapView = mapView;
        this.scene = scene;
        this.imageItem = imageItem;
        this.renderOrder = renderOrder;
        this.color = ColorCache_1.ColorCache.instance.getColor("#000000");
    }
    /**
     * Initialize with the [[ImageTexture]]. Loads the image and sets up the icon size, the texture
     * coordinates and material of the batch. Since image loading is done asynchronously, this
     * batch cannot be rendered right away. MapView#update is being triggered if it loaded
     * successfully.
     */
    init() {
        if (this.boxBuffer === undefined) {
            this.setup();
        }
    }
    /**
     * Clean the `PoiRenderBufferBatch`, remove all icon boxes. Called before starting a new frame.
     */
    reset() {
        if (this.boxBuffer === undefined) {
            this.init();
        }
        this.boxBuffer.reset();
    }
    /**
     * Update the geometry with all the added boxes during the frame.
     */
    update() {
        if (this.boxBuffer === undefined) {
            this.init();
        }
        this.boxBuffer.updateBufferGeometry();
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the
     * `PoiRenderBufferBatch`.
     *
     * @param info The info object to increment with the values from this `PoiRenderBufferBatch`.
     */
    updateMemoryUsage(info) {
        if (this.boxBuffer !== undefined) {
            this.boxBuffer.updateMemoryUsage(info);
        }
    }
    /**
     * Setup texture and material for the batch.
     */
    setup() {
        const bilinear = true;
        // Texture images should be generated with premultiplied alpha
        const premultipliedAlpha = true;
        const iconTexture = new Poi_1.IconTexture(this.imageItem);
        const texture = new THREE.Texture(iconTexture.image.imageData, THREE.UVMapping, undefined, undefined, bilinear ? THREE.LinearFilter : THREE.NearestFilter, bilinear ? THREE.LinearFilter : THREE.NearestFilter, THREE.RGBAFormat);
        texture.needsUpdate = true;
        texture.premultiplyAlpha = premultipliedAlpha;
        texture.generateMipmaps = false; // not needed, always rendered in full size
        this.m_material = new harp_materials_1.IconMaterial({
            map: texture
        });
        this.boxBuffer = new BoxBuffer_1.BoxBuffer(this.m_material, this.renderOrder);
        const mesh = this.boxBuffer.mesh;
        mesh.frustumCulled = false;
        this.scene.add(mesh);
        this.mapView.update();
    }
}
/**
 * Contains all [[PoiRenderBufferBatch]]es. Selects (and initializes) the correct batch for a POI.
 */
class PoiRenderBuffer {
    /**
     * Create the `PoiRenderBuffer`.
     *
     * @param mapView The [[MapView]] to be rendered to.
     * @param textCanvas The [[TextCanvas]] to which scenes this `PoiRenderBuffer` adds geometry to.
     * The actual scene a [[TextElement]] is added to is specified by the renderOrder of the
     * [[TextElement]].
     */
    constructor(mapView, textCanvas) {
        this.mapView = mapView;
        this.textCanvas = textCanvas;
        this.batches = [];
        this.m_batchMap = new Map();
    }
    /**
     * Register the POI and prepare the [[PoiRenderBufferBatch]] for the POI at first usage.
     *
     * @param poiInfo Describes the POI icon.
     */
    registerPoi(poiInfo) {
        const { imageItem, imageTexture, imageTextureName } = poiInfo;
        if (imageItem === undefined ||
            imageTextureName === undefined ||
            imageTexture === undefined) {
            // No image -> invisible -> ignore
            return INVALID_RENDER_BATCH;
        }
        const renderOrder = poiInfo.renderOrder;
        // There is a batch for every ImageDefinition, which could be a texture atlas with many
        // ImageTextures in it.
        const batchKey = imageTexture.image;
        let batchSet = this.m_batchMap.get(batchKey);
        let mappedIndex;
        let bufferBatch;
        if (batchSet === undefined) {
            batchSet = new Map();
            this.m_batchMap.set(batchKey, batchSet);
        }
        mappedIndex = batchSet.get(renderOrder);
        if (mappedIndex !== undefined) {
            return mappedIndex;
        }
        mappedIndex = this.batches.length;
        let layer = this.textCanvas.getLayer(renderOrder);
        if (layer === undefined) {
            this.textCanvas.addText("", tempPos, { layer: renderOrder });
            layer = this.textCanvas.getLayer(renderOrder);
        }
        bufferBatch = new PoiRenderBufferBatch(this.mapView, layer.storage.scene, imageItem, renderOrder);
        bufferBatch.init();
        batchSet.set(renderOrder, mappedIndex);
        this.batches.push(bufferBatch);
        return mappedIndex;
    }
    /**
     * Render a POI image at the specified location.
     *
     * @param poiInfo PoiInfo containing information for rendering the POI icon.
     * @param screenBox Box to render icon into in 2D coordinates.
     * @param opacity Opacity of icon to allow fade in/out.
     */
    addPoi(poiInfo, screenBox, opacity) {
        const batchIndex = this.registerPoi(poiInfo);
        harp_utils_1.assert(batchIndex >= 0);
        if (batchIndex < 0) {
            return INVALID_RENDER_BATCH;
        }
        harp_utils_1.assert(poiInfo.uvBox !== undefined);
        if (this.batches[batchIndex].boxBuffer === undefined) {
            this.batches[batchIndex].init();
        }
        this.batches[batchIndex].boxBuffer.addBox(screenBox, poiInfo.uvBox, this.batches[batchIndex].color, opacity, poiInfo.textElement.renderDistance, poiInfo.textElement);
        return batchIndex;
    }
    /**
     * Retrieve the [[PoiRenderBufferBatch]] from the array at the specified index. May be invalid
     * if the imageTexture could not be found
     *
     * @param index Index into batch array.
     */
    getBatch(index) {
        if (index >= 0) {
            harp_utils_1.assert(index < this.batches.length);
            return this.batches[index];
        }
        // may be invalid if the imageTexture could not be found
        return undefined;
    }
    /**
     * Reset all batches, removing all content from the [[PoiRenderBufferBatch]]es. Called at the
     * beginning of a frame before the POIs are placed.
     */
    reset() {
        for (const batch of this.batches) {
            batch.reset();
        }
    }
    /**
     * Update the geometry of all [[PoiRenderBufferBatch]]es. Called before rendering.
     */
    update() {
        for (const batch of this.batches) {
            batch.update();
        }
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * [[PoiInfo]]s are found, the order of the results is unspecified.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickCallback Callback to be called for every picked element.
     */
    pickTextElements(screenPosition, pickCallback) {
        for (const batch of this.batches) {
            if (batch.boxBuffer === undefined) {
                batch.init();
            }
            batch.boxBuffer.pickBoxes(screenPosition, pickCallback, batch.imageItem.imageData);
        }
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `PoiRenderBuffer`.
     *
     * @param info The info object to increment with the values from this `PoiRenderBuffer`.
     */
    updateMemoryUsage(info) {
        for (const batch of this.batches) {
            if (batch.imageItem.imageData !== undefined) {
                const imageBytes = batch.imageItem.imageData.width * batch.imageItem.imageData.height * 4;
                info.heapSize += imageBytes;
                info.gpuSize += imageBytes;
            }
            if (batch.boxBuffer !== undefined) {
                batch.boxBuffer.updateMemoryUsage(info);
            }
        }
    }
}
/**
 * Manage POI rendering. Uses a [[PoiRenderBuffer]] to actually create the geometry that is being
 * rendered.
 */
class PoiRenderer {
    /**
     * Create the `PoiRenderer` for the specified [[MapView]].
     *
     * @param mapView The MapView to be rendered to.
     * @param textCanvas The [[TextCanvas]] this `PoiRenderer` is associated to. POIs are added to
     * the different layers of this [[TextCanvas]] based on renderOrder.
     */
    constructor(mapView, textCanvas) {
        this.mapView = mapView;
        this.textCanvas = textCanvas;
        // temporary variable to save allocations
        this.m_tempScreenBox = new harp_utils_1.Math2D.Box();
        this.m_renderBuffer = new PoiRenderBuffer(mapView, textCanvas);
    }
    /**
     * Prepare the POI for rendering, and determine which `poiRenderBatch` should be used. If a
     * `poiRenderBatch` is assigned, the POI is ready to be rendered.
     *
     * @param pointLabel TextElement with PoiInfo for rendering the POI icon.
     *
     * @returns `True` if the space is not already allocated by another object (text label or POI)
     */
    prepareRender(pointLabel) {
        const poiInfo = pointLabel.poiInfo;
        if (poiInfo === undefined) {
            return false;
        }
        if (poiInfo.poiRenderBatch === undefined) {
            this.preparePoi(pointLabel);
        }
        return poiInfo.poiRenderBatch !== undefined;
    }
    /**
     * Compute screen box for icon. It is required that `prepareRender` has been successfully called
     * before `isSpaceAvailable` may be called.
     *
     * @param poiInfo PoiInfo containing information for rendering the POI icon.
     * @param screenPosition Position on screen (2D).
     * @param scale Scale to apply to icon.
     * @param screenCollisions Object handling the collision checks for screen-aligned 2D boxes.
     *
     * @returns `True` if box is visible on screen.
     */
    computeScreenBox(poiInfo, screenPosition, scale, screenCollisions, tempScreenBox) {
        if (!this.computeIconScreenBox(poiInfo, screenPosition, scale, tempScreenBox)) {
            return false;
        }
        return screenCollisions.isVisible(tempScreenBox);
    }
    /**
     * Check if the space for the icon is available. It is required that `prepareRender` has been
     * successfully called before `isSpaceAvailable` may be called.
     *
     * @param poiInfo PoiInfo containing information for rendering the POI icon.
     * @param screenPosition Position on screen (2D).
     * @param scale Scale to apply to icon.
     * @param screenCollisions Object handling the collision checks for screen-aligned 2D boxes.
     *
     * @returns `True` if the space is not already allocated by another object (text label or POI)
     */
    isSpaceAvailable(screenCollisions, tempScreenBox) {
        return !screenCollisions.isAllocated(tempScreenBox);
    }
    /**
     * Reset all batches, removing all content from the [[PoiRenderBuffer]]es. Called at the
     * beginning of a frame before the POIs are placed.
     */
    reset() {
        this.m_renderBuffer.reset();
    }
    /**
     * Render the icon.
     *
     * @param poiInfo PoiInfo containing information for rendering the POI icon.
     * @param screenPosition Position on screen (2D):
     * @param screenCollisions Object handling the collision checks for screen-aligned 2D boxes.
     * @param scale Scaling factor to apply to text and icon.
     * @param allocateScreenSpace If `true` screen space will be allocated for the icon.
     * @param opacity Opacity of icon to allow fade in/out.
     */
    renderPoi(poiInfo, screenPosition, screenCollisions, scale, allocateScreenSpace, opacity) {
        harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);
        if (this.computeIconScreenBox(poiInfo, screenPosition, scale, this.m_tempScreenBox)) {
            if (allocateScreenSpace) {
                screenCollisions.allocate(this.m_tempScreenBox);
            }
            this.m_renderBuffer.addPoi(poiInfo, this.m_tempScreenBox, opacity);
        }
    }
    /**
     * Return 'true' if the POI has been successfully prepared for rendering.
     *
     * @param poiInfo PoiInfo containing information for rendering the POI icon.
     */
    poiIsRenderable(poiInfo) {
        return poiInfo.poiRenderBatch !== undefined;
    }
    /**
     * Update the geometry of all [[PoiRenderBuffer]]es. Called before rendering.
     */
    update() {
        this.m_renderBuffer.update();
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * [[PoiInfo]]s are found, the order of the results is unspecified.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickCallback Callback to be called for every picked element.
     */
    pickTextElements(screenPosition, pickCallback) {
        this.m_renderBuffer.pickTextElements(screenPosition, pickCallback);
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `PoiRenderer`.
     *
     * @param info The info object to increment with the values from this `PoiRenderer`.
     */
    getMemoryUsage(info) {
        this.m_renderBuffer.updateMemoryUsage(info);
    }
    /**
     * Compute the screen rectangle from the screen position.
     */
    computeIconScreenBox(poiInfo, screenPosition, scale, 
    /* out */ screenBox) {
        harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);
        const batch = this.m_renderBuffer.getBatch(poiInfo.poiRenderBatch);
        if (batch === undefined) {
            return false;
        }
        const width = poiInfo.computedWidth * scale;
        const height = poiInfo.computedHeight * scale;
        const technique = poiInfo.technique;
        const centerX = screenPosition.x + (technique.iconXOffset !== undefined ? technique.iconXOffset : 0);
        const centerY = screenPosition.y + (technique.iconYOffset !== undefined ? technique.iconYOffset : 0);
        screenBox.x = centerX - width / 2;
        screenBox.y = centerY - height / 2;
        screenBox.w = width;
        screenBox.h = height;
        return true;
    }
    /**
     * Register the POI at the [[PoiRenderBuffer]] which may require some setup, for example loading
     * of the actual image.
     */
    preparePoi(pointLabel) {
        const poiInfo = pointLabel.poiInfo;
        if (poiInfo === undefined || !pointLabel.visible) {
            return;
        }
        if (poiInfo.poiRenderBatch !== undefined || poiInfo.isValid === false) {
            // Already set up, nothing to be done here.
            return;
        }
        if (poiInfo.poiTableName !== undefined) {
            if (this.mapView.poiManager.updatePoiFromPoiTable(pointLabel)) {
                // Remove poiTableName to mark this POI as processed.
                poiInfo.poiTableName = undefined;
                if (!pointLabel.visible) {
                    // PoiTable set this POI to not visible.
                    return;
                }
            }
            else {
                // PoiTable has not been loaded, but is required to determine visibility.
                return;
            }
        }
        const imageTextureName = poiInfo.imageTextureName;
        const imageTexture = this.mapView.poiManager.getImageTexture(imageTextureName);
        if (imageTexture === undefined) {
            // Warn about a missing texture, but only once.
            if (PoiRenderer.m_missingTextureName.get(imageTextureName) === undefined) {
                PoiRenderer.m_missingTextureName.set(imageTextureName, true);
                logger.error(`preparePoi: No imageTexture with name '${imageTextureName}' found`);
            }
            poiInfo.isValid = false;
            return;
        }
        const imageDefinition = imageTexture.image;
        let imageItem = this.mapView.imageCache.findImageByName(imageDefinition);
        if (imageItem === undefined) {
            logger.error(`init: No imageItem found with name '${imageDefinition}'`);
            poiInfo.isValid = false;
            return;
        }
        if (!imageItem.loaded) {
            if (imageItem.loadingPromise !== undefined) {
                // already being loaded, will be rendered once available
                return;
            }
            const imageUrl = imageItem.url;
            const loading = this.mapView.imageCache.loadImage(imageItem);
            if (loading instanceof Promise) {
                loading
                    .then(loadedImageItem => {
                    if (loadedImageItem === undefined) {
                        logger.error(`preparePoi: Failed to load imageItem: '${imageUrl}`);
                        return;
                    }
                    this.setupPoiInfo(poiInfo, imageTexture, loadedImageItem);
                })
                    .catch(error => {
                    logger.error(`preparePoi: Failed to load imageItem: '${imageUrl}`, error);
                    poiInfo.isValid = false;
                });
                return;
            }
            else {
                imageItem = loading;
            }
        }
        this.setupPoiInfo(poiInfo, imageTexture, imageItem);
    }
    /**
     * Setup texture and material for the batch.
     *
     * @param poiInfo [[PoiInfo]] to initialize.
     * @param imageTexture Shared [[ImageTexture]], defines used area in atlas.
     * @param imageItem Shared [[ImageItem]], contains cached image for texture.
     */
    setupPoiInfo(poiInfo, imageTexture, imageItem) {
        harp_utils_1.assert(poiInfo.uvBox === undefined);
        if (imageItem === undefined || imageItem.imageData === undefined) {
            logger.error("setupPoiInfo: No imageItem/imageData found");
            // invalid render batch number
            poiInfo.poiRenderBatch = INVALID_RENDER_BATCH;
            poiInfo.isValid = false;
            return;
        }
        const technique = poiInfo.technique;
        const imageWidth = imageItem.imageData.width;
        const imageHeight = imageItem.imageData.height;
        const iconWidth = imageTexture.width !== undefined ? imageTexture.width : imageWidth;
        const iconHeight = imageTexture.height !== undefined ? imageTexture.height : imageHeight;
        let minS = 0;
        let maxS = 1;
        let minT = 0;
        let maxT = 1;
        let iconScaleH = technique.iconScale !== undefined ? technique.iconScale : 1;
        let iconScaleV = technique.iconScale !== undefined ? technique.iconScale : 1;
        const width = imageTexture.width !== undefined ? imageTexture.width : imageWidth;
        const height = imageTexture.height !== undefined ? imageTexture.height : imageHeight;
        const xOffset = imageTexture.xOffset !== undefined ? imageTexture.xOffset : 0;
        const yOffset = imageTexture.yOffset !== undefined ? imageTexture.yOffset : 0;
        minS = xOffset / imageWidth;
        maxS = (xOffset + width) / imageWidth;
        const flipY = true;
        if (flipY) {
            minT = (imageHeight - yOffset) / imageHeight;
            maxT = (imageHeight - yOffset - height) / imageHeight;
        }
        else {
            minT = yOffset / imageHeight;
            maxT = (yOffset + height) / imageHeight;
        }
        // minS += 0.5 / imageWidth;
        // maxS += 0.5 / imageWidth;
        // minT += 0.5 / imageHeight;
        // maxT += 0.5 / imageHeight;
        // By default, iconScaleV should be equal to iconScaleH, whatever is set in the style.
        if (technique.screenWidth !== undefined) {
            iconScaleV = iconScaleH = technique.screenWidth / imageWidth;
        }
        if (technique.screenHeight !== undefined) {
            iconScaleV = technique.screenHeight / imageHeight;
            if (technique.screenWidth === undefined) {
                iconScaleH = iconScaleV;
            }
        }
        // compute stored values in imageTexture
        poiInfo.computedWidth = iconWidth * iconScaleH;
        poiInfo.computedHeight = iconHeight * iconScaleV;
        poiInfo.uvBox = {
            s0: minS,
            t0: maxT,
            s1: maxS,
            t1: minT
        };
        poiInfo.imageItem = imageItem;
        poiInfo.imageTexture = imageTexture;
        poiInfo.poiRenderBatch = this.m_renderBuffer.registerPoi(poiInfo);
        poiInfo.isValid = true;
        harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);
    }
}
// keep track of the missing textures, but only warn once
PoiRenderer.m_missingTextureName = new Map();
exports.PoiRenderer = PoiRenderer;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const logger = harp_utils_1.LoggerManager.instance.create("PoiTable");
/**
 * Class to store and maintain individual POI information for the [[PoiTable]].
 */
class PoiTableEntry {
    /**
     * Verify that the JSON description of the POI table entry is valid.
     *
     * @param jsonEntry JSON description of the POI table entry.
     *
     * @returns `true` if the `jsonEntry` is valid.
     */
    static verifyJSON(jsonEntry) {
        let isOK = typeof jsonEntry.name === "string" &&
            jsonEntry.name.length > 0 &&
            (jsonEntry.altNames === undefined || Array.isArray(jsonEntry.altNames)) &&
            (jsonEntry.stackMode === undefined ||
                jsonEntry.stackMode === "yes" ||
                jsonEntry.stackMode === "no" ||
                jsonEntry.stackMode === "parent") &&
            (jsonEntry.visible === undefined || typeof jsonEntry.visible === "boolean") &&
            (jsonEntry.priority === undefined || typeof jsonEntry.priority === "number") &&
            (jsonEntry.iconMinLevel === undefined || typeof jsonEntry.iconMinLevel === "number") &&
            (jsonEntry.iconMaxLevel === undefined || typeof jsonEntry.iconMaxLevel === "number") &&
            (jsonEntry.textMinLevel === undefined || typeof jsonEntry.textMinLevel === "number") &&
            (jsonEntry.textMaxLevel === undefined || typeof jsonEntry.textMaxLevel === "number");
        if (isOK && jsonEntry.altNames !== undefined) {
            const altNames = jsonEntry.altNames;
            for (const str in altNames) {
                if (typeof str !== "string") {
                    isOK = false;
                    break;
                }
            }
        }
        return isOK;
    }
    /**
     * Setup the [[PoiTableEntry]] from the JSON description. It is assumed that the jsonEntry has
     * been verified with [[PoiTableEntry#verifyJSON]].
     *
     * @param jsonEntry JSON description of the POI table entry. Expected to have been verified with
     *          [[PoiTableEntry#verifyJSON]].
     */
    setup(jsonEntry) {
        this.name = jsonEntry.name;
        this.altNames = jsonEntry.altNames;
        this.iconName = jsonEntry.iconName;
        this.visible = jsonEntry.visible;
        this.priority = jsonEntry.priority;
        this.iconMinLevel = jsonEntry.iconMinLevel;
        this.iconMaxLevel = jsonEntry.iconMaxLevel;
        this.textMinLevel = jsonEntry.textMinLevel;
        this.textMaxLevel = jsonEntry.textMaxLevel;
        switch (jsonEntry.stackMode) {
            case "yes":
                this.stackMode = harp_datasource_protocol_1.PoiStackMode.Show;
                break;
            case "no":
                this.stackMode = harp_datasource_protocol_1.PoiStackMode.Hide;
                break;
            case "parent":
                this.stackMode = harp_datasource_protocol_1.PoiStackMode.ShowParent;
                break;
            default:
        }
    }
}
/**
 * The `PoiTable` stores individual information for each POI type. If a [[TextElement]] has a
 * reference to a PoiTable (if TextElement.poiInfo.poiTableName is set), information for the
 * TextElement and its icon are read from the PoiTable.
 *
 * The key to look up the POI is taken from the data, in case of OSM data with TileZen data, the
 * `poiNameField` is set to `kind`, which makes the content of the field `kind` in the data the key
 * to look up the POIs in the [[PoiTable]].
 *
 * On the side of the [[PoiTable]], the key to look up the PoiTableEntry is either the property
 * "name" of the [[PoiTableEntry]] (which should be unique), or the alternative list of names
 * `altNames`, where each value should also be unique. If the property `useAltNamesForKey` is set to
 * `true`, the `altNames` will be used.
 */
class PoiTable {
    /**
     * Creates an instance of PoiTable.
     *
     * @param {string} name Name of the `PoiTable`. Must be unique.
     * @param {boolean} useAltNamesForKey Pass `true` to use the contents of the property `altNames`
     *          to find a [[PoiTableEntry]] in the table.
     */
    constructor(name, useAltNamesForKey) {
        this.name = name;
        this.useAltNamesForKey = useAltNamesForKey;
        /**
         * Stores the list of [[PoiTableEntry]]s.
         */
        this.poiList = new Array();
        /**
         * Dictionary to look up for [[PoiTableEntry]] quickly. The dictionary is either created for
         * the `name` property of the [[PoiTableEntry]], which will identify POI, or for all of
         * alternative the names defined in `altNames` of [[PoiTableEntry]] JSON object.
         * Value assigned to key it is the index to [[poiList]] array which contain actual
         * [[PoiTabelEntry]] objects.
         */
        this.poiDict = new Map();
        this.m_isLoading = false;
        this.m_loadedOk = undefined;
    }
    /**
     * Returns `true` if the table is currently being loaded, `false` otherwise.
     *
     * @readonly
     */
    get isLoading() {
        return this.m_isLoading;
    }
    /**
     * Returns `true` if the table has been loaded correctly, `false` otherwise.
     *
     * @readonly
     */
    get loadedOk() {
        return this.m_loadedOk === true;
    }
    /**
     * Gets [[PoiTableEntry]] for poi name specified.
     *
     * @param poiName poi name or one of its alternative names if [[useAltNamesForKey]] is
     * set to `true`.
     * @returns [[PoiTableEntry]] object or undefined if name was not found in dictionary.
     */
    getEntry(poiName) {
        const entryIdx = this.poiDict.get(poiName);
        if (entryIdx !== undefined) {
            if (entryIdx < this.poiList.length) {
                return this.poiList[entryIdx];
            }
            else {
                throw new Error("Poi table entry index out of stored list!");
            }
        }
        return undefined;
    }
    /**
     * Start to load the PoiTable from the specified URL. Can only be called once per table.
     *
     * @param {string} poiTableUrl URL that points to the JSON file.
     *
     * @returns {Promise<boolean>} Promise is being resolved once the JSON file has been fetched and
     *          the `PoiTable` has been set up.
     */
    load(poiTableUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.m_loadedOk !== undefined) {
                // Only load once.
                return true;
            }
            this.m_loadedOk = false;
            const response = yield fetch(poiTableUrl);
            if (!response.ok) {
                throw new Error(`load: Cannot load POI table at ${poiTableUrl}:` + ` ${response.statusText}`);
            }
            const jsonPoiTable = (yield response.json());
            if (jsonPoiTable === undefined) {
                logger.info(`load: TextureAtlas empty: ${poiTableUrl}`);
                return true;
            }
            this.startLoading();
            try {
                logger.log(`load: Loading POI table '${poiTableUrl}' for table '${this.name}'`);
                if (jsonPoiTable.poiList !== undefined && Array.isArray(jsonPoiTable.poiList)) {
                    for (const tableEntry of jsonPoiTable.poiList) {
                        if (PoiTableEntry.verifyJSON(tableEntry)) {
                            const newPoiEntry = new PoiTableEntry();
                            newPoiEntry.setup(tableEntry);
                            const entryIdx = this.poiList.push(newPoiEntry) - 1;
                            if (!this.useAltNamesForKey) {
                                // Use actual name of entry as the key
                                if (newPoiEntry.name === undefined) {
                                    logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ` +
                                        `. No name set in entry: ${tableEntry}.`);
                                }
                                else {
                                    this.poiDict.set(newPoiEntry.name, entryIdx);
                                }
                            }
                            else {
                                if (newPoiEntry.altNames !== undefined &&
                                    newPoiEntry.altNames.length > 0) {
                                    // Use the list of alternative names as keys.
                                    for (const altName of newPoiEntry.altNames) {
                                        this.poiDict.set(altName, entryIdx);
                                    }
                                }
                                else {
                                    logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ` +
                                        `No alternative names set in entry: ${JSON.stringify(tableEntry)}.`);
                                }
                            }
                        }
                        else {
                            logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ${JSON.stringify(tableEntry)}`);
                        }
                    }
                }
                this.m_loadedOk = true;
                this.finishedLoading();
            }
            catch (ex) {
                logger.error(`load: Failed to load POI table ` + `'${poiTableUrl}' : ${ex}`);
                this.m_loadedOk = false;
                this.finishedLoading();
                return false;
            }
            return true;
        });
    }
    startLoading() {
        this.m_isLoading = true;
    }
    finishedLoading() {
        this.m_isLoading = false;
    }
}
exports.PoiTable = PoiTable;
/**
 * The `PoiTableManager` manages the list of [[PoiTables]] that can be defined in the [[Theme]]
 * file.
 */
class PoiTableManager {
    /**
     * Creates an instance of PoiTableManager.
     * @param {MapView} mapView Owning [[MapView]].
     */
    constructor(mapView) {
        this.mapView = mapView;
        this.m_isLoading = false;
        this.m_poiTables = new Map();
    }
    /**
     * Load the [[PoiTable]]s that are stored in the [[MapView]]s [[Theme]]. Note that duplicate
     * names of [[PoiTable]]s in the [[Theme]] will lead to inaccessible [[PoiTable]]s.
     *
     * @param {Theme} theme [[Theme]] containing all [[PoiTable]]s to load.
     *
     * @returns {Promise<void>} Resolved once all the [[PoiTable]]s in the [[Theme]] have been
     *          loaded.
     */
    loadPoiTables(theme) {
        return __awaiter(this, void 0, void 0, function* () {
            const finished = new Promise(resolve => {
                this.clear();
                // Add the POI tables defined in the theme.
                if (theme.poiTables !== undefined) {
                    this.startLoading();
                    // Gather promises to signal the success of having loaded them all
                    const loadPromises = new Array();
                    // Ensure that all resources referenced in theme by relative URLs are in fact
                    // relative to theme.
                    const themeUrl = theme.url;
                    const childUrlResolver = themeUrl === undefined
                        ? undefined
                        : harp_utils_1.composeUrlResolvers((childUrl) => harp_utils_1.resolveReferenceUrl(themeUrl, childUrl), harp_utils_1.defaultUrlResolver);
                    theme.poiTables.forEach((poiTableRef) => {
                        if (poiTableRef !== undefined &&
                            poiTableRef.name !== undefined &&
                            typeof poiTableRef.name === "string") {
                            const poiTable = new PoiTable(poiTableRef.name, poiTableRef.useAltNamesForKey !== false);
                            if (poiTableRef.url !== undefined && typeof poiTableRef.url === "string") {
                                this.addTable(poiTable);
                                const tableUrl = childUrlResolver === undefined
                                    ? poiTableRef.url
                                    : childUrlResolver(poiTableRef.url);
                                loadPromises.push(poiTable.load(tableUrl));
                            }
                            else {
                                logger.error(`POI table definition has no valid url: ${poiTableRef}`);
                            }
                        }
                        else {
                            logger.error(`POI table definition has no valid name: ${poiTableRef}`);
                        }
                    });
                    if (loadPromises.length > 0) {
                        Promise.all(loadPromises).then(() => {
                            this.finishLoading();
                            resolve();
                        });
                    }
                    else {
                        this.finishLoading();
                        resolve();
                    }
                }
                else {
                    this.finishLoading();
                    resolve();
                }
            });
            return finished;
        });
    }
    /**
     * Clear the list of [[PoiTable]]s.
     */
    clear() {
        this.m_poiTables = new Map();
    }
    /**
     * Return the map of [[PoiTable]]s.
     */
    get poiTables() {
        return this.m_poiTables;
    }
    /**
     * Manually add a [[PoiTable]]. Normally, the [[PoiTables]]s are specified in the [[Theme]].
     * Ensure that the name is unique.
     */
    addTable(poiTable) {
        this.m_poiTables.set(poiTable.name, poiTable);
    }
    /**
     * Retrieve a [[PoiTable]] by name.
     *
     * @param {(string | undefined)} poiTableName Name of the [[PoiTable]].
     *
     * @returns {(PoiTable | undefined)} The found [[poiTable]] if it could be found, `undefined`
     *          otherwise.
     */
    getPoiTable(poiTableName) {
        return poiTableName === undefined ? undefined : this.m_poiTables.get(poiTableName);
    }
    /**
     * Return `true` if the [[PoiTable]]s have finished loading.
     *
     * @readonly
     */
    get finishedLoading() {
        return !this.m_isLoading;
    }
    startLoading() {
        this.m_isLoading = true;
    }
    finishLoading() {
        this.m_isLoading = false;
    }
}
exports.PoiTableManager = PoiTableManager;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/SimplePath.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/SimplePath.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * @hidden
 */
class SimpleLineCurve extends THREE.LineCurve {
    constructor(v1, v2) {
        super(v1, v2);
    }
    getLengths() {
        if (this.m_lengths === undefined) {
            this.m_lengths = [0, this.v2.distanceTo(this.v1)];
        }
        return this.m_lengths;
    }
}
exports.SimpleLineCurve = SimpleLineCurve;
/**
 * @hidden
 */
class PathParam {
    constructor(path, index, t) {
        this.path = path;
        this.index = index;
        this.t = t;
    }
    get curve() {
        return this.path.curves[this.index];
    }
    get point() {
        if (this.m_point === undefined) {
            this.m_point = this.curve.getPoint(this.t);
        }
        return this.m_point;
    }
}
exports.PathParam = PathParam;
/**
 * @hidden
 */
class SimplePath extends THREE.Path {
    constructor() {
        super();
    }
    getLengths() {
        if (this.m_cache) {
            return this.m_cache;
        }
        let sum = 0;
        const lengths = new Array();
        lengths.push(0);
        this.curves.forEach(curve => {
            const lineCurve = curve;
            sum += lineCurve.v1.distanceTo(lineCurve.v2);
            lengths.push(sum);
        });
        this.m_cache = lengths;
        return lengths;
    }
    getParamAt(t) {
        const distance = t * this.getLength();
        const curveLengths = this.getCurveLengths();
        for (let index = 0; index < curveLengths.length; ++index) {
            if (curveLengths[index] < distance) {
                continue;
            }
            const diff = curveLengths[index] - distance;
            const curve = this.curves[index];
            const segmentLength = curve.getLength();
            const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
            return new PathParam(this, index, u);
        }
        return null;
    }
}
exports.SimplePath = SimplePath;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElement.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElement.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "./node_modules/@here/harp-text-canvas/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
/**
 * State of fading.
 */
var FadingState;
(function (FadingState) {
    FadingState[FadingState["Undefined"] = 0] = "Undefined";
    FadingState[FadingState["FadingIn"] = 1] = "FadingIn";
    FadingState[FadingState["FadedIn"] = 2] = "FadedIn";
    FadingState[FadingState["FadingOut"] = -1] = "FadingOut";
    FadingState[FadingState["FadedOut"] = -2] = "FadedOut";
})(FadingState = exports.FadingState || (exports.FadingState = {}));
/**
 * State of loading.
 */
var LoadingState;
(function (LoadingState) {
    LoadingState[LoadingState["Requested"] = 0] = "Requested";
    LoadingState[LoadingState["Loaded"] = 1] = "Loaded";
    LoadingState[LoadingState["Initialized"] = 2] = "Initialized";
})(LoadingState = exports.LoadingState || (exports.LoadingState = {}));
/**
 * Time to fade in/fade out the labels in milliseconds.
 */
exports.DEFAULT_FADE_TIME = 800;
/**
 * State of rendering of the icon and text part of the `TextElement`. Mainly for fading the elements
 * in and out, to compute the opacity.
 *
 * @hidden
 */
class RenderState {
    /**
     * Create a `RenderState`.
     *
     * @param state Fading state.
     * @param value Current fading value [0..1].
     * @param startTime Time stamp the fading started.
     * @param opacity Computed opacity depending on value.
     * @param lastFrameNumber Latest frame the elements was rendered, allows to detect some less
     *                        obvious states, like popping up after being hidden.
     * @param fadingTime Time used to fade in or out.
     */
    constructor(state = FadingState.Undefined, value = 0.0, startTime = 0, opacity = 1.0, lastFrameNumber = Number.MIN_SAFE_INTEGER, fadingTime = exports.DEFAULT_FADE_TIME) {
        this.state = state;
        this.value = value;
        this.startTime = startTime;
        this.opacity = opacity;
        this.lastFrameNumber = lastFrameNumber;
        this.fadingTime = fadingTime;
    }
    /**
     * Reset existing `RenderState` to appear like a fresh state.
     */
    reset() {
        this.state = FadingState.Undefined;
        this.value = 0.0;
        this.startTime = 0.0;
        this.opacity = 1.0;
        this.lastFrameNumber = Number.MIN_SAFE_INTEGER;
    }
    /**
     * @returns `true` if element is either fading in or fading out.
     */
    isFading() {
        const fading = this.state === FadingState.FadingIn || this.state === FadingState.FadingOut;
        return fading;
    }
    /**
     * @returns `true` if element is fading in.
     */
    isFadingIn() {
        const fadingIn = this.state === FadingState.FadingIn;
        return fadingIn;
    }
    /**
     * @returns `true` if element is fading out.
     */
    isFadingOut() {
        const fadingOut = this.state === FadingState.FadingOut;
        return fadingOut;
    }
    /**
     * @returns `true` if element is done with fading in.
     */
    isFadedIn() {
        const fadedIn = this.state === FadingState.FadedIn;
        return fadedIn;
    }
    /**
     * @returns `true` if element is done with fading out.
     */
    isFadedOut() {
        const fadedOut = this.state === FadingState.FadedOut;
        return fadedOut;
    }
    /**
     * @returns `true` if element is either faded in, is fading in or is fading out.
     */
    isVisible() {
        const visible = this.state === FadingState.FadingIn ||
            this.state === FadingState.FadedIn ||
            this.state === FadingState.FadingOut;
        return visible;
    }
}
exports.RenderState = RenderState;
/**
 * `TextElement` is used to create 2D text elements (for example, labels).
 */
class TextElement {
    /**
     * Creates a new `TextElement`.
     *
     * @param text The text to display.
     * @param points The position in world coordinates or a list of points in world coordinates for
     *              a curved text.
     * @param renderParams `TextElement` text rendering parameters.
     * @param layoutParams `TextElement` text layout parameters.
     * @param priority The priority of the `TextElement. Elements with the highest priority get
     *              placed first, elements with priority of `0` are placed last, elements with a
     *              negative value are always rendered, ignoring priorities and allowing
     *              overrides.
     * @param xOffset Optional X offset of this `TextElement` in screen coordinates.
     * @param yOffset Optional Y offset of this `TextElement` in screen coordinates.
     * @param featureId Optional number to identify feature (originated from `OmvDataSource`).
     * @param fadeNear Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the
     *              label starts fading out (opacity decreases).
     * @param fadeFar Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the
     *              label becomes transparent. A value of <= 0.0 disables fading.
     */
    constructor(text, points, renderParams, layoutParams, priority = 0, xOffset, yOffset, featureId, style, fadeNear, fadeFar) {
        this.text = text;
        this.points = points;
        this.renderParams = renderParams;
        this.layoutParams = layoutParams;
        this.priority = priority;
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.featureId = featureId;
        this.style = style;
        this.fadeNear = fadeNear;
        this.fadeFar = fadeFar;
        /**
         * Determines visibility. If set to `false`, it will not be rendered.
         */
        this.visible = true;
        /**
         * Scaling factor of text. Defaults to 0.5, reducing the size ot 50% in the distance.
         */
        this.distanceScale = 0.5;
        /**
         * If specified, determines the render order between `TextElement`s. The number different
         * renderOrders should be as small as possible, because every specific `renderOrder` may result
         * in one or more draw calls.
         *
         * TextElements with the same integer `renderOrder` will be rendered in the same batch.
         *
         * The `renderOrder` of `TextElement`s are only relative to other `TextElement`s, and not other
         * map elements.
         *
         * A `TextElement` with a higher `renderOrder` will be rendered after a `TextElement` with a
         * lower `renderOrder`.
         */
        this.renderOrder = 0;
        /**
         * @hidden
         * Used during sorting.
         */
        this.sortPriority = 0;
        if (renderParams instanceof harp_text_canvas_1.TextRenderStyle) {
            this.renderStyle = renderParams;
        }
        if (layoutParams instanceof harp_text_canvas_1.TextLayoutStyle) {
            this.layoutStyle = layoutParams;
        }
    }
    /**
     * The position of this text element in world coordinates or the first point of the path used to
     * render a curved text.
     */
    get position() {
        if (this.points instanceof Array) {
            const p = this.points[0];
            return p;
        }
        return this.points;
    }
    /**
     * The list of points in world coordinates used to render the text along a path or `undefined`.
     */
    get path() {
        if (this.points instanceof Array) {
            return this.points;
        }
        return undefined;
    }
    /**
     * If `true`, `TextElement` is allowed to overlap other labels or icons of lower priority.
     *
     * @default `false`
     */
    get textMayOverlap() {
        return this.mayOverlap === true;
    }
    set textMayOverlap(mayOverlap) {
        this.mayOverlap = mayOverlap;
    }
    /**
     * If `true`, `TextElement` will reserve screen space, other markers of lower priority will not
     * be able to overlap.
     *
     * @default `true`
     */
    get textReservesSpace() {
        return this.reserveSpace !== false;
    }
    set textReservesSpace(reserveSpace) {
        this.reserveSpace = reserveSpace;
    }
    /**
     * Determine if the `TextElement` is a line marker.
     *
     * @returns `true` if this `TextElement` is a line marker.
     */
    get isLineMarker() {
        return (this.points !== undefined &&
            (this.m_poiInfo !== undefined && harp_datasource_protocol_1.isLineMarkerTechnique(this.m_poiInfo.technique)));
    }
    /**
     * Return the last distance that has been computed for sorting during placement. This may not be
     * the actual distance if the camera is moving, as the distance is computed only during
     * placement. If the property `alwaysOnTop` is true, the value returned is always `0`.
     *
     * @returns 0 or negative distance to camera.
     */
    get renderDistance() {
        return this.alwaysOnTop === true
            ? 0
            : this.currentViewDistance !== undefined
                ? -this.currentViewDistance
                : 0;
    }
    /**
     * Contains additional information about icon to be rendered along with text.
     */
    get poiInfo() {
        return this.m_poiInfo;
    }
    set poiInfo(poiInfo) {
        this.m_poiInfo = poiInfo;
        if (poiInfo !== undefined) {
            const poiRenderOrder = this.renderOrder !== undefined ? this.renderOrder : 0;
            poiInfo.renderOrder = poiRenderOrder;
        }
    }
    /**
     * Update the minZoomLevel and maxZoomLevel from the values set in [[PoiInfo]].
     * Selects the smaller/larger one of the two min/max values for icon and text, because the
     * TextElement is a container for both.
     */
    updateMinMaxZoomLevelsFromPoiInfo() {
        if (this.poiInfo !== undefined) {
            if (this.minZoomLevel === undefined) {
                this.minZoomLevel = harp_utils_1.MathUtils.min2(this.poiInfo.iconMinZoomLevel, this.poiInfo.textMinZoomLevel);
            }
            if (this.maxZoomLevel === undefined) {
                this.maxZoomLevel = harp_utils_1.MathUtils.max2(this.poiInfo.iconMaxZoomLevel, this.poiInfo.textMaxZoomLevel);
            }
        }
    }
}
exports.TextElement = TextElement;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "./node_modules/@here/harp-text-canvas/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const ColorCache_1 = __webpack_require__(/*! ../ColorCache */ "./node_modules/@here/harp-mapview/lib/ColorCache.js");
const DebugContext_1 = __webpack_require__(/*! ../DebugContext */ "./node_modules/@here/harp-mapview/lib/DebugContext.js");
const PickHandler_1 = __webpack_require__(/*! ../PickHandler */ "./node_modules/@here/harp-mapview/lib/PickHandler.js");
const PoiRenderer_1 = __webpack_require__(/*! ../poi/PoiRenderer */ "./node_modules/@here/harp-mapview/lib/poi/PoiRenderer.js");
const SimplePath_1 = __webpack_require__(/*! ./SimplePath */ "./node_modules/@here/harp-mapview/lib/text/SimplePath.js");
const TextElement_1 = __webpack_require__(/*! ./TextElement */ "./node_modules/@here/harp-mapview/lib/text/TextElement.js");
const TextStyleCache_1 = __webpack_require__(/*! ./TextStyleCache */ "./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js");
const DEFAULT_STYLE_NAME = "default";
const DEFAULT_FONT_CATALOG_NAME = "default";
const MAX_INITIALIZED_TEXT_ELEMENTS_PER_FRAME = Infinity;
const MIN_GLYPH_COUNT = 1024;
const MAX_GLYPH_COUNT = 32768;
/**
 * Default number of labels/POIs rendered in the scene
 */
const DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS = 500;
/**
 * Default distance scale. Will be applied if distanceScale is not defined in the technique.
 * Defines the scale that will be applied to labeled icons (icon and text) in the distance.
 */
exports.DEFAULT_TEXT_DISTANCE_SCALE = 0.5;
/**
 * Number of elements that are put into second queue. This second chance queue is used to render
 * TextElements that have not been on screen before. This is a quick source for elements that can
 * appear when the camera moves a bit, before new elements are placed.
 */
const DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS = 300;
/**
 * Maximum distance for text labels expressed as a ratio of distance to from the camera (0) to the
 * far plane (1.0). May be synchronized with fog value ?
 */
const DEFAULT_MAX_DISTANCE_RATIO_FOR_TEXT_LABELS = 0.99;
/**
 * Distance to the camera (range: `[0.0, 1.0]`) from which label start to scale.
 */
const DEFAULT_LABEL_SCALE_START_DISTANCE = 0.4;
/**
 * Maximum number of recommended labels. If more labels are encountered, the "overloaded" mode is
 * set, which modifies the behavior of label placement and rendering, trying to keep delivering an
 * interactive performance. The overloaded mode should not be activated if the [[MapView]] is
 * rendering a static image (camera not moving and no animation running).
 */
const OVERLOAD_LABEL_LIMIT = 20000;
/**
 * If "overloaded" is `true`:
 *
 * Default number of labels/POIs placed in the scene. They are rendered only if they fit. If the
 * camera is not moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].
 */
const OVERLOAD_PLACED_LABEL_LIMIT = 100;
/**
 * If "overloaded" is `true`:
 *
 * Maximum time in milliseconds available for placement. If value is <= 0, or if the camera is not
 * moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].
 */
const OVERLOAD_PLACEMENT_TIME_LIMIT = 5;
/**
 * If "overloaded" is `true`:
 *
 * Maximum time in milliseconds available for rendering. If value is <= 0, or if the camera is not
 * moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].
 */
const OVERLOAD_RENDER_TIME_LIMIT = 10;
/**
 * Minimum number of pixels per character. Used during estimation if there is enough screen space
 * available to render a text.
 */
const MIN_AVERAGE_CHAR_WIDTH = 5;
// Development flag: Enable debug print.
const PRINT_LABEL_DEBUG_INFO = false;
const logger = harp_utils_1.LoggerManager.instance.create("TextElementsRenderer");
const tempBox = new THREE.Box2();
const tempBoxes = [];
const tempBox2D = new harp_utils_1.Math2D.Box();
const tempPosition = new THREE.Vector3();
const tempPoiPosition = new THREE.Vector3(0, 0, 0);
const tempScreenPosition = new THREE.Vector2();
const tempPoiScreenPosition = new THREE.Vector2();
class TileTextElements {
    constructor(tile, textElements) {
        this.tile = tile;
        this.textElements = textElements;
    }
}
class TextElementLists {
    constructor(priority, textElementLists) {
        this.priority = priority;
        this.textElementLists = textElementLists;
    }
    /**
     * Sum up the number of elements in all lists.
     */
    count() {
        let n = 0;
        for (const list of this.textElementLists) {
            n += list.textElements.length;
        }
        return n;
    }
}
/**
 * @hidden
 *
 * Internal class to manage all text rendering.
 */
class TextElementsRenderer {
    /**
     * Create the `TextElementsRenderer` which selects which labels should be placed on screen as
     * a preprocessing step, which is not done every frame, and also renders the placed
     * [[TextElement]]s every frame.
     *
     * @param m_mapView MapView to render into
     * @param m_screenCollisions General 2D screen occlusion management, may be shared between
     *     instances.
     * @param m_screenProjector Projects 3D coordinates into screen space.
     * @param m_minNumGlyphs Minimum number of glyphs (per-layer). Controls the size of internal
     * buffers.
     * @param m_maxNumGlyphs Maximum number of glyphs (per-layer). Controls the size of internal
     * buffers.
     * @param m_theme Theme defining  text styles.
     * @param m_maxNumVisibleLabels Maximum number of visible [[TextElement]]s.
     * @param m_numSecondChanceLabels Number of [[TextElement]] that will be rendered again.
     * @param m_maxDistanceRatioForLabels Maximum distance for [[TextElement]] and icons, expressed
     *          as a fraction of the distance between the near and far plane [0, 1.0].
     *          Defaults to `0.99`.
     * @param m_labelStartScaleDistance Distance at which the [[TextElement]]s start to apply their
     *          `distanceScale` value, expressed as a fraction of the distance between the near and
     *          far plane [0, 1.0]. Defaults to `0.4`.
     */
    constructor(m_mapView, m_screenCollisions, m_screenProjector, m_minNumGlyphs, m_maxNumGlyphs, m_theme, m_maxNumVisibleLabels, m_numSecondChanceLabels, m_maxDistanceRatioForLabels, m_labelStartScaleDistance) {
        this.m_mapView = m_mapView;
        this.m_screenCollisions = m_screenCollisions;
        this.m_screenProjector = m_screenProjector;
        this.m_minNumGlyphs = m_minNumGlyphs;
        this.m_maxNumGlyphs = m_maxNumGlyphs;
        this.m_theme = m_theme;
        this.m_maxNumVisibleLabels = m_maxNumVisibleLabels;
        this.m_numSecondChanceLabels = m_numSecondChanceLabels;
        this.m_maxDistanceRatioForLabels = m_maxDistanceRatioForLabels;
        this.m_labelStartScaleDistance = m_labelStartScaleDistance;
        this.m_initializedTextElementCount = 0;
        this.m_textRenderers = [];
        this.m_textStyles = new Map();
        this.m_defaultStyle = {
            name: DEFAULT_STYLE_NAME,
            fontCatalog: DEFAULT_FONT_CATALOG_NAME,
            renderParams: this.m_mapView.textRenderStyleCache.get(TextStyleCache_1.DEFAULT_TEXT_STYLE_CACHE_ID).params,
            layoutParams: this.m_mapView.textLayoutStyleCache.get(TextStyleCache_1.DEFAULT_TEXT_STYLE_CACHE_ID).params
        };
        this.m_lastRenderedTextElements = [];
        this.m_secondChanceTextElements = [];
        this.m_tmpVector = new THREE.Vector2();
        this.m_overloaded = false;
        this.m_catalogsLoading = 0;
        if (this.m_minNumGlyphs === undefined) {
            this.m_minNumGlyphs = MIN_GLYPH_COUNT;
        }
        if (this.m_maxNumGlyphs === undefined) {
            this.m_maxNumGlyphs = MAX_GLYPH_COUNT;
        }
        if (this.m_maxNumVisibleLabels === undefined) {
            this.m_maxNumVisibleLabels = DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS;
        }
        if (this.m_numSecondChanceLabels === undefined) {
            this.m_numSecondChanceLabels = DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS;
        }
        if (this.m_maxDistanceRatioForLabels === undefined) {
            this.m_maxDistanceRatioForLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_TEXT_LABELS;
        }
        if (this.m_labelStartScaleDistance === undefined) {
            this.m_labelStartScaleDistance = DEFAULT_LABEL_SCALE_START_DISTANCE;
        }
        this.initializeDefaultAssets();
        this.initializeTextCanvases();
    }
    /**
     * Render the text using the specified camera into the current canvas.
     *
     * @param camera Orthographic camera to use.
     */
    renderText(camera) {
        const debugGlyphs = DebugContext_1.debugContext.getValue("DEBUG_GLYPHS");
        if (debugGlyphs !== undefined &&
            this.m_debugGlyphTextureCacheMesh !== undefined &&
            this.m_debugGlyphTextureCacheWireMesh !== undefined) {
            this.m_debugGlyphTextureCacheMesh.visible = debugGlyphs;
            this.m_debugGlyphTextureCacheWireMesh.visible = debugGlyphs;
        }
        for (const textRenderer of this.m_textRenderers) {
            textRenderer.textCanvas.render(camera);
        }
    }
    /**
     * Reset internal state at the beginning of a frame.
     */
    reset() {
        this.m_screenCollisions.reset();
        for (const textRenderer of this.m_textRenderers) {
            textRenderer.textCanvas.clear();
            textRenderer.poiRenderer.reset();
        }
        this.m_initializedTextElementCount = 0;
    }
    /**
     * Update the geometries at the end of a frame before rendering them.
     */
    update() {
        for (const textRenderer of this.m_textRenderers) {
            textRenderer.poiRenderer.update();
        }
    }
    /**
     * Visit all visible tiles and place their text labels and POI icons. The placement of
     * [[TextElement]]s is a time consuming process, and cannot be done every frame, but should only
     * be done when the camera moved (a lot) of whenever the set of visible tiles change.
     *
     * The actually rendered [[TextElement]]s are stored internally until the next placement is done
     * to speed up rendering when no camera movement was detected.
     */
    placeAllTileLabels() {
        this.placeAllLabels();
    }
    /**
     * Notify `TextElementsRenderer` that the camera has started a movement.
     */
    movementStarted() {
        // Nothing to do (yet)
    }
    /**
     * Notify `TextElementsRenderer` that the camera has finished its movement.
     */
    movementFinished() {
        this.placeAllLabels();
    }
    /**
     * Default [[TextElementStyle]] used to render [[TextElement]]s.
     */
    get defaultStyle() {
        return this.m_defaultStyle;
    }
    /**
     * Is `true` if number of [[TextElement]]s in visible tiles is larger than the recommended
     * number `OVERLOAD_LABEL_LIMIT`.
     */
    get overloaded() {
        return this.m_overloaded;
    }
    /**
     * Is `true` if [[MapView]] is currently animating or the camera is moving or an update is
     * pending.
     */
    get isDynamicFrame() {
        const mapView = this.m_mapView;
        return mapView.cameraIsMoving || mapView.animating || mapView.updatePending;
    }
    /**
     * Render the user [[TextElement]]s.
     *
     * @param time Current time for animations.
     * @param frameNumber Integer number incremented every frame.
     */
    renderUserTextElements(time, frameNumber) {
        const renderList = this.m_mapView.visibleTileSet.dataSourceTileList;
        const zoomLevel = this.m_mapView.zoomLevel;
        // Render the user POIs first
        renderList.forEach(renderListEntry => {
            for (const tile of renderListEntry.visibleTiles) {
                for (const textElement of tile.userTextElements) {
                    // update distance
                    textElement.tileCenter = tile.center;
                    this.updateViewDistance(this.m_mapView.worldCenter, textElement);
                }
                this.renderTextElements(tile.userTextElements, time, frameNumber, zoomLevel);
            }
        });
    }
    /**
     * Re-render the previously placed [[TextElement]]s.
     *
     * @param time Current time for animations.
     * @param frameNumber Integer number incremented every frame.
     */
    renderAllTileText(time, frameNumber) {
        const renderList = this.m_mapView.visibleTileSet.dataSourceTileList;
        const zoomLevel = this.m_mapView.zoomLevel;
        this.checkIfOverloaded();
        if (this.m_lastRenderedTextElements.length === 0) {
            const renderStartTime = this.overloaded && this.isDynamicFrame ? harp_utils_1.PerformanceTimer.now() : undefined;
            // Nothing has been rendered before, process the list of placed labels in all tiles.
            renderList.forEach(renderListEntry => {
                this.renderTileList(renderListEntry.renderedTiles, time, frameNumber, zoomLevel, renderStartTime, this.m_lastRenderedTextElements, this.m_secondChanceTextElements);
            });
        }
        else {
            //TODO: Avoid list allocation
            const allRenderableTextElements = this.m_lastRenderedTextElements.concat(this.m_secondChanceTextElements);
            this.renderTextElements(allRenderableTextElements, time, frameNumber, zoomLevel);
        }
    }
    /**
     * Render the [[TextElement]]s that are not part of the scene, but the overlay. Useful if a UI
     * with text or just plain information in the canvas itself should be presented to the user,
     * instead of using an HTML layer.
     *
     * @param textElements List of [[TextElement]]s in the overlay.
     */
    renderOverlay(textElements) {
        if (textElements === undefined || textElements.length === 0) {
            return;
        }
        this.renderOverlayTextElements(textElements);
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * [[TextElement]]s are found, the order of the results is unspecified.
     *
     * Note: [[TextElement]]s with identical `featureId` or identical `userData` will only appear
     * once in the list `pickResults`.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickResults Array filled with pick results.
     */
    pickTextElements(screenPosition, pickResults) {
        const pickHandler = (pickData, pickObjectType) => {
            const textElement = pickData;
            if (textElement === undefined) {
                return;
            }
            let isDuplicate = false;
            if (textElement.featureId !== undefined) {
                isDuplicate = pickResults.some(pickResult => {
                    return (pickResult !== undefined &&
                        pickObjectType === pickResult.type &&
                        ((pickResult.featureId !== undefined &&
                            pickResult.featureId === textElement.featureId) ||
                            (pickResult.userData !== undefined &&
                                pickResult.userData === textElement.userData)));
                });
                if (!isDuplicate) {
                    const pickResult = {
                        type: pickObjectType,
                        point: screenPosition,
                        distance: 0,
                        featureId: textElement.featureId,
                        userData: textElement.userData,
                        text: textElement.text
                    };
                    pickResults.push(pickResult);
                }
            }
        };
        for (const textRenderer of this.m_textRenderers) {
            textRenderer.textCanvas.pickText(screenPosition, (pickData) => {
                pickHandler(pickData, PickHandler_1.PickObjectType.Text);
            });
            textRenderer.poiRenderer.pickTextElements(screenPosition, (pickData) => {
                pickHandler(pickData, PickHandler_1.PickObjectType.Icon);
            });
        }
    }
    /**
     * Retrieves a [[TextElementStyle]] for [[Theme]]'s [[TextStyle]] id.
     */
    getTextElementStyle(styleId) {
        let result;
        if (styleId === undefined) {
            result = this.m_defaultStyle;
        }
        else {
            result = this.m_textStyles.get(styleId);
            if (result === undefined) {
                result = this.m_defaultStyle;
            }
        }
        return result;
    }
    /**
     * `true` if font catalogs are ready, that means all font catalogs are initialized.
     */
    get ready() {
        return this.m_catalogsLoading === 0 && this.m_textRenderers.length > 0;
    }
    /**
     * `true` if any resource used by any `FontCatalog` is still loading.
     */
    get loading() {
        let isLoading = this.m_catalogsLoading > 0;
        for (const textRenderer of this.m_textRenderers) {
            isLoading = isLoading || textRenderer.textCanvas.fontCatalog.isLoading;
        }
        return isLoading;
    }
    /**
     * Reset the current text render states of all visible tiles. All [[TextElement]]s will fade in
     * after that as if they have just been added.
     */
    clearRenderStates() {
        const renderList = this.m_mapView.visibleTileSet.dataSourceTileList;
        renderList.forEach(renderListEntry => {
            for (const tile of renderListEntry.visibleTiles) {
                // Reset the render states, handle them as if they were just added to the tile.
                tile.userTextElements.forEach(textElement => {
                    textElement.iconRenderState = undefined;
                    textElement.textRenderState = undefined;
                });
                tile.textElementGroups.forEach(textElement => {
                    textElement.iconRenderState = undefined;
                    textElement.textRenderState = undefined;
                });
            }
        });
    }
    /**
     * Return memory used by all objects managed by `TextElementsRenderer`.
     *
     * @returns `MemoryUsage` Heap and GPU memory used by this `TextElementsRenderer`.
     */
    getMemoryUsage() {
        const memoryUsage = {
            heapSize: 0,
            gpuSize: 0
        };
        for (const renderer of this.m_textRenderers) {
            renderer.textCanvas.getMemoryUsage(memoryUsage);
            renderer.poiRenderer.getMemoryUsage(memoryUsage);
        }
        return memoryUsage;
    }
    initializeDefaultAssets() {
        // Initialize default font catalog.
        if (this.m_theme.fontCatalogs === undefined ||
            (Array.isArray(this.m_theme.fontCatalogs) && this.m_theme.fontCatalogs.length === 0)) {
            this.m_theme.fontCatalogs = [
                {
                    name: DEFAULT_FONT_CATALOG_NAME,
                    url: this.m_mapView.defaultFontCatalog
                }
            ];
        }
        const fontCatalogs = this.m_theme.fontCatalogs;
        let defaultFontCatalogName;
        if (fontCatalogs.length > 0) {
            for (const fontCatalog of fontCatalogs) {
                if (fontCatalog.name !== undefined) {
                    defaultFontCatalogName = fontCatalog.name;
                    break;
                }
            }
            if (defaultFontCatalogName === undefined) {
                defaultFontCatalogName = DEFAULT_FONT_CATALOG_NAME;
                fontCatalogs[0].name = defaultFontCatalogName;
            }
        }
        // Initialize default text style.
        if (this.m_theme.textStyles === undefined) {
            this.m_theme.textStyles = [];
        }
        const styles = this.m_theme.textStyles;
        const themedDefaultStyle = styles.find(style => style.name === DEFAULT_STYLE_NAME);
        if (themedDefaultStyle !== undefined) {
            this.m_defaultStyle = this.createTextElementStyle(themedDefaultStyle, DEFAULT_STYLE_NAME);
        }
        else if (this.m_theme.defaultTextStyle !== undefined) {
            this.m_defaultStyle = this.createTextElementStyle(this.m_theme.defaultTextStyle, DEFAULT_STYLE_NAME);
        }
        else if (styles.length > 0) {
            this.m_defaultStyle = this.createTextElementStyle(styles[0], DEFAULT_STYLE_NAME);
        }
        this.m_defaultStyle.fontCatalog = defaultFontCatalogName;
    }
    createTextElementStyle(style, styleName) {
        return {
            name: styleName,
            fontCatalog: harp_utils_1.getOptionValue(style.fontCatalogName, DEFAULT_FONT_CATALOG_NAME),
            renderParams: {
                fontName: style.fontName,
                fontSize: {
                    unit: harp_text_canvas_1.FontUnit.Pixel,
                    size: 32,
                    backgroundSize: style.backgroundSize || 8
                },
                fontStyle: style.fontStyle === "Regular" ||
                    style.fontStyle === "Bold" ||
                    style.fontStyle === "Italic" ||
                    style.fontStyle === "BoldItalic"
                    ? harp_text_canvas_1.FontStyle[style.fontStyle]
                    : undefined,
                fontVariant: style.fontVariant === "Regular" ||
                    style.fontVariant === "AllCaps" ||
                    style.fontVariant === "SmallCaps"
                    ? harp_text_canvas_1.FontVariant[style.fontVariant]
                    : undefined,
                rotation: style.rotation,
                color: style.color !== undefined
                    ? ColorCache_1.ColorCache.instance.getColor(style.color)
                    : undefined,
                backgroundColor: style.backgroundColor !== undefined
                    ? ColorCache_1.ColorCache.instance.getColor(style.backgroundColor)
                    : undefined,
                opacity: style.opacity,
                backgroundOpacity: style.backgroundOpacity
            },
            layoutParams: {
                tracking: style.tracking,
                leading: style.leading,
                maxLines: style.maxLines,
                lineWidth: style.lineWidth,
                canvasRotation: style.canvasRotation,
                lineRotation: style.lineRotation,
                wrappingMode: style.wrappingMode === "None" ||
                    style.wrappingMode === "Character" ||
                    style.wrappingMode === "Word"
                    ? harp_text_canvas_1.WrappingMode[style.wrappingMode]
                    : harp_text_canvas_1.WrappingMode.Word,
                verticalAlignment: style.vAlignment === "Above" ||
                    style.vAlignment === "Center" ||
                    style.vAlignment === "Below"
                    ? harp_text_canvas_1.VerticalAlignment[style.vAlignment]
                    : harp_text_canvas_1.VerticalAlignment.Center,
                horizontalAlignment: style.hAlignment === "Left" ||
                    style.hAlignment === "Center" ||
                    style.hAlignment === "Right"
                    ? harp_text_canvas_1.HorizontalAlignment[style.hAlignment]
                    : harp_text_canvas_1.HorizontalAlignment.Center
            }
        };
    }
    initializeTextCanvases() {
        const promises = [];
        this.m_theme.fontCatalogs.forEach(fontCatalogConfig => {
            this.m_catalogsLoading += 1;
            const fontCatalogPromise = harp_text_canvas_1.FontCatalog.load(fontCatalogConfig.url, 1024)
                .then((loadedFontCatalog) => {
                this.m_catalogsLoading -= 1;
                const loadedTextCanvas = new harp_text_canvas_1.TextCanvas({
                    renderer: this.m_mapView.renderer,
                    fontCatalog: loadedFontCatalog,
                    minGlyphCount: this.m_minNumGlyphs,
                    maxGlyphCount: this.m_maxNumGlyphs
                });
                this.m_textRenderers.push({
                    fontCatalog: fontCatalogConfig.name,
                    textCanvas: loadedTextCanvas,
                    poiRenderer: new PoiRenderer_1.PoiRenderer(this.m_mapView, loadedTextCanvas)
                });
            })
                .catch((error) => {
                this.m_catalogsLoading -= 1;
                logger.error("Failed to load FontCatalog: ", error);
            });
            promises.push(fontCatalogPromise);
        });
        Promise.all(promises).then(() => {
            this.initializeTextElementStyles();
            const defaultFontCatalog = this.m_textRenderers[0].textCanvas.fontCatalog;
            // Initialize glyph-debugging mesh.
            const planeGeometry = new THREE.PlaneGeometry(defaultFontCatalog.textureSize.width / 2.5, defaultFontCatalog.textureSize.height / 2.5, defaultFontCatalog.textureSize.width / defaultFontCatalog.maxWidth, defaultFontCatalog.textureSize.height / defaultFontCatalog.maxHeight);
            const material = new THREE.MeshBasicMaterial({
                transparent: true,
                depthWrite: false,
                depthTest: false,
                map: defaultFontCatalog.texture
            });
            this.m_debugGlyphTextureCacheMesh = new THREE.Mesh(planeGeometry, material);
            this.m_debugGlyphTextureCacheMesh.renderOrder = 10000;
            this.m_debugGlyphTextureCacheMesh.visible = false;
            this.m_debugGlyphTextureCacheMesh.name = "glyphDebug";
            const wireframe = new THREE.WireframeGeometry(planeGeometry);
            const wireframeMaterial = new THREE.LineBasicMaterial({
                transparent: true,
                color: 0x999999,
                depthWrite: false,
                depthTest: false
            });
            this.m_debugGlyphTextureCacheWireMesh = new THREE.LineSegments(wireframe, wireframeMaterial);
            this.m_debugGlyphTextureCacheWireMesh.renderOrder = 9999;
            this.m_debugGlyphTextureCacheWireMesh.visible = false;
            this.m_debugGlyphTextureCacheWireMesh.name = "glyphDebug";
            this.m_textRenderers[0].textCanvas
                .getLayer(harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER)
                .storage.scene.add(this.m_debugGlyphTextureCacheMesh, this.m_debugGlyphTextureCacheWireMesh);
            this.m_mapView.update();
        });
    }
    initializeTextElementStyles() {
        // Find the default TextCanvas and PoiRenderer.
        let defaultTextCanvas;
        this.m_textRenderers.forEach(textRenderer => {
            if (defaultTextCanvas === undefined) {
                defaultTextCanvas = textRenderer.textCanvas;
            }
        });
        const defaultPoiRenderer = new PoiRenderer_1.PoiRenderer(this.m_mapView, defaultTextCanvas);
        // Initialize default text style.
        if (this.m_defaultStyle.fontCatalog !== undefined) {
            const styledTextRenderer = this.m_textRenderers.find(textRenderer => textRenderer.fontCatalog === this.m_defaultStyle.fontCatalog);
            this.m_defaultStyle.textCanvas =
                styledTextRenderer !== undefined ? styledTextRenderer.textCanvas : undefined;
            this.m_defaultStyle.poiRenderer =
                styledTextRenderer !== undefined ? styledTextRenderer.poiRenderer : undefined;
        }
        if (this.m_defaultStyle.textCanvas === undefined) {
            if (this.m_defaultStyle.fontCatalog !== undefined) {
                logger.warn(`FontCatalog '${this.m_defaultStyle.fontCatalog}' set in TextStyle '${this.m_defaultStyle.name}' not found, using default fontCatalog(${defaultTextCanvas.fontCatalog.name}).`);
            }
            this.m_defaultStyle.textCanvas = defaultTextCanvas;
            this.m_defaultStyle.poiRenderer = defaultPoiRenderer;
        }
        // Initialize theme text styles.
        this.m_theme.textStyles.forEach(element => {
            this.m_textStyles.set(element.name, this.createTextElementStyle(element, element.name));
        });
        // tslint:disable-next-line:no-unused-variable
        for (const [name, style] of this.m_textStyles) {
            if (style.textCanvas === undefined) {
                if (style.fontCatalog !== undefined) {
                    const styledTextRenderer = this.m_textRenderers.find(textRenderer => textRenderer.fontCatalog === style.fontCatalog);
                    style.textCanvas =
                        styledTextRenderer !== undefined
                            ? styledTextRenderer.textCanvas
                            : undefined;
                    style.poiRenderer =
                        styledTextRenderer !== undefined
                            ? styledTextRenderer.poiRenderer
                            : undefined;
                }
                if (style.textCanvas === undefined) {
                    if (style.fontCatalog !== undefined) {
                        logger.warn(`FontCatalog '${style.fontCatalog}' set in TextStyle '${style.name}' not found, using default fontCatalog(${defaultTextCanvas.fontCatalog.name}).`);
                    }
                    style.textCanvas = defaultTextCanvas;
                    style.poiRenderer = defaultPoiRenderer;
                }
            }
        }
    }
    updateViewDistance(worldCenter, textElement) {
        let viewDistance;
        if (Array.isArray(textElement.points) && textElement.points.length > 1) {
            tempPoiPosition.copy(textElement.points[0]).add(textElement.tileCenter);
            const viewDistance0 = worldCenter.distanceTo(tempPoiPosition);
            tempPoiPosition
                .copy(textElement.points[textElement.points.length - 1])
                .add(textElement.tileCenter);
            const viewDistance1 = worldCenter.distanceTo(tempPoiPosition);
            viewDistance = Math.min(viewDistance0, viewDistance1);
        }
        else {
            tempPoiPosition.copy(textElement.position).add(textElement.tileCenter);
            viewDistance = worldCenter.distanceTo(tempPoiPosition);
        }
        textElement.currentViewDistance = viewDistance;
        return viewDistance;
    }
    sortTextElements(textElements, maxViewDistance) {
        const distancePriorityFactor = 0.1;
        const indexPriorityFactor = 0.01 * (1 / textElements.length);
        // Compute the sortPriority once for all elements, because the computation is done more
        // than once per element. Also, make sorting stable by taking the index into the array into
        // account, this is required to get repeatable results for testing.
        for (let i = 0; i < textElements.length; i++) {
            const textElement = textElements[i];
            textElement.sortPriority =
                textElement.priority +
                    i * indexPriorityFactor +
                    distancePriorityFactor -
                    distancePriorityFactor * (textElement.currentViewDistance / maxViewDistance);
        }
        // Do the actual sort based on sortPriority
        textElements.sort((a, b) => {
            return b.sortPriority - a.sortPriority;
        });
    }
    placeAllLabels() {
        const renderList = this.m_mapView.visibleTileSet.dataSourceTileList;
        const zoomLevel = this.m_mapView.zoomLevel;
        this.checkIfOverloaded();
        const placementStartTime = this.overloaded && this.isDynamicFrame ? harp_utils_1.PerformanceTimer.now() : undefined;
        renderList.forEach(tileList => {
            this.placeTextElements(tileList.dataSource, tileList.storageLevel, zoomLevel, tileList.visibleTiles, placementStartTime);
        });
        this.m_lastRenderedTextElements.length = 0;
        this.m_secondChanceTextElements.length = 0;
    }
    placeTextElements(tileDataSource, storageLevel, zoomLevel, visibleTiles, placementStartTime) {
        const sortedTiles = visibleTiles;
        sortedTiles.sort((a, b) => {
            return a.tileKey.mortonCode() - b.tileKey.mortonCode();
        });
        for (const tile of sortedTiles) {
            this.prepareUserTextElements(tile);
        }
        const sortedGroups = [];
        this.createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups);
        const textElementGroups = [];
        let numTextElementsPlaced = 0;
        for (const textElementLists of sortedGroups) {
            this.selectTextElementsToPlaceByDistance(zoomLevel, textElementLists, textElementGroups);
            // The value of placementStartTime is set if this.overloaded is true.
            if (placementStartTime !== undefined) {
                // If overloaded and all time is used up, exit early.
                if (OVERLOAD_PLACEMENT_TIME_LIMIT > 0) {
                    const endTime = harp_utils_1.PerformanceTimer.now();
                    const elapsedTime = endTime - placementStartTime;
                    if (elapsedTime > OVERLOAD_PLACEMENT_TIME_LIMIT) {
                        break;
                    }
                }
                // Try not to place too many elements. They will be checked for visibility each
                // frame.
                numTextElementsPlaced += textElementLists.count();
                if (numTextElementsPlaced >= OVERLOAD_PLACED_LABEL_LIMIT) {
                    break;
                }
            }
        }
    }
    /**
     * Process any (new) user [[TextElement]], which has not been placed by the PoiManager, to set
     * it up for rendering.
     *
     * @param tile The Tile to process all user [[TextElements]] of.
     */
    prepareUserTextElements(tile) {
        for (const textElement of tile.userTextElements) {
            textElement.tileCenter = tile.center;
        }
    }
    createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups) {
        if (this.m_textRenderers.length === 0 || sortedTiles.length === 0) {
            return;
        }
        const tilesToRender = [];
        for (const tile of sortedTiles) {
            tile.placedTextElements.clear();
            if (tileDataSource.shouldRenderText(storageLevel, tile.tileKey)) {
                tilesToRender.push(tile);
            }
        }
        const groupedPriorityLists = new Map();
        for (const tile of tilesToRender) {
            for (const group of tile.textElementGroups.groups.values()) {
                if (group.elements.length === 0) {
                    continue;
                }
                const foundGroup = groupedPriorityLists.get(group.priority);
                if (foundGroup === undefined) {
                    groupedPriorityLists.set(group.priority, new TextElementLists(group.priority, [
                        new TileTextElements(tile, group.elements)
                    ]));
                }
                else {
                    foundGroup.textElementLists.push(new TileTextElements(tile, group.elements));
                }
            }
        }
        if (groupedPriorityLists.size === 0) {
            return;
        }
        for (const g of groupedPriorityLists) {
            const lists = g[1];
            sortedGroups.push(lists);
        }
        sortedGroups.sort((a, b) => {
            return b.priority - a.priority;
        });
        const printTextInfo = false;
        if (PRINT_LABEL_DEBUG_INFO && printTextInfo) {
            let outString = "";
            for (const textElementLists of sortedGroups) {
                let size = 0;
                for (const tileTextElements of textElementLists.textElementLists) {
                    size += tileTextElements.textElements.length;
                }
                outString += `priority ${textElementLists.priority} size: ${size}\n`;
            }
            logger.log(outString);
        }
    }
    getMaxDistance(farDistanceLimitRatio) {
        const farDistance = this.m_mapView.camera.far;
        const maxDistance = farDistance * farDistanceLimitRatio;
        return maxDistance;
    }
    selectTextElementsToPlaceByDistance(zoomLevel, textElementLists, textElementGroups) {
        const farDistanceLimitRatio = this.m_maxDistanceRatioForLabels;
        const maxDistance = this.getMaxDistance(farDistanceLimitRatio);
        const textElementGroup = [];
        for (const tileTextElements of textElementLists.textElementLists) {
            const tile = tileTextElements.tile;
            const worldOffsetX = this.m_mapView.projection.worldExtent(0, 0).max.x * tile.offset;
            for (const textElement of tileTextElements.textElements) {
                if (!textElement.visible) {
                    continue;
                }
                // If a PoiTable is specified in the technique, the table is required to be
                // loaded before the POI can be rendered.
                if (textElement.poiInfo !== undefined &&
                    textElement.poiInfo.poiTableName !== undefined) {
                    if (this.m_mapView.poiManager.updatePoiFromPoiTable(textElement)) {
                        // Remove poiTableName to mark this POI as processed.
                        textElement.poiInfo.poiTableName = undefined;
                    }
                    else {
                        // PoiTable has not been loaded, but is required to determine
                        // visibility.
                        continue;
                    }
                }
                if (!textElement.visible ||
                    !harp_utils_1.MathUtils.isClamped(zoomLevel, textElement.minZoomLevel, textElement.maxZoomLevel)) {
                    continue;
                }
                if (textElement.tileCenter === undefined) {
                    textElement.tileCenter = new THREE.Vector3(tile.center.x + worldOffsetX, tile.center.y, tile.center.z);
                }
                else {
                    textElement.tileCenter.set(tile.center.x + worldOffsetX, tile.center.y, tile.center.z);
                }
                // If the distance is greater than allowed, skip it.
                const textDistance = this.updateViewDistance(this.m_mapView.worldCenter, textElement);
                if (this.m_mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
                    tempPoiPosition.copy(textElement.position).add(textElement.tileCenter);
                    tempPoiPosition.normalize();
                    const cameraDir = new THREE.Vector3();
                    this.m_mapView.camera.getWorldDirection(cameraDir);
                    if (tempPoiPosition.dot(cameraDir) < -0.6 &&
                        textDistance !== undefined &&
                        textDistance <= maxDistance) {
                        tile.placedTextElements.add(textElement);
                    }
                }
                else if (textDistance !== undefined && textDistance <= maxDistance) {
                    tile.placedTextElements.add(textElement);
                }
            }
        }
        textElementGroups.push(textElementGroup);
    }
    renderOverlayTextElements(textElements) {
        if (this.m_textRenderers.length === 0) {
            return;
        }
        const screenSize = this.m_mapView.renderer.getSize(this.m_tmpVector);
        const screenXOrigin = -screenSize.width / 2.0;
        const screenYOrigin = screenSize.height / 2.0;
        const tempAdditionParams = {};
        const tempBufferAdditionParams = {};
        // Place text elements one by one.
        for (const textElement of textElements) {
            // Get the TextElementStyle.
            const textElementStyle = this.getTextElementStyle(textElement.style);
            const textCanvas = textElementStyle.textCanvas;
            if (textCanvas === undefined) {
                continue;
            }
            const layer = textCanvas.getLayer(textElement.renderOrder || harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER);
            const isPathLabel = textElement.path !== undefined && !textElement.isLineMarker;
            // Trigger the glyph load if needed.
            if (textElement.loadingState === undefined) {
                textElement.loadingState = TextElement_1.LoadingState.Requested;
                if (textElement.renderStyle === undefined) {
                    textElement.renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign({}, textElementStyle.renderParams, textElement.renderParams));
                }
                if (textElement.layoutStyle === undefined) {
                    textElement.layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign({}, textElementStyle.layoutParams, textElement.layoutParams));
                }
                if (textElement.text === "") {
                    textElement.loadingState = TextElement_1.LoadingState.Loaded;
                }
                else {
                    textCanvas.fontCatalog
                        .loadCharset(textElement.text, textElement.renderStyle)
                        .then(() => {
                        textElement.loadingState = TextElement_1.LoadingState.Loaded;
                        this.m_mapView.update();
                    });
                }
            }
            if (textElement.loadingState === TextElement_1.LoadingState.Loaded) {
                if (this.m_initializedTextElementCount < MAX_INITIALIZED_TEXT_ELEMENTS_PER_FRAME) {
                    textCanvas.textRenderStyle = textElement.renderStyle;
                    textCanvas.textLayoutStyle = textElement.layoutStyle;
                    textElement.glyphCaseArray = [];
                    textElement.glyphs = textCanvas.fontCatalog.getGlyphs(textElement.text, textCanvas.textRenderStyle, textElement.glyphCaseArray);
                    textElement.loadingState = TextElement_1.LoadingState.Initialized;
                    ++this.m_initializedTextElementCount;
                }
            }
            if (textElement.loadingState !== TextElement_1.LoadingState.Initialized) {
                continue;
            }
            // Move onto the next TextElement if we cannot continue adding glyphs to this layer.
            if (layer !== undefined) {
                if (layer.storage.drawCount + textElement.glyphs.length > layer.storage.capacity) {
                    continue;
                }
            }
            // Set the current style for the canvas.
            textCanvas.textRenderStyle = textElement.renderStyle;
            textCanvas.textLayoutStyle = textElement.layoutStyle;
            // Place text.
            let textPath;
            if (!isPathLabel) {
                // Adjust the label positioning.
                tempScreenPosition.x = screenXOrigin + textElement.position.x * screenSize.width;
                tempScreenPosition.y = screenYOrigin - textElement.position.y * screenSize.height;
                if (textElement.xOffset !== undefined) {
                    tempScreenPosition.x += textElement.xOffset;
                }
                if (textElement.yOffset !== undefined) {
                    tempScreenPosition.y -= textElement.yOffset;
                }
                tempPosition.x = tempScreenPosition.x;
                tempPosition.y = tempScreenPosition.y;
                tempPosition.z = 0.0;
                tempBufferAdditionParams.position = tempPosition;
                tempAdditionParams.layer = textElement.renderOrder;
                tempAdditionParams.letterCaseArray = textElement.glyphCaseArray;
                textCanvas.addText(textElement.glyphs, tempPosition, tempAdditionParams);
            }
            else {
                // Adjust the label positioning.
                tempScreenPosition.x = screenXOrigin;
                tempScreenPosition.y = screenYOrigin;
                if (textElement.xOffset !== undefined) {
                    tempScreenPosition.x += textElement.xOffset;
                }
                if (textElement.yOffset !== undefined) {
                    tempScreenPosition.y -= textElement.yOffset;
                }
                // Get the screen points that define the label's segments and create a path with
                // them.
                // TODO: Optimize array allocations.
                const screenPoints = [];
                for (const pt of textElement.path) {
                    const pX = tempScreenPosition.x + pt.x * screenSize.width;
                    const pY = tempScreenPosition.y - pt.y * screenSize.height;
                    screenPoints.push(new THREE.Vector2(pX, pY));
                }
                textPath = new SimplePath_1.SimplePath();
                for (let i = 0; i < screenPoints.length - 1; ++i) {
                    textPath.add(new THREE.LineCurve(screenPoints[i], screenPoints[i + 1]));
                }
                tempAdditionParams.path = textPath;
                tempAdditionParams.pathOverflow = true;
                tempAdditionParams.layer = textElement.renderOrder;
                tempAdditionParams.letterCaseArray = textElement.glyphCaseArray;
                textCanvas.addText(textElement.glyphs, tempPosition, tempAdditionParams);
            }
        }
    }
    getDistanceFadingFactor(label, cameraFar) {
        let distanceFadeValue = 1.0;
        const textDistance = label.currentViewDistance;
        if (textDistance !== undefined && label.fadeFar !== undefined && label.fadeFar > 0.0) {
            const fadeNear = label.fadeNear === undefined ? 0.0 : label.fadeNear;
            const fadeFar = label.fadeFar;
            if (fadeFar > fadeNear) {
                distanceFadeValue =
                    1.0 -
                        harp_utils_1.MathUtils.clamp((textDistance / cameraFar - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);
            }
        }
        return distanceFadeValue;
    }
    renderTextElements(textElements, time, frameNumber, zoomLevel, renderedTextElements, secondChanceTextElements) {
        if (this.m_textRenderers.length === 0) {
            return 0;
        }
        const currentlyRenderingPlacedElements = renderedTextElements === undefined;
        const printInfo = textElements.length > 5000;
        let numNotVisible = 0;
        let numPathTooSmall = 0;
        let numCannotAdd = 0;
        let numRenderedPoiIcons = 0;
        let numRenderedPoiTexts = 0;
        let numPoiTextsInvisible = 0;
        const maxNumRenderedLabels = this.m_maxNumVisibleLabels;
        const numSecondChanceLabels = this.m_numSecondChanceLabels;
        const labelStartScaleDistance = this.m_labelStartScaleDistance;
        let numRenderedTextElements = 0;
        const shieldGroups = [];
        const textFarDistanceLimitRatio = 0.9;
        const textMaxDistance = this.getMaxDistance(textFarDistanceLimitRatio);
        const poiTextFarDistanceLimitRatio = 0.8;
        const poiTextMaxDistance = this.getMaxDistance(poiTextFarDistanceLimitRatio);
        const cameraIsMoving = this.m_mapView.cameraIsMoving;
        const cameraFar = this.m_mapView.camera.far;
        // Keep track if we need to call another update() on MapView.
        let fadeAnimationRunning = false;
        const tempAdditionParams = {};
        const tempPoiMeasurementParams = {};
        const tempMeasurementParams = {};
        const tempBufferAdditionParams = {};
        // Place text elements one by one.
        for (const textElement of textElements) {
            if (!currentlyRenderingPlacedElements &&
                maxNumRenderedLabels >= 0 &&
                numRenderedTextElements >= maxNumRenderedLabels) {
                break;
            }
            // Get the TextElementStyle.
            const textElementStyle = this.getTextElementStyle(textElement.style);
            const textCanvas = textElementStyle.textCanvas;
            const poiRenderer = textElementStyle.poiRenderer;
            if (textCanvas === undefined || poiRenderer === undefined) {
                continue;
            }
            const isPathLabel = textElement.path !== undefined && !textElement.isLineMarker;
            let screenPoints;
            // For paths, check if the label may fit.
            if (isPathLabel) {
                const screenPointsResult = this.checkForSmallLabels(textElement);
                if (screenPointsResult === undefined) {
                    numNotVisible++;
                    if (textElement.dbgPathTooSmall === true) {
                        numPathTooSmall++;
                    }
                    continue;
                }
                screenPoints = screenPointsResult;
            }
            // Trigger the glyph load if needed.
            if (textElement.loadingState === undefined) {
                textElement.loadingState = TextElement_1.LoadingState.Requested;
                if (textElement.renderStyle === undefined) {
                    textElement.renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign({}, textElementStyle.renderParams, textElement.renderParams));
                }
                if (textElement.layoutStyle === undefined) {
                    textElement.layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign({}, textElementStyle.layoutParams, textElement.layoutParams));
                }
                if (textElement.text === "") {
                    textElement.loadingState = TextElement_1.LoadingState.Loaded;
                }
                else {
                    textCanvas.fontCatalog
                        .loadCharset(textElement.text, textElement.renderStyle)
                        .then(() => {
                        textElement.loadingState = TextElement_1.LoadingState.Loaded;
                        this.m_mapView.update();
                    });
                }
            }
            if (textElement.loadingState === TextElement_1.LoadingState.Loaded) {
                if (this.m_initializedTextElementCount < MAX_INITIALIZED_TEXT_ELEMENTS_PER_FRAME) {
                    textCanvas.textRenderStyle = textElement.renderStyle;
                    textCanvas.textLayoutStyle = textElement.layoutStyle;
                    textElement.glyphCaseArray = [];
                    textElement.glyphs = textCanvas.fontCatalog.getGlyphs(textElement.text, textCanvas.textRenderStyle, textElement.glyphCaseArray);
                    if (!isPathLabel) {
                        textElement.bounds = new THREE.Box2();
                        tempPoiMeasurementParams.letterCaseArray = textElement.glyphCaseArray;
                        textCanvas.measureText(textElement.glyphs, textElement.bounds, tempPoiMeasurementParams);
                    }
                    textElement.loadingState = TextElement_1.LoadingState.Initialized;
                    ++this.m_initializedTextElementCount;
                }
            }
            if (textElement.loadingState !== TextElement_1.LoadingState.Initialized) {
                if (secondChanceTextElements !== undefined &&
                    secondChanceTextElements.length < numSecondChanceLabels) {
                    secondChanceTextElements.push(textElement);
                }
                continue;
            }
            const layer = textCanvas.getLayer(textElement.renderOrder || harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER);
            // Move onto the next TextElement if we cannot continue adding glyphs to this layer.
            if (layer !== undefined) {
                if (layer.storage.drawCount + textElement.glyphs.length > layer.storage.capacity) {
                    ++numCannotAdd;
                    continue;
                }
            }
            // Set the current style for the canvas.
            textCanvas.textRenderStyle = textElement.renderStyle;
            textCanvas.textLayoutStyle = textElement.layoutStyle;
            // Define the point, poi, lineMarker and path label placement functions.
            const addPointLabel = (pointLabel, iconRenderState, textRenderState, position, screenPosition) => {
                // Find the label's original position.
                tempScreenPosition.x = tempPoiScreenPosition.x = screenPosition.x;
                tempScreenPosition.y = tempPoiScreenPosition.y = screenPosition.y;
                // Offset the label accordingly to alignment (and POI, if any).
                let xOffset = (pointLabel.xOffset || 0.0) *
                    (pointLabel.layoutStyle.horizontalAlignment === harp_text_canvas_1.HorizontalAlignment.Right
                        ? -1.0
                        : 1.0);
                let yOffset = (pointLabel.yOffset || 0.0) *
                    (pointLabel.layoutStyle.verticalAlignment === harp_text_canvas_1.VerticalAlignment.Below
                        ? -1.0
                        : 1.0);
                if (pointLabel.poiInfo !== undefined) {
                    xOffset +=
                        pointLabel.poiInfo.computedWidth *
                            (0.5 + pointLabel.layoutStyle.horizontalAlignment);
                    yOffset +=
                        pointLabel.poiInfo.computedHeight *
                            (0.5 + pointLabel.layoutStyle.verticalAlignment);
                }
                tempScreenPosition.x += xOffset;
                tempScreenPosition.y += yOffset;
                // If we try to place text above their current position, we need to compensate for
                // its bounding box height.
                if (pointLabel.layoutStyle.verticalAlignment === harp_text_canvas_1.VerticalAlignment.Above) {
                    tempScreenPosition.y += -pointLabel.bounds.min.y;
                }
                // Scale the text depending on the label's distance to the camera.
                let textScale = 1.0;
                let distanceScale = 1.0;
                const textDistance = this.m_mapView.worldCenter.distanceTo(position);
                if (textDistance !== undefined) {
                    if (pointLabel.fadeFar !== undefined &&
                        (pointLabel.fadeFar <= 0.0 || pointLabel.fadeFar * cameraFar < textDistance)) {
                        // The label is farther away than fadeFar value, which means it is totally
                        // transparent.
                        return false;
                    }
                    const startScaleDistance = cameraFar * labelStartScaleDistance;
                    if (textDistance > startScaleDistance) {
                        distanceScale =
                            1.0 -
                                ((textDistance - startScaleDistance) /
                                    (cameraFar - startScaleDistance)) *
                                    (1.0 - pointLabel.distanceScale);
                        textScale *= distanceScale;
                    }
                    textElement.currentViewDistance = textDistance;
                }
                const distanceFadeFactor = this.getDistanceFadingFactor(pointLabel, cameraFar);
                // Check if there is need to check for screen space for the label's icon.
                const poiInfo = pointLabel.poiInfo;
                let iconSpaceAvailable = true;
                // Check if icon should be rendered at this zoomLevel
                const renderIcon = poiInfo === undefined ||
                    harp_utils_1.MathUtils.isClamped(zoomLevel, poiInfo.iconMinZoomLevel, poiInfo.iconMaxZoomLevel);
                if (renderIcon && poiInfo !== undefined && poiRenderer.prepareRender(pointLabel)) {
                    if (poiInfo.isValid === false) {
                        return false;
                    }
                    const iconIsVisible = poiRenderer.computeScreenBox(poiInfo, tempPoiScreenPosition, distanceScale, this.m_screenCollisions, tempBox2D);
                    if (iconIsVisible) {
                        iconSpaceAvailable = poiRenderer.isSpaceAvailable(this.m_screenCollisions, tempBox2D);
                        // Reserve screen space if necessary, return false if failed:
                        if (
                        // Check if free screen space is available:
                        !iconSpaceAvailable) {
                            if (!iconRenderState.isVisible()) {
                                return false;
                            }
                            else if (!(poiInfo.mayOverlap === true) &&
                                !iconRenderState.isFadingOut()) {
                                this.startFadeOut(iconRenderState, frameNumber, time);
                                if (textRenderState !== undefined && textRenderState.isVisible()) {
                                    this.startFadeOut(textRenderState, frameNumber, time);
                                }
                            }
                        }
                        else {
                            if (iconRenderState.lastFrameNumber < frameNumber - 1 ||
                                iconRenderState.isFadingOut() ||
                                iconRenderState.isFadedOut()) {
                                this.startFadeIn(iconRenderState, frameNumber, time);
                            }
                        }
                    }
                    // If the icon is prepared and valid, but just not visible, try again next time.
                    else {
                        if (secondChanceTextElements !== undefined &&
                            secondChanceTextElements.length < numSecondChanceLabels) {
                            secondChanceTextElements.push(pointLabel);
                        }
                        // Forced making it un-current.
                        iconRenderState.lastFrameNumber = -1;
                        return false;
                    }
                    if (iconRenderState.isFading()) {
                        this.updateFading(iconRenderState, time);
                    }
                }
                // Check if label should be rendered at this zoomLevel
                const renderText = poiInfo === undefined ||
                    zoomLevel === undefined ||
                    harp_utils_1.MathUtils.isClamped(zoomLevel, poiInfo.iconMinZoomLevel, poiInfo.iconMaxZoomLevel);
                // Check if we should render the label's text.
                const doRenderText = 
                // Render if between min/max zoom level
                renderText &&
                    // Do not render if the distance is too great and distance shouldn't be ignored.
                    (pointLabel.ignoreDistance === true ||
                        (pointLabel.currentViewDistance === undefined ||
                            pointLabel.currentViewDistance < poiTextMaxDistance)) &&
                    // Do not render text if POI cannot be rendered and is not optional.
                    (poiInfo === undefined ||
                        poiInfo.isValid === true ||
                        poiInfo.iconIsOptional !== false);
                // Render the label's text...
                if (doRenderText && textElement.text !== "") {
                    // Adjust the label positioning to match its bounding box.
                    tempPosition.x = tempScreenPosition.x;
                    tempPosition.y = tempScreenPosition.y;
                    tempPosition.z = textElement.renderDistance;
                    tempBox2D.x = tempScreenPosition.x + pointLabel.bounds.min.x * textScale;
                    tempBox2D.y = tempScreenPosition.y + pointLabel.bounds.min.y * textScale;
                    tempBox2D.w = (pointLabel.bounds.max.x - pointLabel.bounds.min.x) * textScale;
                    tempBox2D.h = (pointLabel.bounds.max.y - pointLabel.bounds.min.y) * textScale;
                    // TODO: Make the margin configurable
                    tempBox2D.x -= 4 * textScale;
                    tempBox2D.y -= 2 * textScale;
                    tempBox2D.w += 8 * textScale;
                    tempBox2D.h += 4 * textScale;
                    // Check the text visibility.
                    if (!this.m_screenCollisions.isVisible(tempBox2D)) {
                        if (secondChanceTextElements !== undefined &&
                            secondChanceTextElements.length < numSecondChanceLabels) {
                            secondChanceTextElements.push(pointLabel);
                        }
                        numPoiTextsInvisible++;
                        return false;
                    }
                    const textIsOptional = pointLabel.poiInfo !== undefined &&
                        pointLabel.poiInfo.textIsOptional === true;
                    const textIsFadingIn = textRenderState !== undefined && textRenderState.isFadingIn();
                    const textIsFadingOut = textRenderState !== undefined && textRenderState.isFadingOut();
                    const textSpaceAvailable = !this.m_screenCollisions.isAllocated(tempBox2D);
                    const textVisible = pointLabel.textMayOverlap ||
                        textSpaceAvailable ||
                        textIsFadingIn ||
                        textIsFadingOut;
                    if (textVisible) {
                        // Compute the TextBufferObject when we know we're gonna render this label.
                        if (pointLabel.textBufferObject === undefined) {
                            pointLabel.textBufferObject = textCanvas.createTextBufferObject(pointLabel.glyphs);
                        }
                        // Allocate collision info if needed.
                        if (!textIsFadingOut && pointLabel.textReservesSpace) {
                            this.m_screenCollisions.allocate(tempBox2D);
                        }
                        // Do not actually render (just allocate space) if camera is moving and
                        // renderTextDuringMovements is not true.
                        if ((textIsFadingIn ||
                            textIsFadingOut ||
                            !cameraIsMoving ||
                            (poiInfo === undefined ||
                                poiInfo.renderTextDuringMovements === true)) &&
                            !iconRenderState.isFadedOut()) {
                            let textFading = false;
                            if (!iconRenderState.isFadingOut() &&
                                textSpaceAvailable &&
                                iconSpaceAvailable) {
                                textFading = this.checkStartFadeIn(textRenderState, frameNumber, time, true);
                            }
                            else if (textRenderState !== undefined) {
                                if (textRenderState.isFading()) {
                                    this.updateFading(textRenderState, time);
                                    textFading = true;
                                }
                            }
                            fadeAnimationRunning =
                                fadeAnimationRunning || textIsFadingOut || textFading;
                            const opacity = textRenderState !== undefined
                                ? textRenderState.opacity
                                : iconRenderState.opacity;
                            tempBufferAdditionParams.layer = pointLabel.renderOrder;
                            tempBufferAdditionParams.position = tempPosition;
                            tempBufferAdditionParams.scale = textScale;
                            tempBufferAdditionParams.opacity = opacity * distanceFadeFactor;
                            tempBufferAdditionParams.backgroundOpacity =
                                tempBufferAdditionParams.opacity *
                                    textElement.renderStyle.backgroundOpacity;
                            textCanvas.addTextBufferObject(pointLabel.textBufferObject, tempBufferAdditionParams);
                        }
                        numRenderedPoiTexts++;
                    }
                    // If the text is not visible nor optional, we won't render the icon neither.
                    else if (!renderIcon || !textIsOptional) {
                        if (pointLabel.poiInfo === undefined || iconRenderState.isVisible()) {
                            if (pointLabel.poiInfo !== undefined) {
                                this.startFadeOut(iconRenderState, frameNumber, time);
                            }
                            if (textRenderState !== undefined && textRenderState.isVisible()) {
                                const iconStartedFadeOut = this.checkStartFadeOut(textRenderState, frameNumber, time);
                                fadeAnimationRunning = fadeAnimationRunning || iconStartedFadeOut;
                            }
                            this.startFadeOut(iconRenderState, frameNumber, time);
                        }
                        else {
                            if (secondChanceTextElements !== undefined &&
                                secondChanceTextElements.length < numSecondChanceLabels) {
                                secondChanceTextElements.push(pointLabel);
                            }
                            numPoiTextsInvisible++;
                            return false;
                        }
                    }
                    // If the label is currently visible, fade it out.
                    else if (textRenderState !== undefined && textRenderState.isVisible()) {
                        const iconStartedFadeOut = this.checkStartFadeOut(textRenderState, frameNumber, time);
                        fadeAnimationRunning = fadeAnimationRunning || iconStartedFadeOut;
                    }
                }
                // ... and render the icon (if any).
                if (renderIcon && poiInfo !== undefined && poiRenderer.poiIsRenderable(poiInfo)) {
                    const iconStartedFadeIn = this.checkStartFadeIn(iconRenderState, frameNumber, time);
                    fadeAnimationRunning = fadeAnimationRunning || iconStartedFadeIn;
                    poiRenderer.renderPoi(poiInfo, tempPoiScreenPosition, this.m_screenCollisions, distanceScale, poiInfo.reserveSpace !== false, iconRenderState.opacity * distanceFadeFactor);
                    iconRenderState.lastFrameNumber = frameNumber;
                    numRenderedPoiIcons++;
                }
                // Add this label to the list of rendered elements.
                if (renderedTextElements !== undefined) {
                    renderedTextElements.push(pointLabel);
                }
                numRenderedTextElements++;
                return true;
            };
            const addPoiLabel = (poiLabel) => {
                // Calculate the world position of this label.
                tempPosition.copy(poiLabel.position).add(poiLabel.tileCenter);
                // Only process labels frustum-clipped labels
                if (this.m_screenProjector.project(tempPosition, tempScreenPosition) !== undefined) {
                    // Initialize the POI's icon and text render states (fading).
                    if (poiLabel.iconRenderState === undefined) {
                        poiLabel.iconRenderState = new TextElement_1.RenderState();
                        poiLabel.textRenderState = new TextElement_1.RenderState();
                        if (this.m_mapView.fadingDisabled) {
                            // Force fadingTime to zero to keep it from fading in and out.
                            poiLabel.iconRenderState.fadingTime = 0;
                            poiLabel.textRenderState.fadingTime = 0;
                        }
                    }
                    // Add this POI as a point label.
                    addPointLabel(poiLabel, poiLabel.iconRenderState, poiLabel.textRenderState, tempPosition, tempScreenPosition);
                }
            };
            const addLineMarkerLabel = (lineMarkerLabel) => {
                // Early exit if the line marker doesn't have the necessary data.
                const poiInfo = lineMarkerLabel.poiInfo;
                if (lineMarkerLabel.path === undefined ||
                    lineMarkerLabel.path.length === 0 ||
                    !poiRenderer.prepareRender(lineMarkerLabel)) {
                    return;
                }
                // Initialize the shield group for this lineMarker.
                let shieldGroup;
                if (poiInfo.shieldGroupIndex !== undefined) {
                    shieldGroup = shieldGroups[poiInfo.shieldGroupIndex];
                    if (shieldGroup === undefined) {
                        shieldGroup = [];
                        shieldGroups[poiInfo.shieldGroupIndex] = shieldGroup;
                    }
                }
                // Create an individual render state for every individual point of the lineMarker.
                if (lineMarkerLabel.iconRenderStates === undefined) {
                    const renderStates = new Array();
                    lineMarkerLabel.path.forEach(() => {
                        const renderState = new TextElement_1.RenderState();
                        renderState.state = TextElement_1.FadingState.FadingIn;
                        renderState.fadingTime = this.m_mapView.fadingDisabled
                            ? 0
                            : renderState.fadingTime;
                        renderStates.push(renderState);
                    });
                    lineMarkerLabel.iconRenderStates = renderStates;
                }
                const lineTechnique = poiInfo.technique;
                const minDistanceSqr = lineTechnique.minDistance !== undefined
                    ? lineTechnique.minDistance * lineTechnique.minDistance
                    : 0;
                // Process markers (with shield groups).
                if (minDistanceSqr > 0 && shieldGroup !== undefined) {
                    for (let i = 0; i < lineMarkerLabel.path.length; i++) {
                        const point = lineMarkerLabel.path[i];
                        // Calculate the world position of this label.
                        tempPosition.copy(point).add(lineMarkerLabel.tileCenter);
                        // Only process labels frustum-clipped labels
                        if (this.m_screenProjector.project(tempPosition, tempScreenPosition) !==
                            undefined) {
                            // Find a suitable location for the lineMarker to be placed at.
                            let tooClose = false;
                            for (let j = 0; j < shieldGroup.length; j += 2) {
                                const distanceSqr = harp_utils_1.Math2D.distSquared(shieldGroup[j], shieldGroup[j + 1], tempScreenPosition.x, tempScreenPosition.y);
                                tooClose = distanceSqr < minDistanceSqr;
                                if (tooClose) {
                                    break;
                                }
                            }
                            // Place it as a point label if it's not to close to other marker in the
                            // same shield group.
                            if (!tooClose) {
                                if (addPointLabel(lineMarkerLabel, lineMarkerLabel.iconRenderStates[i], undefined, tempPosition, tempScreenPosition)) {
                                    shieldGroup.push(tempScreenPosition.x, tempScreenPosition.y);
                                }
                            }
                        }
                    }
                }
                // Process markers (without shield groups).
                else {
                    for (let i = 0; i < lineMarkerLabel.path.length; i++) {
                        const point = lineMarkerLabel.path[i];
                        // Calculate the world position of this label.
                        tempPosition.copy(point).add(lineMarkerLabel.tileCenter);
                        // Only process labels frustum-clipped labels
                        if (this.m_screenProjector.project(tempPosition, tempScreenPosition) !==
                            undefined) {
                            addPointLabel(lineMarkerLabel, lineMarkerLabel.iconRenderStates[i], undefined, tempPosition, tempScreenPosition);
                        }
                    }
                }
            };
            const addPathLabel = (pathLabel) => {
                // Limit the text rendering of path labels in the far distance.
                if (!(pathLabel.ignoreDistance === true ||
                    pathLabel.currentViewDistance === undefined ||
                    pathLabel.currentViewDistance < textMaxDistance)) {
                    return false;
                }
                // Scale the text depending on the label's distance to the camera.
                let distanceScale = 1.0;
                if (pathLabel.fadeFar !== undefined &&
                    (pathLabel.fadeFar <= 0.0 ||
                        pathLabel.fadeFar * cameraFar < pathLabel.renderDistance)) {
                    // The label is farther away than fadeFar value, which means it is totally
                    // transparent
                    return false;
                }
                // Compute values common for all glyphs in the label.
                let textScale = textCanvas.textRenderStyle.fontSize.size / 100.0;
                let opacity = 1.0;
                // Get the screen points that define the label's segments and create a path with
                // them.
                let textPath = new THREE.Path();
                tempScreenPosition.copy(screenPoints[0]);
                for (let i = 0; i < screenPoints.length - 1; ++i) {
                    textPath.add(new SimplePath_1.SimpleLineCurve(screenPoints[i], screenPoints[i + 1]));
                }
                // Flip the path if the label is gonna be rendered downwards.
                if (textPath.getPoint(0.5).x - textPath.getPoint(0.51).x > 0) {
                    tempScreenPosition.copy(screenPoints[screenPoints.length - 1]);
                    textPath = new THREE.Path();
                    for (let i = screenPoints.length - 1; i > 0; --i) {
                        textPath.add(new SimplePath_1.SimpleLineCurve(screenPoints[i], screenPoints[i - 1]));
                    }
                }
                // Update the real rendering distance to have smooth fading and scaling
                this.updateViewDistance(this.m_mapView.worldCenter, pathLabel);
                const textRenderDistance = pathLabel.renderDistance;
                const startScaleDistance = cameraFar * labelStartScaleDistance;
                const renderDistance = -textRenderDistance;
                if (renderDistance > startScaleDistance) {
                    distanceScale =
                        1.0 -
                            ((renderDistance - startScaleDistance) / (cameraFar - startScaleDistance)) *
                                (1.0 - pathLabel.distanceScale);
                    textScale *= distanceScale;
                }
                // Scale the path label correctly.
                const prevSize = textCanvas.textRenderStyle.fontSize.size;
                textCanvas.textRenderStyle.fontSize.size = textScale * 100;
                // Recalculate the text bounds for this path label. If measurement fails, the whole
                // label doesn't fit the path and should be discarded.
                tempMeasurementParams.path = textPath;
                tempMeasurementParams.outputCharacterBounds = tempBoxes;
                tempMeasurementParams.letterCaseArray = pathLabel.glyphCaseArray;
                if (!textCanvas.measureText(pathLabel.glyphs, tempBox, tempMeasurementParams)) {
                    textCanvas.textRenderStyle.fontSize.size = prevSize;
                    return false;
                }
                // Perform per-character collision checks.
                for (const charBounds of tempBoxes) {
                    tempBox2D.x = tempScreenPosition.x + charBounds.min.x;
                    tempBox2D.y = tempScreenPosition.y + charBounds.min.y;
                    tempBox2D.w = charBounds.max.x - charBounds.min.x;
                    tempBox2D.h = charBounds.max.y - charBounds.min.y;
                    if (!this.m_screenCollisions.isVisible(tempBox2D) ||
                        (!textElement.textMayOverlap &&
                            this.m_screenCollisions.isAllocated(tempBox2D))) {
                        textCanvas.textRenderStyle.fontSize.size = prevSize;
                        return false;
                    }
                }
                // Fade-in after skipping rendering during movement.
                // NOTE: Shouldn't this only happen once we know the label is gonna be visible?
                if (pathLabel.textRenderState === undefined) {
                    pathLabel.textRenderState = new TextElement_1.RenderState();
                    pathLabel.textRenderState.fadingTime = this.m_mapView.fadingDisabled
                        ? 0
                        : pathLabel.textRenderState.fadingTime;
                }
                if (pathLabel.textRenderState.state === TextElement_1.FadingState.Undefined ||
                    pathLabel.textRenderState.lastFrameNumber < frameNumber - 1) {
                    this.startFadeIn(pathLabel.textRenderState, frameNumber, time);
                }
                const startedFadeIn = this.checkStartFadeIn(pathLabel.textRenderState, frameNumber, time);
                fadeAnimationRunning = fadeAnimationRunning || startedFadeIn;
                if (pathLabel.textRenderState.isFading()) {
                    opacity = pathLabel.textRenderState.opacity;
                }
                const prevOpacity = textCanvas.textRenderStyle.opacity;
                const prevBgOpacity = textCanvas.textRenderStyle.backgroundOpacity;
                const distanceFadeFactor = this.getDistanceFadingFactor(pathLabel, cameraFar);
                textCanvas.textRenderStyle.opacity = opacity * distanceFadeFactor;
                textCanvas.textRenderStyle.backgroundOpacity =
                    textCanvas.textRenderStyle.opacity * textElement.renderStyle.backgroundOpacity;
                tempPosition.z = textElement.renderDistance;
                tempAdditionParams.path = textPath;
                tempAdditionParams.layer = pathLabel.renderOrder;
                tempAdditionParams.letterCaseArray = pathLabel.glyphCaseArray;
                textCanvas.addText(pathLabel.glyphs, tempPosition, tempAdditionParams);
                // Allocate collision info if needed.
                if (pathLabel.textReservesSpace) {
                    tempBox2D.x = tempScreenPosition.x + tempBox.min.x;
                    tempBox2D.y = tempScreenPosition.y + tempBox.min.y;
                    tempBox2D.w = tempBox.max.x - tempBox.min.x;
                    tempBox2D.h = tempBox.max.y - tempBox.min.y;
                    this.m_screenCollisions.allocate(tempBox2D);
                }
                // Add this label to the list of rendered elements.
                if (renderedTextElements !== undefined) {
                    renderedTextElements.push(pathLabel);
                }
                numRenderedTextElements++;
                // Restore previous style values for text elements using the same style.
                textCanvas.textRenderStyle.fontSize.size = prevSize;
                textCanvas.textRenderStyle.opacity = prevOpacity;
                textCanvas.textRenderStyle.backgroundOpacity = prevBgOpacity;
                return true;
            };
            // Render a POI...
            if (textElement.path === undefined) {
                addPoiLabel(textElement);
            }
            // ... a line marker...
            else if (textElement.isLineMarker) {
                addLineMarkerLabel(textElement);
            }
            // ... or a path label.
            else {
                addPathLabel(textElement);
            }
        }
        if (PRINT_LABEL_DEBUG_INFO && printInfo) {
            logger.log("textElements.length", textElements.length);
            logger.log("numRenderedTextElements", numRenderedTextElements);
            logger.log("numRenderedPoiIcons", numRenderedPoiIcons);
            logger.log("numRenderedPoiTexts", numRenderedPoiTexts);
            logger.log("numPoiTextsInvisible", numPoiTextsInvisible);
            logger.log("numNotVisible", numNotVisible);
            logger.log("numPathTooSmall", numPathTooSmall);
            logger.log("numCannotAdd", numCannotAdd);
        }
        if (!this.m_mapView.fadingDisabled && fadeAnimationRunning) {
            this.m_mapView.update();
        }
        return numRenderedTextElements;
    }
    checkForSmallLabels(textElement) {
        let indexOfFirstVisibleScreenPoint = -1;
        // Get the screen points that define the label's segments and create a path with
        // them.
        const screenPoints = [];
        let minX = Number.MAX_SAFE_INTEGER;
        let maxX = Number.MIN_SAFE_INTEGER;
        let minY = Number.MAX_SAFE_INTEGER;
        let maxY = Number.MIN_SAFE_INTEGER;
        for (const pt of textElement.path) {
            tempPosition.copy(pt).add(textElement.tileCenter);
            const screenPoint = this.m_screenProjector.project(tempPosition, tempScreenPosition);
            if (screenPoint === undefined) {
                continue;
            }
            screenPoints.push(tempScreenPosition.clone());
            if (screenPoint.x < minX) {
                minX = screenPoint.x;
            }
            if (screenPoint.x > maxX) {
                maxX = screenPoint.x;
            }
            if (screenPoint.y < minY) {
                minY = screenPoint.y;
            }
            if (screenPoint.y > maxY) {
                maxY = screenPoint.y;
            }
            if (indexOfFirstVisibleScreenPoint < 0) {
                const firstIndex = screenPoints.findIndex(p2 => {
                    return this.m_screenCollisions.screenBounds.contains(p2.x, p2.y);
                });
                if (firstIndex >= 0) {
                    indexOfFirstVisibleScreenPoint = firstIndex;
                }
            }
        }
        // TODO: (HARP-3515)
        //      The rendering of a path label that contains just a single point that is not
        //      visible is impossible, which is problematic with long paths.
        //      Fix: Skip/clip the invisible points at beginning and end of the path to get
        //      the visible part of the path.
        // If not a single point is visible, skip the path
        if (indexOfFirstVisibleScreenPoint === -1) {
            return undefined;
        }
        // Check/guess if the screen box can hold a string of that length. It is important
        // to guess that value without measuring the font first to save time.
        const minScreenSpace = textElement.text.length * MIN_AVERAGE_CHAR_WIDTH;
        if ((maxX - minX) * (maxX - minX) + (maxY - minY) * (maxY - minY) <
            minScreenSpace * minScreenSpace) {
            textElement.dbgPathTooSmall = true;
            return undefined;
        }
        return screenPoints;
    }
    renderTileList(visibleTiles, time, frameNumber, zoomLevel, renderStartTime, renderedTextElements, secondChanceTextElements) {
        if (this.m_textRenderers.length === 0 || visibleTiles.length === 0) {
            return;
        }
        const consideredTextElements = new harp_utils_1.GroupedPriorityList();
        for (const tile of visibleTiles) {
            consideredTextElements.merge(tile.placedTextElements);
        }
        const maxNumRenderedTextElements = this.m_maxNumVisibleLabels;
        let numRenderedTextElements = 0;
        for (const elementGroup of consideredTextElements.sortedGroups) {
            const textElementsInGroup = elementGroup.elements;
            this.sortTextElements(textElementsInGroup, this.m_mapView.camera.far);
            numRenderedTextElements += this.renderTextElements(textElementsInGroup, time, frameNumber, zoomLevel, renderedTextElements, secondChanceTextElements);
            if (numRenderedTextElements > maxNumRenderedTextElements) {
                break;
            }
            // renderStartTime is set if this.overloaded is true
            if (renderStartTime !== undefined && OVERLOAD_RENDER_TIME_LIMIT > 0) {
                const endTime = harp_utils_1.PerformanceTimer.now();
                const elapsedTime = endTime - renderStartTime;
                if (elapsedTime > OVERLOAD_RENDER_TIME_LIMIT) {
                    return;
                }
            }
        }
    }
    checkIfOverloaded() {
        const renderList = this.m_mapView.visibleTileSet.dataSourceTileList;
        // Count the number of TextElements in the scene to see if we have to switch to
        // "overloadMode".
        let numTextElementsInScene = 0;
        renderList.forEach(renderListEntry => {
            for (const tile of renderListEntry.renderedTiles) {
                numTextElementsInScene += tile.textElementGroups.count();
                numTextElementsInScene += tile.userTextElements.length;
            }
        });
        this.m_overloaded = numTextElementsInScene > OVERLOAD_LABEL_LIMIT;
        return this.m_overloaded;
    }
    checkStartFadeIn(renderState, frameNumber, time, forceFadeIn = false) {
        let fadeAnimationStarted = false;
        if (renderState !== undefined) {
            // Fade-in after skipping rendering during movement
            if (forceFadeIn ||
                renderState.state === TextElement_1.FadingState.Undefined ||
                renderState.lastFrameNumber < frameNumber - 1) {
                this.startFadeIn(renderState, frameNumber, time);
            }
            if (renderState.isFading()) {
                this.updateFading(renderState, time);
                fadeAnimationStarted = true;
            }
            renderState.lastFrameNumber = frameNumber;
        }
        return fadeAnimationStarted;
    }
    checkStartFadeOut(renderState, frameNumber, time, forceFadeOut = true) {
        let fadeAnimationStarted = false;
        if (renderState !== undefined) {
            // Fade-in after skipping rendering during movement
            if (forceFadeOut ||
                renderState.state === TextElement_1.FadingState.Undefined ||
                renderState.lastFrameNumber < frameNumber - 1) {
                this.startFadeOut(renderState, frameNumber, time);
            }
            if (renderState.isFading()) {
                this.updateFading(renderState, time);
                fadeAnimationStarted = true;
            }
            renderState.lastFrameNumber = frameNumber;
        }
        return fadeAnimationStarted;
    }
    startFadeIn(renderState, frameNumber, time) {
        if (renderState.lastFrameNumber < frameNumber - 1) {
            renderState.reset();
        }
        if (renderState.state === TextElement_1.FadingState.FadingIn ||
            renderState.state === TextElement_1.FadingState.FadedIn) {
            return;
        }
        if (renderState.state === TextElement_1.FadingState.FadingOut) {
            // The fadeout is not complete: compute the virtual fadingStartTime in the past, to get
            // a correct end time:
            renderState.value = 1.0 - renderState.value;
            renderState.startTime = time - renderState.value * renderState.fadingTime;
        }
        else {
            renderState.startTime = time;
            renderState.value = 0.0;
            renderState.opacity = 0;
        }
        renderState.state = TextElement_1.FadingState.FadingIn;
    }
    startFadeOut(renderState, frameNumber, time) {
        if (renderState.lastFrameNumber < frameNumber - 1) {
            renderState.reset();
        }
        if (renderState.state === TextElement_1.FadingState.FadingOut ||
            renderState.state === TextElement_1.FadingState.FadedOut) {
            return;
        }
        if (renderState.state === TextElement_1.FadingState.FadingIn) {
            // The fade-in is not complete: compute the virtual fadingStartTime in the past, to get
            // a correct end time:
            renderState.startTime = time - renderState.value * renderState.fadingTime;
            renderState.value = 1.0 - renderState.value;
        }
        else {
            renderState.startTime = time;
            renderState.value = 0.0;
            renderState.opacity = 1;
        }
        renderState.state = TextElement_1.FadingState.FadingOut;
    }
    updateFading(renderState, time) {
        if (renderState.state !== TextElement_1.FadingState.FadingIn &&
            renderState.state !== TextElement_1.FadingState.FadingOut) {
            return;
        }
        if (renderState.startTime === 0) {
            renderState.startTime = time;
        }
        const fadingTime = time - renderState.startTime;
        const startValue = renderState.state === TextElement_1.FadingState.FadingIn ? 0 : 1;
        const endValue = renderState.state === TextElement_1.FadingState.FadingIn ? 1 : 0;
        if (fadingTime >= renderState.fadingTime) {
            renderState.value = 1.0;
            renderState.opacity = endValue;
            renderState.state =
                renderState.state === TextElement_1.FadingState.FadingIn
                    ? TextElement_1.FadingState.FadedIn
                    : TextElement_1.FadingState.FadedOut;
        }
        else {
            renderState.value = fadingTime / renderState.fadingTime;
            renderState.opacity = harp_utils_1.MathUtils.clamp(harp_utils_1.MathUtils.smootherStep(startValue, endValue, renderState.value), 0, 1);
        }
    }
}
exports.TextElementsRenderer = TextElementsRenderer;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "./node_modules/@here/harp-text-canvas/index.js");
const ColorCache_1 = __webpack_require__(/*! ../ColorCache */ "./node_modules/@here/harp-mapview/lib/ColorCache.js");
/**
 * [[TextStyle]] id for the default value inside a [[TextRenderStyleCache]] or a
 * [[TextLayoutStyleCache]].
 */
exports.DEFAULT_TEXT_STYLE_CACHE_ID = "Default";
/**
 * Calculates the [[TextStyle]] id that identifies either a [[TextRenderStyle]] or a
 * [[TextLayoutStyle]] inside a [[TextRenderStyleCache]] or a [[TextLayoutStyleCache]],
 * respectively.
 *
 * @param technique Technique defining the [[TextStyle]].
 * @param zoomLevel Zoom level for which to interpret the technique.
 *
 * @returns [[TextStyle]] id.
 */
function computeStyleCacheId(datasourceName, technique, zoomLevel) {
    return `${datasourceName}_${technique._styleSetIndex}_${zoomLevel}`;
}
exports.computeStyleCacheId = computeStyleCacheId;
/**
 * Cache storing [[MapView]]'s [[TextRenderStyle]]s.
 */
class TextRenderStyleCache {
    constructor() {
        this.m_map = new Map();
        this.m_map.set(exports.DEFAULT_TEXT_STYLE_CACHE_ID, new harp_text_canvas_1.TextRenderStyle({
            fontSize: {
                unit: harp_text_canvas_1.FontUnit.Pixel,
                size: 32,
                backgroundSize: 8
            },
            color: ColorCache_1.ColorCache.instance.getColor("#6d7477"),
            backgroundColor: ColorCache_1.ColorCache.instance.getColor("#f7fbfd"),
            backgroundOpacity: 0.5
        }));
    }
    get size() {
        return this.m_map.size;
    }
    get(id) {
        return this.m_map.get(id);
    }
    set(id, value) {
        this.m_map.set(id, value);
    }
    clear() {
        this.m_map.clear();
        this.m_map.set(exports.DEFAULT_TEXT_STYLE_CACHE_ID, new harp_text_canvas_1.TextRenderStyle({
            fontSize: {
                unit: harp_text_canvas_1.FontUnit.Pixel,
                size: 32,
                backgroundSize: 8
            },
            color: ColorCache_1.ColorCache.instance.getColor("#6d7477"),
            backgroundColor: ColorCache_1.ColorCache.instance.getColor("#f7fbfd"),
            backgroundOpacity: 0.5
        }));
    }
}
exports.TextRenderStyleCache = TextRenderStyleCache;
/**
 * Cache storing [[MapView]]'s [[TextLayoutStyle]]s.
 */
class TextLayoutStyleCache {
    constructor() {
        this.m_map = new Map();
        this.m_map.set(exports.DEFAULT_TEXT_STYLE_CACHE_ID, new harp_text_canvas_1.TextLayoutStyle({
            verticalAlignment: harp_text_canvas_1.VerticalAlignment.Center,
            horizontalAlignment: harp_text_canvas_1.HorizontalAlignment.Center
        }));
    }
    get size() {
        return this.m_map.size;
    }
    get(id) {
        return this.m_map.get(id);
    }
    set(id, value) {
        this.m_map.set(id, value);
    }
    clear() {
        this.m_map.clear();
        this.m_map.set(exports.DEFAULT_TEXT_STYLE_CACHE_ID, new harp_text_canvas_1.TextLayoutStyle({
            verticalAlignment: harp_text_canvas_1.VerticalAlignment.Center,
            horizontalAlignment: harp_text_canvas_1.HorizontalAlignment.Center
        }));
    }
}
exports.TextLayoutStyleCache = TextLayoutStyleCache;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/workers/WorkerBootstrapDefs.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/workers/WorkerBootstrapDefs.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
function isWorkerBootstrapRequest(message) {
    return (message &&
        message.type === "worker-bootstrap-request" &&
        Array.isArray(message.dependencies));
}
exports.isWorkerBootstrapRequest = isWorkerBootstrapRequest;
function isWorkerBootstrapResponse(message) {
    return (message &&
        message.type === "worker-bootstrap-response" &&
        Array.isArray(message.resolvedDependencies));
}
exports.isWorkerBootstrapResponse = isWorkerBootstrapResponse;


/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(/*! @here/harp-fetch */ "./node_modules/@here/harp-fetch/index.web.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const WorkerBootstrapDefs_1 = __webpack_require__(/*! ./WorkerBootstrapDefs */ "./node_modules/@here/harp-mapview/lib/workers/WorkerBootstrapDefs.js");
const logger = harp_utils_1.LoggerManager.instance.create("WorkerLoader");
/**
 * Set of `Worker` loading and initialization helpers:
 *  - starting Worker from URL with fallback to XHR+blob [[WorkerLoader.startWorker]]
 *  - waiting for proper worker initialization, see [[WorkerLoader.waitWorkerInitialized]]
 */
class WorkerLoader {
    /**
     * Starts worker by first attempting load from `scriptUrl` using native `Worker` constructor.
     * Then waits (using [[waitWorkerInitialized]]) for its successful initialization. In case of
     * error falls back to [[startWorkerBlob]].
     *
     * This method is needed as browsers in general forbid to load worker if it's not on 'same
     * origin' regardless of Content-Security-Policy.
     *
     * For blob-based fallback work, one need to ensure that Content Security Policy (CSP) allows
     * loading web worker code from `Blob`s. By default browsers, allow 'blob:' for workers, but
     * this may change.
     *
     * Following snippet setups CSP, so workers can be started from blob urls:
     *
     *     <head>
     *         <meta http-equiv="Content-Security-Policy" content="child-src blob:">
     *     </head>
     *
     * Tested on:
     *   * Chrome 67 / Linux, Window, OSX, Android
     *   * Firefox 60 / Linux, Windows, OSX
     *   * Edge 41 / Windows
     *   * Safari 11 / OSX
     *   * Samsung Internet 7.2
     *
     * See
     *  * https://benohead.com/cross-domain-cross-browser-web-workers/
     *  * MapBox
     *    * https://stackoverflow.com/questions/21913673/execute-web-worker-from-different-origin
     *    * https://github.com/mapbox/mapbox-gl-js/issues/2658
     *    * https://github.com/mapbox/mapbox-gl-js/issues/559
     *    * https://github.com/mapbox/mapbox-gl-js/issues/6058
     *
     * Findings:
     *
     * * Chrome reports CSP by exception when constructing [[Worker]] instance.
     * * Firefox reports CSP errors when loading in first event:
     *   https://bugzilla.mozilla.org/show_bug.cgi?id=1241888
     * * Firefox 62, Chrome 67 obeys `<meta http-equiv="Content-Security-Policy">` with
     *   `worker-src blob:` but doesn't obey `worker-src URL` when used
     * * Chrome 67 doesn't obey CSP `worker-src URL` despite it's documented as supported
     *   (https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy/worker-src)
     *
     * @param scriptUrl web worker script URL
     */
    static startWorker(scriptUrl) {
        if (scriptUrl.startsWith("blob:")) {
            return this.startWorkerImmediately(scriptUrl);
        }
        if (this.directlyFallbackToBlobBasedLoading) {
            return this.startWorkerBlob(scriptUrl);
        }
        return this.startWorkerImmediately(scriptUrl).catch(error => {
            logger.log("#startWorker: worker construction failed, attempting load with blob");
            this.directlyFallbackToBlobBasedLoading = true;
            return WorkerLoader.startWorkerBlob(scriptUrl);
        });
    }
    /**
     * Start worker, loading it immediately from `scriptUrl`. Waits (using
     * [[waitWorkerInitialized]]) for successful worker start.
     *
     * @param scriptUrl web worker script URL
     */
    static startWorkerImmediately(scriptUrl) {
        try {
            const worker = new Worker(scriptUrl);
            return this.waitWorkerInitialized(worker);
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    /**
     * Start worker "via blob" by first loading worker script code with [[fetch]], creating `Blob`
     * and attempting to start worker from blob url. Waits (using [[waitWorkerInitialized]]) for
     * successful worker start.
     *
     * @param scriptUrl web worker script URL
     */
    static startWorkerBlob(scriptUrl) {
        return this.fetchScriptSourceToBlobUrl(scriptUrl).then(blobUrl => {
            return this.startWorkerImmediately(blobUrl);
        });
    }
    /**
     * Fetch script source as `Blob` url.
     *
     * Reuses results, if there are many simultaneous requests.
     *
     * @param scriptUrl web worker script URL
     * @return promise that resolves to url of a `Blob` with script source code
     */
    static fetchScriptSourceToBlobUrl(scriptUrl) {
        let loadingPromise = this.sourceLoaderCache.get(scriptUrl);
        if (loadingPromise !== undefined) {
            return loadingPromise;
        }
        loadingPromise = fetch(scriptUrl)
            .then(response => response.text())
            .catch(error => {
            throw new Error(`WorkerLoader#fetchScriptSourceToBlob: failed to load worker script: ${error}`);
        })
            .then(scriptSource => {
            this.sourceLoaderCache.delete(scriptUrl);
            const blob = new Blob([scriptSource], { type: "application/javascript" });
            return URL.createObjectURL(blob);
        });
        this.sourceLoaderCache.set(scriptUrl, loadingPromise);
        return loadingPromise;
    }
    /**
     * Waits for successful Web Worker start.
     *
     * Expects that worker script sends initial message.
     *
     * If first event is `message` then assumes that worker has been loaded sussesfully and promise
     * resolves to `worker` object passed as argument.
     *
     * If first event is 'error', then it is assumed that worker failed to load and promise is
     * rejected.
     *
     * (NOTE: The initial 'message' - if received - is immediately replayed using worker's
     * `dispatchEvent`, so application code can also consume it as confirmation of successful
     * worker initialization.
     *
     * @param worker [[Worker]] instance to be checked
     * @returns `Promise` that resolves to `worker` on success
     */
    static waitWorkerInitialized(worker) {
        return new Promise((resolve, reject) => {
            const firstMessageCallback = (event) => {
                const message = event.data;
                if (WorkerBootstrapDefs_1.isWorkerBootstrapRequest(message)) {
                    const dependencies = message.dependencies;
                    const resolvedDependencies = [];
                    for (const dependency of dependencies) {
                        const resolved = this.dependencyUrlMapping[dependency];
                        if (!resolved) {
                            reject(new Error(`#waitWorkerInitialized: Unable to resolve '${dependency}'` +
                                ` as needed by worker script.`));
                            return;
                        }
                        resolvedDependencies.push(resolved);
                    }
                    const response = {
                        type: "worker-bootstrap-response",
                        resolvedDependencies
                    };
                    worker.postMessage(response);
                    return;
                }
                worker.removeEventListener("message", firstMessageCallback);
                worker.removeEventListener("error", errorCallback);
                resolve(worker);
                // We've just consumed first message from worker before client has any chance to
                // even call `addEventListener` on it, so here after resolve, we wait next tick and
                // replay message so user has chance to intercept it in its own handler.
                setTimeout(() => {
                    worker.dispatchEvent(event);
                }, 0);
            };
            const errorCallback = (error) => {
                // Error events do not carry any useful information on tested browsers, so we assume
                // that any error before 'firstMessageCallback' as failed Worker initialization.
                worker.removeEventListener("message", firstMessageCallback);
                worker.removeEventListener("error", errorCallback);
                reject(new Error("#waitWorkerInitialized: Error event before first message."));
            };
            worker.addEventListener("message", firstMessageCallback);
            worker.addEventListener("error", errorCallback);
        });
    }
}
WorkerLoader.directlyFallbackToBlobBasedLoading = false;
WorkerLoader.sourceLoaderCache = new Map();
WorkerLoader.dependencyUrlMapping = {};
exports.WorkerLoader = WorkerLoader;


/***/ }),

/***/ "./node_modules/@here/harp-materials/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@here/harp-materials/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/CopyMaterial */ "./node_modules/@here/harp-materials/lib/CopyMaterial.js"));
__export(__webpack_require__(/*! ./lib/SepiaShader */ "./node_modules/@here/harp-materials/lib/SepiaShader.js"));
__export(__webpack_require__(/*! ./lib/VignetteShader */ "./node_modules/@here/harp-materials/lib/VignetteShader.js"));
__export(__webpack_require__(/*! ./lib/DashedLineMaterial */ "./node_modules/@here/harp-materials/lib/DashedLineMaterial.js"));
__export(__webpack_require__(/*! ./lib/EdgeMaterial */ "./node_modules/@here/harp-materials/lib/EdgeMaterial.js"));
__export(__webpack_require__(/*! ./lib/MapMeshMaterials */ "./node_modules/@here/harp-materials/lib/MapMeshMaterials.js"));
__export(__webpack_require__(/*! ./lib/HighPrecisionLineMaterial */ "./node_modules/@here/harp-materials/lib/HighPrecisionLineMaterial.js"));
__export(__webpack_require__(/*! ./lib/HighPrecisionPointMaterial */ "./node_modules/@here/harp-materials/lib/HighPrecisionPointMaterial.js"));
__export(__webpack_require__(/*! ./lib/IconMaterial */ "./node_modules/@here/harp-materials/lib/IconMaterial.js"));
__export(__webpack_require__(/*! ./lib/SolidLineMaterial */ "./node_modules/@here/harp-materials/lib/SolidLineMaterial.js"));
__export(__webpack_require__(/*! ./lib/CirclePointsMaterial */ "./node_modules/@here/harp-materials/lib/CirclePointsMaterial.js"));
__export(__webpack_require__(/*! ./lib/MSAAMaterial */ "./node_modules/@here/harp-materials/lib/MSAAMaterial.js"));
__export(__webpack_require__(/*! ./lib/LuminosityHighPassShader */ "./node_modules/@here/harp-materials/lib/LuminosityHighPassShader.js"));


/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/CirclePointsMaterial.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/CirclePointsMaterial.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const vertexShader = `
uniform float size;

void main() {
    vec3 transformed = vec3(position);
    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);

    gl_Position = projectionMatrix * mvPosition;
    gl_PointSize = size;
}
`;
const fragmentShader = `
uniform vec3 diffuse;

void main() {
    float alpha = 1.0;

    float radius = 0.5;
    vec2 coords = gl_PointCoord.xy - vec2(0.5);
    float len = length(coords);
    float falloff = fwidth(len);
    float threshold = 1.0 - smoothstep(radius - falloff, radius, len);
    alpha *= threshold;

    gl_FragColor = vec4(diffuse, alpha);
}`;
const DEFAULT_CIRCLE_SIZE = 1;
/**
 * Material designed to render circle points. Note that it is always transparent since the circle
 * shape is created with an alpha channel to benefit an antialising that a mere `discard` could
 * not bring.
 */
class CirclePointsMaterial extends THREE.ShaderMaterial {
    /**
     * Constructs a new `CirclePointsMaterial`.
     *
     * @param parameters The constructor's parameters.
     */
    constructor(parameters = {}) {
        parameters.depthTest = false;
        super(parameters);
        this.isCirclePointsMaterial = true;
        this.type = "CirclePointsMaterial";
        this.vertexShader = vertexShader;
        this.fragmentShader = fragmentShader;
        this.transparent = true;
        this.m_size = parameters.size || DEFAULT_CIRCLE_SIZE;
        this.m_color = new THREE.Color();
        this.uniforms = {
            diffuse: new THREE.Uniform(this.m_color),
            size: new THREE.Uniform(this.m_size)
        };
        this.extensions.derivatives = true;
    }
    /**
     * Gets the circle screen size.
     */
    get size() {
        return this.m_size;
    }
    /**
     * Sets the circle screen size.
     */
    set size(size) {
        this.m_size = size;
        this.uniforms.size.value = size;
        this.needsUpdate = true;
    }
    /**
     * Gets the diffuse.
     */
    get color() {
        return "#" + this.m_color.getHexString();
    }
    /**
     * Sets the diffuse.
     */
    set color(color) {
        this.m_color.set(color);
        this.uniforms.diffuse.value.set(this.m_color);
        this.needsUpdate = true;
    }
}
exports.CirclePointsMaterial = CirclePointsMaterial;


/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/CopyMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/CopyMaterial.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
/**
 * The base shader to use for [[MapView]]'s composing passes, like [[MSAAMaterial]].
 */
exports.CopyShader = {
    uniforms: {
        tDiffuse: { value: null },
        opacity: { value: 1.0 }
    },
    vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }`,
    fragmentShader: `
    uniform float opacity;
    uniform sampler2D tDiffuse;
    varying vec2 vUv;
    void main() {
        vec4 texel = texture2D( tDiffuse, vUv );
        gl_FragColor = opacity * texel;
    }`
};
/**
 * The material is used for composing.
 */
class CopyMaterial extends THREE.ShaderMaterial {
    /**
     * The constructor of `CopyMaterial`.
     *
     * @param uniforms The [[CopyShader]]'s uniforms.
     */
    constructor(uniforms) {
        super({
            name: "CopyMaterial",
            uniforms,
            vertexShader: exports.CopyShader.vertexShader,
            fragmentShader: exports.CopyShader.fragmentShader,
            premultipliedAlpha: true,
            transparent: false,
            blending: THREE.NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}
exports.CopyMaterial = CopyMaterial;


/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/DashedLineMaterial.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/DashedLineMaterial.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const SolidLineMaterial_1 = __webpack_require__(/*! ./SolidLineMaterial */ "./node_modules/@here/harp-materials/lib/SolidLineMaterial.js");
/**
 * Material designed to render dashed variable-width lines.
 */
class DashedLineMaterial extends SolidLineMaterial_1.SolidLineMaterial {
    /**
     * Constructs a new `DashedLineMaterial`.
     *
     * @param params `DashedLineMaterial` parameters.
     */
    constructor(params) {
        const shaderParams = {};
        if (params !== undefined && params.color !== undefined) {
            shaderParams.color = params.color;
        }
        if (params !== undefined && params.lineWidth !== undefined) {
            shaderParams.lineWidth = params.lineWidth;
        }
        if (params !== undefined && params.opacity !== undefined) {
            shaderParams.opacity = params.opacity;
        }
        if (params !== undefined && params.fog !== undefined) {
            shaderParams.fog = params.fog;
        }
        super(shaderParams);
        this.name = "DashedLineMaterial";
        Object.assign(this.uniforms, {
            dashSize: new THREE.Uniform(DashedLineMaterial.DEFAULT_DASH_SIZE),
            gapSize: new THREE.Uniform(DashedLineMaterial.DEFAULT_GAP_SIZE)
        });
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.dashSize !== undefined) {
                this.dashSize = params.dashSize;
            }
            if (params.gapSize !== undefined) {
                this.gapSize = params.gapSize;
            }
            if (params.fog !== undefined) {
                this.fog = params.fog !== null;
            }
        }
    }
    /**
     * Size of the dashed segments.
     */
    get dashSize() {
        return this.uniforms.dashSize.value;
    }
    set dashSize(value) {
        this.uniforms.dashSize.value = value;
    }
    /**
     * Size of the gaps between dashed segments.
     */
    get gapSize() {
        return this.uniforms.gapSize.value;
    }
    set gapSize(value) {
        this.uniforms.gapSize.value = value;
        this.updateDashedFeature();
    }
    updateDashedFeature() {
        this.defines.DASHED_LINE = this.gapSize > 0.0 ? 1 : 0;
    }
}
DashedLineMaterial.DEFAULT_DASH_SIZE = 1.0;
DashedLineMaterial.DEFAULT_GAP_SIZE = 1.0;
exports.DashedLineMaterial = DashedLineMaterial;


/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/EdgeMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/EdgeMaterial.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const AnimatedExtrusionHandler_1 = __webpack_require__(/*! ../../harp-mapview/lib/AnimatedExtrusionHandler */ "./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js");
const MapMeshMaterials_1 = __webpack_require__(/*! ./MapMeshMaterials */ "./node_modules/@here/harp-materials/lib/MapMeshMaterials.js");
const vertexSource = `
attribute vec3 position;
attribute vec4 color;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform vec3 edgeColor;
uniform float edgeColorMix;

varying vec3 vColor;

#ifdef USE_EXTRUSION
#include <extrusion_pars_vertex>
#endif

#ifdef USE_FADING
#include <fading_pars_vertex>
#endif

void main() {
    #ifdef USE_COLOR
    vColor = mix(edgeColor.rgb, color.rgb, edgeColorMix);
    #else
    vColor = edgeColor.rgb;
    #endif

    vec3 transformed = vec3( position );

    #ifdef USE_EXTRUSION
    #include <extrusion_vertex>
    #endif

    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );

    gl_Position = projectionMatrix * mvPosition;

    #ifdef USE_FADING
    #include <fading_vertex>
    #endif
}`;
const fragmentSource = `
precision highp float;
precision highp int;

varying vec3 vColor;

#ifdef USE_EXTRUSION
#include <extrusion_pars_fragment>
#endif

#ifdef USE_FADING
#include <fading_pars_fragment>
#endif

void main() {
    float alphaValue = 1.0;
    gl_FragColor = vec4(vColor, alphaValue);

    #ifdef USE_EXTRUSION
    #include <extrusion_fragment>
    #endif

    #ifdef USE_FADING
    #include <fading_fragment>
    #endif
}`;
/**
 * Material designed to render the edges of extruded buildings using GL_LINES. It supports solid
 * colors, vertex colors, color mixing and distance fading.
 */
class EdgeMaterial extends THREE.RawShaderMaterial {
    /**
     * Constructs a new `EdgeMaterial`.
     *
     * @param params `EdgeMaterial` parameters.
     */
    constructor(params) {
        const shaderParams = {
            name: "EdgeMaterial",
            vertexShader: vertexSource,
            fragmentShader: fragmentSource,
            uniforms: {
                edgeColor: new THREE.Uniform(new THREE.Color(EdgeMaterial.DEFAULT_COLOR)),
                edgeColorMix: new THREE.Uniform(EdgeMaterial.DEFAULT_COLOR_MIX),
                fadeNear: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_NEAR),
                fadeFar: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_FAR),
                extrusionRatio: new THREE.Uniform(AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler.DEFAULT_RATIO_MIN)
            },
            depthWrite: false
        };
        super(shaderParams);
        this.transparent = true;
        MapMeshMaterials_1.FadingFeature.patchGlobalShaderChunks();
        MapMeshMaterials_1.ExtrusionFeature.patchGlobalShaderChunks();
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.color !== undefined) {
                this.color.set(params.color);
            }
            if (params.colorMix !== undefined) {
                this.colorMix = params.colorMix;
            }
            if (params.fadeNear !== undefined) {
                this.fadeNear = params.fadeNear;
            }
            if (params.fadeFar !== undefined) {
                this.fadeFar = params.fadeFar;
            }
        }
    }
    /**
     * Edge color.
     */
    get color() {
        return this.uniforms.edgeColor.value;
    }
    set color(value) {
        this.uniforms.edgeColor.value = value;
    }
    /**
     * Color mix value. Mixes between vertexColors and edgeColor.
     */
    get colorMix() {
        return this.uniforms.edgeColorMix.value;
    }
    set colorMix(value) {
        this.uniforms.edgeColorMix.value = value;
        this.updateColorMixFeature();
    }
    updateColorMixFeature() {
        this.defines.USE_COLOR = this.colorMix > 0.0 ? 1 : 0;
    }
    get fadeNear() {
        return this.uniforms.fadeNear.value;
    }
    set fadeNear(value) {
        this.uniforms.fadeNear.value = value;
    }
    get fadeFar() {
        return this.uniforms.fadeFar.value;
    }
    set fadeFar(value) {
        this.uniforms.fadeFar.value = value;
        const doFade = value !== undefined && value > 0.0;
        if (doFade) {
            this.needsUpdate = this.needsUpdate || this.defines.USE_FADING === undefined;
            this.defines.USE_FADING = "";
        }
        else {
            this.needsUpdate = this.needsUpdate || this.defines.USE_FADING !== undefined;
            delete this.defines.USE_FADING;
        }
    }
    get extrusionRatio() {
        return this.uniforms.extrusionRatio.value;
    }
    set extrusionRatio(value) {
        this.uniforms.extrusionRatio.value = value;
        const doExtrusion = value !== undefined && value >= AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler.DEFAULT_RATIO_MIN;
        if (doExtrusion) {
            this.needsUpdate = this.needsUpdate || this.defines.USE_EXTRUSION === undefined;
            this.defines.USE_EXTRUSION = "";
        }
        else {
            this.needsUpdate = this.needsUpdate || this.defines.USE_EXTRUSION !== undefined;
            delete this.defines.USE_EXTRUSION;
        }
    }
}
EdgeMaterial.DEFAULT_COLOR = 0x000000;
EdgeMaterial.DEFAULT_COLOR_MIX = 0.0;
exports.EdgeMaterial = EdgeMaterial;


/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/HighPrecisionLineMaterial.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/HighPrecisionLineMaterial.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ "./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js");
const vertexSource = `
#ifdef USE_COLOR
attribute vec4 color;
varying vec3 vColor;
#endif

// uniforms to implement double-precision
uniform mat4 u_mvp;             // combined modelView and projection matrix
uniform vec3 u_eyepos;          // eye position major
uniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)

// vertex attributes
attribute vec3 position;        // high part
attribute vec3 positionLow;     // low part

#include <high_precision_vert_func>

void main() {
    #ifdef USE_COLOR
    vColor = color.rgb;
    #endif

    vec3 pos = subtractDblEyePos(position);
    gl_Position = u_mvp * vec4(pos, 1.0);
}`;
const fragmentSource = `
precision highp float;
precision highp int;

uniform vec3 diffuse;
uniform float opacity;

#ifdef USE_COLOR
varying vec3 color;
#endif

void main() {
    #ifdef USE_COLOR
    gl_FragColor = vec4( diffuse * vColor, opacity );
    #else
    gl_FragColor = vec4( diffuse, opacity );
    #endif
}`;
/**
 * Material designed to render high precision lines (ideal for position-sensible data).
 */
class HighPrecisionLineMaterial extends THREE.RawShaderMaterial {
    /**
     * Constructs a new `HighPrecisionLineMaterial`.
     *
     * @param params `HighPrecisionLineMaterial` parameters.
     */
    constructor(params) {
        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);
        const shaderParams = {
            name: "HighPrecisionLineMaterial",
            vertexShader: vertexSource,
            fragmentShader: fragmentSource,
            uniforms: {
                diffuse: new THREE.Uniform(new THREE.Color(HighPrecisionLineMaterial.DEFAULT_COLOR)),
                opacity: new THREE.Uniform(HighPrecisionLineMaterial.DEFAULT_OPACITY),
                u_mvp: new THREE.Uniform(new THREE.Matrix4()),
                u_eyepos: new THREE.Uniform(new THREE.Vector3()),
                u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())
            }
        };
        Object.assign(shaderParams, params);
        super(shaderParams);
        this.type = "HighPrecisionLineMaterial";
        this.isHighPrecisionLineMaterial = true;
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.color !== undefined) {
                this.color.set(params.color);
            }
            if (params.opacity !== undefined) {
                this.opacity = params.opacity;
            }
        }
        this.updateTransparencyFeature();
    }
    /**
     * Line color.
     */
    get color() {
        return this.uniforms.diffuse.value;
    }
    set color(value) {
        this.uniforms.diffuse.value = value;
    }
    updateTransparencyFeature() {
        this.transparent = this.opacity < 1.0 ? true : false;
    }
}
HighPrecisionLineMaterial.DEFAULT_COLOR = 0x000050;
HighPrecisionLineMaterial.DEFAULT_OPACITY = 1.0;
exports.HighPrecisionLineMaterial = HighPrecisionLineMaterial;


/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/HighPrecisionPointMaterial.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/HighPrecisionPointMaterial.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ "./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js");
const vertexSource = `
#ifdef USE_COLOR
varying vec3 vColor;
#endif

uniform float size;

// uniforms to implement double-precision
uniform mat4 u_mvp;             // combined modelView and projection matrix
uniform vec3 u_eyepos;          // eye position major
uniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)

// vertex attributes
attribute vec3 positionLow;     // low part

#include <high_precision_vert_func>

void main() {
    #ifdef USE_COLOR
    vColor = color.rgb;
    #endif

    vec3 pos = subtractDblEyePos(position);
    gl_Position = u_mvp * vec4(pos, 1.0);

    // ignore sizeAttenuation for now!
    gl_PointSize = size;
}`;
/**
 * Material designed to render high precision points (ideal for position-sensible data).
 */
class HighPrecisionPointMaterial extends THREE.PointsMaterial {
    /**
     * Constructs a new `HighPrecisionPointMaterial`.
     *
     * @param params `HighPrecisionPointMaterial` parameters.
     */
    constructor(params) {
        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);
        const shaderParams = params;
        super(shaderParams);
        this.type = "HighPrecisionPointMaterial";
        this.vertexShader = vertexSource;
        this.fragmentShader = THREE.ShaderChunk.points_frag;
        this.fog = false;
        this.uniforms = {
            diffuse: new THREE.Uniform(new THREE.Color(HighPrecisionPointMaterial.DEFAULT_COLOR)),
            opacity: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_OPACITY),
            size: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SIZE),
            scale: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SCALE),
            map: new THREE.Uniform(new THREE.Texture()),
            uvTransform: new THREE.Uniform(new THREE.Matrix3()),
            u_mvp: new THREE.Uniform(new THREE.Matrix4()),
            u_eyepos: new THREE.Uniform(new THREE.Vector3()),
            u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())
        };
        this.isHighPrecisionPointMaterial = true;
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.color !== undefined) {
                this.color.set(params.color);
            }
            if (params.opacity !== undefined) {
                this.opacity = params.opacity;
            }
            if (params.size !== undefined) {
                this.size = params.size;
            }
            if (params.scale !== undefined) {
                this.scale = params.scale;
            }
            if (params.uvTransform !== undefined) {
                this.uvTransform = params.uvTransform;
            }
            if (params.map !== undefined) {
                this.map = params.map;
            }
        }
    }
    /**
     *  Point scale.
     */
    get scale() {
        return this.uniforms.scale.value;
    }
    set scale(value) {
        this.uniforms.scale.value = value;
    }
    /**
     * UV transformation matrix.
     */
    get uvTransform() {
        return this.uniforms.uvTransform.value;
    }
    set uvTransform(value) {
        this.uniforms.uvTransform.value = value;
    }
}
HighPrecisionPointMaterial.DEFAULT_COLOR = 0x000050;
HighPrecisionPointMaterial.DEFAULT_OPACITY = 1.0;
HighPrecisionPointMaterial.DEFAULT_SIZE = 1.0;
HighPrecisionPointMaterial.DEFAULT_SCALE = 1.0;
exports.HighPrecisionPointMaterial = HighPrecisionPointMaterial;
function isHighPrecisionPointMaterial(material) {
    return (material !== undefined &&
        material.isHighPrecisionPointMaterial === true);
}
exports.isHighPrecisionPointMaterial = isHighPrecisionPointMaterial;


/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/IconMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/IconMaterial.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const vertexSource = `
attribute vec4 position;
attribute vec4 color;
attribute vec2 uv;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

varying vec4 vColor;
varying vec2 vUv;

void main() {
    vUv = uv;
    vColor = color;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
}`;
const fragmentSource = `
precision highp float;
precision highp int;

uniform sampler2D map;

varying vec4 vColor;
varying vec2 vUv;

void main() {

    vec4 color = texture2D(map, vUv.xy);
    color *= vColor.a;
    if (color.a < 0.05) {
        discard;
    }
    gl_FragColor = color;
}`;
/**
 * 2D material for icons, similar to [[TextMaterial]]. Uses component in texture coordinates to
 * apply opacity.
 */
class IconMaterial extends THREE.RawShaderMaterial {
    /**
     * Constructs a new `IconMaterial`.
     *
     * @param params `IconMaterial` parameters.
     */
    constructor(params) {
        const shaderParams = {
            name: "IconMaterial",
            vertexShader: vertexSource,
            fragmentShader: fragmentSource,
            uniforms: {
                map: new THREE.Uniform(params.map)
            },
            depthTest: true,
            depthWrite: true,
            transparent: true,
            vertexColors: THREE.VertexColors,
            premultipliedAlpha: true,
            blending: THREE.NormalBlending
        };
        super(shaderParams);
    }
    /**
     * Icon texture map/atlas.
     */
    get map() {
        return this.uniforms.map.value;
    }
}
exports.IconMaterial = IconMaterial;


/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/LuminosityHighPassShader.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/LuminosityHighPassShader.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * The shader used in the [[UnrealBloomPass]] for the bloom/glow effect.
 */
exports.LuminosityHighPassShader = {
    uniforms: {
        tDiffuse: { value: null },
        luminosityThreshold: { value: 1.0 },
        smoothWidth: { value: 1.0 },
        defaultColor: { value: new THREE.Color(0x000000) },
        defaultOpacity: { value: 0.0 }
    },
    vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }`,
    fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform vec3 defaultColor;
    uniform float defaultOpacity;
    uniform float luminosityThreshold;
    uniform float smoothWidth;
    varying vec2 vUv;
    void main() {
        vec4 texel = texture2D( tDiffuse, vUv );
        vec3 luma = vec3( 0.299, 0.587, 0.114 );
        float v = dot( texel.xyz, luma );
        vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );
        float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );
        gl_FragColor = mix( outputColor, texel, alpha );
    }`
};


/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/MSAAMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/MSAAMaterial.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
const CopyMaterial_1 = __webpack_require__(/*! ./CopyMaterial */ "./node_modules/@here/harp-materials/lib/CopyMaterial.js");
/**
 * The material to use for the quad of the [[MSAARenderPass]] in the composing.
 */
class MSAAMaterial extends THREE.ShaderMaterial {
    /**
     * The constructor of `MSAAMaterial`.
     *
     * @param uniforms The [[CopyShader]]'s uniforms.
     */
    constructor(uniforms) {
        super({
            uniforms,
            vertexShader: CopyMaterial_1.CopyShader.vertexShader,
            fragmentShader: CopyMaterial_1.CopyShader.fragmentShader,
            premultipliedAlpha: true,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}
exports.MSAAMaterial = MSAAMaterial;


/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/MapMeshMaterials.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/MapMeshMaterials.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const AnimatedExtrusionHandler_1 = __webpack_require__(/*! ../../harp-mapview/lib/AnimatedExtrusionHandler */ "./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-materials/lib/Utils.js");
const THREE = __webpack_require__(/*! three */ "three");
const ExtrusionChunks_1 = __webpack_require__(/*! ./ShaderChunks/ExtrusionChunks */ "./node_modules/@here/harp-materials/lib/ShaderChunks/ExtrusionChunks.js");
const FadingChunks_1 = __webpack_require__(/*! ./ShaderChunks/FadingChunks */ "./node_modules/@here/harp-materials/lib/ShaderChunks/FadingChunks.js");
/**
 * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into
 * [0..cameraFar].
 *
 * Copy from MapViewUtils, since it cannot be accessed here because of circular dependencies.
 *
 * @param distance Distance from the camera (range: [0, 1]).
 * @param camera Camera applying the perspective projection.
 */
function cameraToWorldDistance(distance, camera) {
    const perspCam = camera;
    return distance * perspCam.far;
}
/**
 * Namespace with support functions for implementors of `FadingFeature`.
 */
var FadingFeature;
(function (FadingFeature) {
    FadingFeature.DEFAULT_FADE_NEAR = -1.0;
    FadingFeature.DEFAULT_FADE_FAR = -1.0;
    /**
     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.
     */
    function patchGlobalShaderChunks() {
        if (THREE.ShaderChunk.fading_pars_vertex === undefined) {
            Object.assign(THREE.ShaderChunk, FadingChunks_1.default);
        }
    }
    FadingFeature.patchGlobalShaderChunks = patchGlobalShaderChunks;
    /**
     * Update the internals of the `FadingFeature` depending on the value of [[fadeNear]]. The
     * fading feature will be disabled if fadeFar <= 0.0.
     *
     * @param fadingMaterial FadingFeature
     */
    function updateDistanceFadeFeature(fadingMaterial) {
        fadingMaterial.needsUpdate = true;
        if (fadingMaterial.defines === undefined) {
            fadingMaterial.defines = {};
        }
        if (fadingMaterial.fadeFar !== undefined && fadingMaterial.fadeFar > 0.0) {
            // Add this define to differentiate it internally from other MeshBasicMaterial
            fadingMaterial.defines.FADING_MATERIAL = "";
        }
    }
    FadingFeature.updateDistanceFadeFeature = updateDistanceFadeFeature;
    /**
     * This function should be called on implementors of FadingFeature in the `onBeforeCompile`
     * callback of that material. It adds the required code to the shaders and declares the new
     * uniforms that control fading based on view distance.
     *
     * @param fadingMaterial Material to add uniforms to.
     * @param shader [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the
     *                  special includes to.
     */
    function onBeforeCompile(fadingMaterial, shader) {
        if (fadingMaterial.fadeFar === undefined || fadingMaterial.fadeFar <= 0.0) {
            return;
        }
        // The vertex and fragment shaders have been constructed dynamically. The uniforms and
        // the shader includes are now appended to them.
        //
        // The object "defines" are not available for this material, so the fading shader chunks
        // have the #ifdefs commented out.
        // Create the uniforms for the shader (if not already existing), and add the new uniforms
        // to it:
        const uniforms = shader.uniforms;
        uniforms.fadeNear = { value: fadingMaterial.fadeNear };
        uniforms.fadeFar = { value: fadingMaterial.fadeFar };
        // Append the new fading shader cod directly after the fog code. This is done by adding an
        // include directive for the fading code.
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "fog_pars_vertex", "fading_pars_vertex");
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "fog_vertex", "fading_vertex", true);
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_pars_fragment", "fading_pars_fragment");
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_fragment", "fading_fragment", true);
    }
    FadingFeature.onBeforeCompile = onBeforeCompile;
    /**
     * As threejs is rendering the transparent objects last (internally), regardless of their
     * renderOrder value, we set the transparent value to false in the [[onAfterRenderCall]]. In
     * [[onBeforeRender]], the function [[calculateDepthFromCameraDistance]] sets it to true if the
     * fade distance value is less than 1.
     *
     * @param object [[THREE.Object3D]] to prepare for rendering.
     * @param fadeNear The fadeNear value to set in the material.
     * @param fadeFar The fadeFar value to set in the material.
     * @param forceMaterialToTransparent If `true`, the material will be forced to render with
     *          blending set to `true`. May be `false` if the material is known to be transparent
     *          anyway.
     * @param updateUniforms If `true`, the fading uniforms are set. Not rquired if material is
     *          handling the uniforms already, like in a [[THREE.ShaderMaterial]].
     * @param additionalCallback If defined, this function will be called before the function will
     *          return.
     */
    function addRenderHelper(object, fadeNear, fadeFar, forceMaterialToTransparent, updateUniforms, additionalCallback) {
        // tslint:disable-next-line:no-unused-variable
        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, (renderer, scene, camera, geometry, material, group) => {
            if (forceMaterialToTransparent) {
                //
                material.transparent = true;
            }
            const fadingMaterial = material;
            fadingMaterial.fadeNear =
                fadeNear === undefined
                    ? FadingFeature.DEFAULT_FADE_NEAR
                    : cameraToWorldDistance(fadeNear, camera);
            fadingMaterial.fadeFar =
                fadeFar === undefined
                    ? FadingFeature.DEFAULT_FADE_FAR
                    : cameraToWorldDistance(fadeFar, camera);
            if (updateUniforms) {
                const properties = renderer.properties.get(material);
                if (properties.shader !== undefined &&
                    properties.shader.uniforms.fadeNear !== undefined) {
                    properties.shader.uniforms.fadeNear.value = fadingMaterial.fadeNear;
                    properties.shader.uniforms.fadeFar.value = fadingMaterial.fadeFar;
                    fadingMaterial.uniformsNeedUpdate = true;
                }
            }
            if (additionalCallback !== undefined) {
                additionalCallback(renderer, material);
            }
        });
        if (forceMaterialToTransparent) {
            object.onAfterRender = (renderer, scene, camera, geom, material) => {
                material.transparent = false;
            };
        }
    }
    FadingFeature.addRenderHelper = addRenderHelper;
})(FadingFeature = exports.FadingFeature || (exports.FadingFeature = {}));
/**
 * Mixin class for extended THREE materials. Adds new properties required for `fadeNear` and
 * `fadeFar`. Thre is some special handling for the fadeNear/fadeFar properties, which get some
 * setters and getters in a way that works well with the mixin.
 *
 * @see [[Tile#addRenderHelper]]
 */
class FadingFeatureMixin {
    constructor() {
        this.m_fadeNear = FadingFeature.DEFAULT_FADE_NEAR;
        this.m_fadeFar = FadingFeature.DEFAULT_FADE_FAR;
    }
    /**
     * @see [[FadingFeature#fadeNear]]
     */
    getFadeNear() {
        return this.m_fadeNear;
    }
    /**
     * @see [[FadingFeature#fadeNear]]
     */
    setFadeNear(value) {
        this.needsUpdate = this.needsUpdate || value !== this.m_fadeNear;
        this.m_fadeNear = value;
        if (this.needsUpdate) {
            FadingFeature.updateDistanceFadeFeature(this);
        }
    }
    /**
     * @see [[FadingFeature#fadeFar]]
     */
    getFadeFar() {
        return this.m_fadeFar;
    }
    /**
     * @see [[FadingFeature#fadeFar]]
     */
    setFadeFar(value) {
        this.needsUpdate = this.needsUpdate || value !== this.m_fadeFar;
        this.m_fadeFar = value;
        if (this.needsUpdate) {
            FadingFeature.updateDistanceFadeFeature(this);
        }
    }
    /**
     * The mixin classes should call this method to register the properties [[fadeNear]] and
     * [[fadeFar]].
     */
    addFadingProperties() {
        Object.defineProperty(this, "fadeNear", {
            get: () => {
                return this.getFadeNear();
            },
            set: val => {
                this.setFadeNear(val);
            }
        });
        Object.defineProperty(this, "fadeFar", {
            get: () => {
                return this.getFadeFar();
            },
            set: val => {
                this.setFadeFar(val);
            }
        });
    }
    /**
     * Apply the fadeNear/fadeFar values from the parameters to the respective properties.
     *
     * @param params `FadingMeshBasicMaterial` parameters.
     */
    applyFadingParameters(params) {
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.fadeNear !== undefined) {
                this.setFadeNear(params.fadeNear);
            }
            if (params.fadeFar !== undefined) {
                this.setFadeFar(params.fadeFar);
            }
        }
        this.onBeforeCompile = (shader) => {
            FadingFeature.onBeforeCompile(this, shader);
        };
    }
    /**
     * Copy fadeNear/fadeFar values from other FadingFeature.
     *
     * @param source The material to copy property values from.
     */
    copyFadingParameters(source) {
        this.setFadeNear(source.fadeNear === undefined ? FadingFeature.DEFAULT_FADE_NEAR : source.fadeNear);
        this.setFadeFar(source.fadeFar === undefined ? FadingFeature.DEFAULT_FADE_FAR : source.fadeFar);
        return this;
    }
}
exports.FadingFeatureMixin = FadingFeatureMixin;
var ExtrusionFeature;
(function (ExtrusionFeature) {
    /**
     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.
     */
    function patchGlobalShaderChunks() {
        if (THREE.ShaderChunk.extrusion_pars_vertex === undefined) {
            Object.assign(THREE.ShaderChunk, ExtrusionChunks_1.default);
        }
    }
    ExtrusionFeature.patchGlobalShaderChunks = patchGlobalShaderChunks;
    /**
     * Update the internals of the `ExtrusionFeature` depending on the value of [[extrusionRatio]].
     *
     * @param ExtrusionMaterial ExtrusionFeature
     */
    function updateExtrusionFeature(extrusionMaterial) {
        extrusionMaterial.needsUpdate = true;
        if (extrusionMaterial.defines === undefined) {
            extrusionMaterial.defines = {};
        }
        if (extrusionMaterial.extrusionRatio !== undefined &&
            extrusionMaterial.extrusionRatio >= AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler.DEFAULT_RATIO_MIN) {
            // Add this define to differentiate it internally from other MeshBasicMaterial
            extrusionMaterial.defines.EXTRUSION_MATERIAL = "";
        }
    }
    ExtrusionFeature.updateExtrusionFeature = updateExtrusionFeature;
    /**
     * This function should be called on implementors of ExtrusionFeature in the `onBeforeCompile`
     * callback of that material. It adds the required code to the shaders and declares the new
     * uniforms that control extrusion.
     *
     * @param extrusionMaterial Material to add uniforms to.
     * @param shader [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the
     *                  special includes to.
     */
    function onBeforeCompile(extrusionMaterial, shader) {
        if (extrusionMaterial.extrusionRatio === undefined) {
            return;
        }
        // The vertex and fragment shaders have been constructed dynamically. The uniforms and
        // the shader includes are now appended to them.
        // Create the uniforms for the shader (if not already existing), and add the new uniforms
        // to it:
        const uniforms = shader.uniforms;
        uniforms.extrusionRatio = { value: extrusionMaterial.extrusionRatio };
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "common", "extrusion_pars_vertex");
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "begin_vertex", "extrusion_vertex", true);
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_pars_fragment", "extrusion_pars_fragment");
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_fragment", "extrusion_fragment", true);
    }
    ExtrusionFeature.onBeforeCompile = onBeforeCompile;
    /**
     * Handles animated extrusion on each frame. Should be installed as respective
     * Object3D.onBeforeRender of meshes which use animated extusion feature.
     */
    function addRenderHelper(object) {
        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, ExtrusionFeature.onBeforeRender);
    }
    ExtrusionFeature.addRenderHelper = addRenderHelper;
    function onBeforeRender(renderer, scene, camera, geometry, material, group) {
        const extrusionMaterial = material;
        const properties = renderer.properties.get(material);
        if (properties.shader !== undefined &&
            properties.shader.uniforms.extrusionRatio !== undefined) {
            properties.shader.uniforms.extrusionRatio.value =
                extrusionMaterial.extrusionRatio || AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler.DEFAULT_RATIO_MAX;
            extrusionMaterial.uniformsNeedUpdate = true;
        }
    }
    ExtrusionFeature.onBeforeRender = onBeforeRender;
})(ExtrusionFeature = exports.ExtrusionFeature || (exports.ExtrusionFeature = {}));
/**
 * Mixin class for extended THREE materials. Adds new properties required for `extrusionRatio`.
 * Thre is some special handling for the extrusionRatio property, which get some setters and
 * getters in a way that works well with the mixin.
 *
 * @see [[Tile#addRenderHelper]]
 */
class ExtrusionFeatureMixin {
    constructor() {
        this.m_extrusion = AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler.DEFAULT_RATIO_MAX;
    }
    /**
     * @see [[ExtrusionFeature#extrusion]]
     */
    getExtrusionRatio() {
        return this.m_extrusion;
    }
    /**
     * @see [[ExtrusionFeature#extrusion]]
     */
    setExtrusionRatio(value) {
        this.needsUpdate = this.needsUpdate || value !== this.m_extrusion;
        this.m_extrusion = value;
        if (this.needsUpdate) {
            ExtrusionFeature.updateExtrusionFeature(this);
        }
    }
    /**
     * The mixin class should call this method to register the property [[extrusionRatio]]
     */
    addExtrusionProperties() {
        Object.defineProperty(this, "extrusionRatio", {
            get: () => {
                return this.getExtrusionRatio();
            },
            set: val => {
                this.setExtrusionRatio(val);
            }
        });
    }
    /**
     * Apply the extrusionRatio value from the parameters to the respective properties.
     */
    applyExtrusionParameters(params) {
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.extrusionRatio !== undefined) {
                this.setExtrusionRatio(params.extrusionRatio);
            }
        }
        this.onBeforeCompile = (shader) => {
            ExtrusionFeature.onBeforeCompile(this, shader);
        };
    }
    /**
     * Copy extrusionRatio values from other ExtrusionFeature.
     *
     * @param source The material to copy property values from.
     */
    copyExtrusionParameters(source) {
        this.setExtrusionRatio(source.extrusionRatio === undefined
            ? AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler.DEFAULT_RATIO_MAX
            : source.extrusionRatio);
        return this;
    }
}
exports.ExtrusionFeatureMixin = ExtrusionFeatureMixin;
/**
 * Subclass of [[THREE.MeshBasicMaterial]]. Adds new properties required for [[fadeNear]] and
 * [[fadeFar]]. In addition to the new properties (which update their respective uniforms), it is
 * also required to update the material in their objects [[onBeforeRender]] and [[OnAfterRender]]
 * calls, where their flag [[transparent]] is set and the internal fadeNear/fadeFar values are
 * updated to world space distances.
 *
 * @see [[Tile#addRenderHelper]]
 */
class MapMeshBasicMaterial extends THREE.MeshBasicMaterial {
    /**
     * Constructs a new `FadingMeshBasicMaterial`.
     *
     * @param params `FadingMeshBasicMaterial` parameters.
     */
    constructor(params) {
        super(params);
        FadingFeature.patchGlobalShaderChunks();
        this.addFadingProperties();
        this.applyFadingParameters(params);
        ExtrusionFeature.patchGlobalShaderChunks();
        this.addExtrusionProperties();
        this.applyExtrusionParameters(params);
    }
    clone() {
        return new MapMeshBasicMaterial().copy(this);
    }
    copy(source) {
        super.copy(source);
        this.copyFadingParameters(source);
        this.copyExtrusionParameters(source);
        return this;
    }
    // Only here to make the compiler happy, these methods will be overriden: The actual
    // implementations are those in [[FadingFeatureMixin]] and [[ExtrusionFeatureMixin]], see below:
    //
    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);
    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);
    //
    // Mixin declarations start ---------------------------------------------------------
    get fadeNear() {
        return FadingFeature.DEFAULT_FADE_NEAR;
    }
    // tslint:disable-next-line:no-unused-variable
    set fadeNear(value) {
        // to be overridden
    }
    get fadeFar() {
        return FadingFeature.DEFAULT_FADE_FAR;
    }
    // tslint:disable-next-line:no-unused-variable
    set fadeFar(value) {
        // to be overridden
    }
    get extrusionRatio() {
        return AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler.DEFAULT_RATIO_MAX;
    }
    // tslint:disable-next-line:no-unused-variable
    set extrusionRatio(value) {
        // to be overridden
    }
    addFadingProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyFadingParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyFadingParameters(source) {
        // to be overridden
    }
    addExtrusionProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyExtrusionParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyExtrusionParameters(source) {
        // to be overridden
    }
}
exports.MapMeshBasicMaterial = MapMeshBasicMaterial;
/**
 * Subclass of THREE.MeshStandardMaterial. Adds new properties required for `fadeNear` and
 * `fadeFar`. In addition to the new properties (which fill respective uniforms), it is also
 * required to update the material in their objects `onBeforeRender` and `OnAfterRender` calls,
 * where their flag `transparent` is set and the internal fadeNear/fadeFar values are updated to
 * world space distances.
 *
 * @see [[Tile#addRenderHelper]]
 */
class MapMeshStandardMaterial extends THREE.MeshStandardMaterial {
    /**
     * Constructs a new `FadingMeshStandardMaterial`.
     *
     * @param params `FadingMeshStandardMaterial` parameters.
     */
    constructor(params) {
        super(params);
        FadingFeature.patchGlobalShaderChunks();
        this.addFadingProperties();
        this.applyFadingParameters(params);
        ExtrusionFeature.patchGlobalShaderChunks();
        this.addExtrusionProperties();
        this.applyExtrusionParameters(params);
    }
    clone() {
        return new MapMeshStandardMaterial().copy(this);
    }
    copy(source) {
        super.copy(source);
        this.copyFadingParameters(source);
        this.copyExtrusionParameters(source);
        return this;
    }
    // Only here to make the compiler happy, these methods will be overriden: The actual
    // implementations are those in [[FadingFeatureMixin]] and [[ExtrusionFeatureMixin]], see below:
    //
    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);
    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);
    //
    // Mixin declarations start ---------------------------------------------------------
    get fadeNear() {
        return FadingFeature.DEFAULT_FADE_NEAR;
    }
    // tslint:disable-next-line:no-unused-variable
    set fadeNear(value) {
        // to be overridden
    }
    get fadeFar() {
        return FadingFeature.DEFAULT_FADE_FAR;
    }
    // tslint:disable-next-line:no-unused-variable
    set fadeFar(value) {
        // to be overridden
    }
    get extrusionRatio() {
        return AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler.DEFAULT_RATIO_MAX;
    }
    // tslint:disable-next-line:no-unused-variable
    set extrusionRatio(value) {
        // to be overridden
    }
    addFadingProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyFadingParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyFadingParameters(source) {
        // to be overridden
    }
    addExtrusionProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyExtrusionParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyExtrusionParameters(source) {
        // to be overridden
    }
}
exports.MapMeshStandardMaterial = MapMeshStandardMaterial;
/**
 * Finish the classes MapMeshBasicMaterial and MapMeshStandardMaterial by assigning them the actual
 * implementations of the mixed in functions.
 */
harp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [FadingFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshStandardMaterial, [FadingFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [ExtrusionFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshStandardMaterial, [ExtrusionFeatureMixin]);


/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/SepiaShader.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/SepiaShader.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * `SepiaShader`.
 */
exports.SepiaShader = {
    uniforms: {
        tDiffuse: { value: null },
        amount: { value: 1.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }`,
    fragmentShader: `
        uniform float amount;
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 color = texture2D( tDiffuse, vUv );
            vec3 c = color.rgb;
            color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );
            color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );
            color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );
            gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );
        }`
};


/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/ShaderChunks/ExtrusionChunks.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/ShaderChunks/ExtrusionChunks.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    extrusion_pars_vertex: `
attribute vec3 extrusionAxis;
uniform float extrusionRatio;
`,
    extrusion_vertex: `
transformed = transformed - extrusionAxis + extrusionAxis * extrusionRatio;
`,
    extrusion_pars_fragment: `
uniform float extrusionRatio;
`,
    extrusion_fragment: `
gl_FragColor.a *= smoothstep( 0.0, 0.25, extrusionRatio );
`
};


/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/ShaderChunks/FadingChunks.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/ShaderChunks/FadingChunks.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The shader chunks have their lines "#ifdef USE_FADING" commented out, because currently the
 * mesh materials use individually created shader strings based on the materials settings.
 * @see [[FadingMeshBasicMaterial]]
 **/
exports.default = {
    fading_pars_vertex: `
varying float fadingDepth;
`,
    fading_vertex: `
fadingDepth = -mvPosition.z;
`,
    fading_pars_fragment: `
varying float fadingDepth;
uniform float fadeNear;
uniform float fadeFar;
`,
    fading_fragment: `

// lerp with "hard" edges
//float fadingFactor = 1.0 - clamp((fadingDepth - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);

// smooth transitions
float fadingFactor = smoothstep( fadeNear, fadeFar, fadingDepth );

gl_FragColor.a *= 1.0 - fadingFactor;

// debugging color:
// gl_FragColor = vec4(1., fadingFactor, fadingFactor, 1.0);
`
};


/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    extrude_line_vert_func: `
void extrudeLine(vec2 segment, vec4 bt, vec3 t, float lineWidth, inout vec3 pos, inout vec2 uv) {
    float uu = uv.x / 2.0 + 0.5;
    float ss = mix(segment.x, segment.y, uu);

    float angle = bt.w;
    vec3 dir = bt.xyz;
    if (angle != 0.0) {
        pos += uv.y * lineWidth * dir / cos(angle / 2.0);
        uv.x = ss + uv.x * lineWidth * uv.y * tan(angle / 2.0);
    }
    else {
        pos += uv.y * lineWidth * dir + uv.x * lineWidth * t;
        uv.x = ss + uv.x * lineWidth;
    }
}
`,
    join_dist_func: `
float joinDist(vec2 segment, vec2 texcoord) {
    float d = abs(texcoord.y);
    float dx = texcoord.x;
    if (dx < segment.x) {
        d = max(d, length(texcoord - vec2(segment.x, 0.0)));
    } else if (dx > segment.y) {
        d = max(d, length(texcoord - vec2(segment.y, 0.0)));
    }
    return d;
}
`,
    tile_clip_func: `
void tileClip(vec2 tilePos, vec2 tileSize) {
    if (tileSize.x > 0.0 && (tilePos.x < -tileSize.x / 2.0 || tilePos.x > tileSize.x / 2.0))
        discard;
    if (tileSize.y > 0.0 && (tilePos.y < -tileSize.y / 2.0 || tilePos.y > tileSize.y / 2.0))
        discard;
}
`,
    high_precision_vert_func: `
vec3 subtractDblEyePos( const in vec3 pos ) {
    vec3 t1 = positionLow - u_eyepos_lowpart;
    vec3 e = t1 - positionLow;
    vec3 t2 = ((-u_eyepos_lowpart - e) + (positionLow - (t1 - e))) + pos - u_eyepos;
    vec3 high_delta = t1 + t2;
    vec3 low_delta = t2 - (high_delta - t1);
    return (high_delta + low_delta);
}
`
};


/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/SolidLineMaterial.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/SolidLineMaterial.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const MapMeshMaterials_1 = __webpack_require__(/*! ./MapMeshMaterials */ "./node_modules/@here/harp-materials/lib/MapMeshMaterials.js");
const LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ "./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js");
const vertexSource = `
#define SEGMENT_OFFSET 0.1

attribute vec2 texcoord;
attribute vec3 position;
attribute vec4 bitangent;
attribute vec3 tangent;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform float lineWidth;

varying vec2 vTexcoord;
varying vec2 vSegment;
varying float vLinewidth;
varying vec3 vPosition;

#if USE_COLOR
attribute vec3 color;
varying vec3 vColor;
#endif

#ifdef USE_FADING
#include <fading_pars_vertex>
#endif

#include <fog_pars_vertex>

#include <extrude_line_vert_func>

void main() {
    vLinewidth = lineWidth;
    vSegment = abs(texcoord) - SEGMENT_OFFSET;

    vec3 pos = position;
    vec2 uvs = sign(texcoord);

    extrudeLine(vSegment, bitangent, tangent, lineWidth, pos, uvs);

    vPosition = pos;
    vTexcoord = vec2(uvs.x, uvs.y * lineWidth);

    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
    gl_Position = projectionMatrix * mvPosition;

    #if USE_COLOR
    vColor = color;
    #endif

    #ifdef USE_FADING
    #include <fading_vertex>
    #endif

    #include <fog_vertex>
}`;
const fragmentSource = `
precision highp float;
precision highp int;

uniform vec3 diffuse;
uniform float opacity;
uniform vec2 tileSize;
#if DASHED_LINE
uniform float dashSize;
uniform float gapSize;
#endif

varying vec2 vTexcoord;
varying vec2 vSegment;
varying float vLinewidth;
varying vec3 vPosition;

#if USE_COLOR
varying vec3 vColor;
#endif

#include <join_dist_func>
#include <tile_clip_func>

#ifdef USE_FADING
#include <fading_pars_fragment>
#endif

#include <fog_pars_fragment>

void main() {

    float alpha = opacity;

    #if TILE_CLIP
    tileClip(vPosition.xy, tileSize);
    #endif

    float dist = joinDist(vSegment, vTexcoord) - vLinewidth;
    float width = fwidth(dist);
    alpha *= (1.0 - smoothstep(-width, width, dist));

    #if DASHED_LINE
    float halfSegment = (dashSize + gapSize) / dashSize * 0.5;
    float segmentDist = mod(vTexcoord.x, dashSize + gapSize) / dashSize;
    float dashDist = 0.5 - distance(segmentDist, halfSegment);
    float dashWidth = fwidth(dashDist);
    alpha *= smoothstep(-dashWidth, dashWidth, dashDist);
    #endif

    #if USE_COLOR
    gl_FragColor = vec4( diffuse * vColor, alpha );
    #else
    gl_FragColor = vec4( diffuse, alpha );
    #endif

    #include <fog_fragment>

    #ifdef USE_FADING
    #include <fading_fragment>
    #endif
}`;
/**
 * Material designed to render solid variable-width lines.
 */
class SolidLineMaterial extends THREE.RawShaderMaterial {
    /**
     * Constructs a new `SolidLineMaterial`.
     *
     * @param params `SolidLineMaterial` parameters.
     */
    constructor(params) {
        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);
        MapMeshMaterials_1.FadingFeature.patchGlobalShaderChunks();
        const defines = {
            DASHED_LINE: 0,
            TILE_CLIP: 0,
            USE_COLOR: 0
        };
        const hasFog = params !== undefined && params.fog === true;
        if (hasFog) {
            defines.USE_FOG = "";
        }
        const shaderParams = {
            name: "SolidLineMaterial",
            vertexShader: vertexSource,
            fragmentShader: fragmentSource,
            uniforms: THREE.UniformsUtils.merge([
                {
                    diffuse: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),
                    lineWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_WIDTH),
                    opacity: new THREE.Uniform(SolidLineMaterial.DEFAULT_OPACITY),
                    tileSize: new THREE.Uniform(new THREE.Vector2()),
                    fadeNear: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_NEAR),
                    fadeFar: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_FAR)
                },
                // We need the fog uniforms available when we use `updateFog` as the internal
                // recompilation cannot add or remove uniforms.
                THREE.UniformsLib.fog
            ]),
            defines,
            transparent: true,
            fog: true
        };
        super(shaderParams);
        this.extensions.derivatives = true;
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.color !== undefined) {
                this.color.set(params.color);
            }
            if (params.lineWidth !== undefined) {
                this.lineWidth = params.lineWidth;
            }
            if (params.opacity !== undefined) {
                this.opacity = params.opacity;
            }
            if (params.depthTest !== undefined) {
                this.depthTest = params.depthTest;
            }
            if (params.depthWrite !== undefined) {
                this.depthWrite = params.depthWrite;
            }
            if (params.fadeNear !== undefined) {
                this.fadeNear = params.fadeNear;
            }
            if (params.fadeFar !== undefined) {
                this.fadeFar = params.fadeFar;
            }
            this.fog = hasFog;
        }
    }
    /**
     * The method to call to recompile a material to get a new fog define.
     *
     * @param enableFog Whether we want to enable the fog.
     */
    updateFog(enableFog) {
        if (!enableFog) {
            delete this.defines.USE_FOG;
        }
        else {
            this.defines.USE_FOG = "";
        }
    }
    /**
     * Line opacity.
     */
    get opacity() {
        return this.uniforms.opacity.value;
    }
    set opacity(value) {
        if (this.uniforms !== undefined) {
            this.uniforms.opacity.value = value;
        }
    }
    /**
     * Line color.
     */
    get color() {
        return this.uniforms.diffuse.value;
    }
    set color(value) {
        this.uniforms.diffuse.value = value;
    }
    /**
     * Line width.
     */
    get lineWidth() {
        return this.uniforms.lineWidth.value;
    }
    set lineWidth(value) {
        this.uniforms.lineWidth.value = value;
    }
    get fadeNear() {
        return this.uniforms.fadeNear.value;
    }
    set fadeNear(value) {
        this.uniforms.fadeNear.value = value;
    }
    get fadeFar() {
        return this.uniforms.fadeFar.value;
    }
    set fadeFar(value) {
        const fadeFar = this.uniforms.fadeFar.value;
        this.uniforms.fadeFar.value = value;
        const doFade = fadeFar !== undefined && fadeFar > 0.0;
        if (doFade) {
            this.defines.USE_FADING = "";
        }
        else {
            delete this.defines.USE_FADING;
        }
    }
}
SolidLineMaterial.DEFAULT_COLOR = 0xff0000;
SolidLineMaterial.DEFAULT_WIDTH = 1.0;
SolidLineMaterial.DEFAULT_OPACITY = 1.0;
exports.SolidLineMaterial = SolidLineMaterial;


/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/Utils.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/Utils.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Insert shader includes after another shader include.
 *
 * @param shaderContent Original string.
 * @param shaderName String to append to.
 * @param insertedShaderName String to append after string `shaderA`.
 * @param addTab If `true`, a tab character will be inserted before `shaderB`.
 */
function insertShaderInclude(shaderContent, shaderName, insertedShaderName, addTab) {
    const tabChar = addTab === true ? "\t" : "";
    const result = shaderContent.replace(`#include <${shaderName}>`, `#include <${shaderName}>
${tabChar}#include <${insertedShaderName}>`);
    return result;
}
exports.insertShaderInclude = insertShaderInclude;


/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/VignetteShader.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/VignetteShader.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * `VignetteShader`.
 */
exports.VignetteShader = {
    uniforms: {
        tDiffuse: { value: null },
        offset: { value: 1.0 },
        darkness: { value: 1.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }`,
    fragmentShader: `
        uniform float offset;
        uniform float darkness;
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D( tDiffuse, vUv );
            vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );
            gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );
        }`
};


/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/OmvDataFilter */ "./node_modules/@here/harp-omv-datasource/lib/OmvDataFilter.js"));
__export(__webpack_require__(/*! ./lib/OmvDataSource */ "./node_modules/@here/harp-omv-datasource/lib/OmvDataSource.js"));
__export(__webpack_require__(/*! ./lib/OmvDecoderDefs */ "./node_modules/@here/harp-omv-datasource/lib/OmvDecoderDefs.js"));
__export(__webpack_require__(/*! ./lib/OmvTile */ "./node_modules/@here/harp-omv-datasource/lib/OmvTile.js"));
__export(__webpack_require__(/*! ./lib/OmvDebugLabelsTile */ "./node_modules/@here/harp-omv-datasource/lib/OmvDebugLabelsTile.js"));
__export(__webpack_require__(/*! ./lib/OmvRestClient */ "./node_modules/@here/harp-omv-datasource/lib/OmvRestClient.js"));


/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvDataFilter.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvDataFilter.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ "./node_modules/@here/harp-omv-datasource/lib/OmvDecoderDefs.js");
/**
 * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as well
 * as an [[OmvFeatureModifier]].
 *
 */
class OmvFeatureFilterDescriptionBuilder {
    /**
     * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as
     * well as an [[OmvFeatureModifier]].
     *
     * @param processLayersDefault If `true`, all unspecified layers will be processed. If `false`,
     * all unspecified layers will be ignored.
     * @param processPointsDefault If `true`, all unspecified point features will be processed. If
     * `false`, all unspecified point features will be ignored.
     * @param processLinesDefault If `true`, all unspecified line features will be processed. If
     * `false`, all unspecified line features will be ignored.
     * @param processPolygonsDefault If `true`, all unspecified polygon features will be processed.
     * If `false`, all unspecified polygon features will be ignored.
     */
    constructor(options) {
        this.m_processLayersDefault = true;
        this.m_processPointsDefault = true;
        this.m_processLinesDefault = true;
        this.m_processPolygonsDefault = true;
        this.m_layersToProcess = new Array();
        this.m_layersToIgnore = new Array();
        this.m_pointsToProcess = new Array();
        this.m_ignoredPoints = new Array();
        this.m_linesToProcess = new Array();
        this.m_linesToIgnore = new Array();
        this.m_polygonsToProcess = new Array();
        this.m_polygonsToIgnore = new Array();
        if (options) {
            this.m_processLayersDefault =
                options.processLayersDefault !== undefined ? options.processLayersDefault : true;
            this.m_processPointsDefault =
                options.processPointsDefault !== undefined ? options.processPointsDefault : true;
            this.m_processLinesDefault =
                options.processLinesDefault !== undefined ? options.processLinesDefault : true;
            this.m_processPolygonsDefault =
                options.processPolygonsDefault !== undefined
                    ? options.processPolygonsDefault
                    : true;
        }
    }
    /**
     * Add a layer that should be processed.
     *
     * @param layer Layer name to be matched.
     * @param match Match condition.
     */
    processLayer(layer, match = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, minLevel = 0, maxLevel = Infinity) {
        this.m_layersToProcess.push({
            name: { value: layer, match },
            minLevel,
            maxLevel
        });
    }
    /**
     * Add a layer that should be ignored.
     *
     * @param layer Layer name to be matched.
     * @param match Match condition.
     */
    ignoreLayer(layer, match = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, minLevel = 0, maxLevel = Infinity) {
        this.m_layersToIgnore.push({
            name: { value: layer, match },
            minLevel,
            maxLevel
        });
    }
    /**
     * Add a valid point feature.
     *
     * @param options Feature options.
     */
    processPoint(options) {
        this.addItem(this.m_pointsToProcess, options.layer, options.geomType, options.featureClass, options.matchLayer, options.matchClass, options.minLevel, options.maxLevel);
    }
    /**
     * Add valid point features.
     *
     * @param options multi feature options
     */
    processPoints(options) {
        this.addItems(this.m_pointsToProcess, options.layer, options.geomTypes, options.featureClasses, options.matchLayer, options.minLevel, options.maxLevel);
    }
    /**
     * Add a point feature that should be ignored.
     *
     * @param layer Layer name to be matched
     * @param geomType Optional geometry type to be limited to. If specified, but does not match,
     * the feature is ignored.
     * @param featureClass Optional class/classes to match. If specified, but does not match, the
     * feature is ignored.
     * @param matchLayer Match condition for the layer name.
     * @param matchClass Match condition for `featureClass`.
     */
    ignorePoint(layer, geomType, featureClass, matchLayer = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, matchClass = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match) {
        this.addItem(this.m_ignoredPoints, layer, geomType, featureClass, matchLayer, matchClass);
    }
    /**
     * Add point features that should be ignored.
     *
     * @param layer Layer name to be matched
     * @param geomTypes Optional geometry type to be limited to. If specified, but does not match,
     * the feature is ignored.
     * @param featureClasses Optional class/classes to match. If specified, but does not match, the
     * feature is ignored.
     * @param matchLayer Match condition for the layer name.
     * @param matchClass Match condition for `featureClass`.
     */
    ignorePoints(layer, geomTypes, featureClasses, matchLayer = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match) {
        this.addItems(this.m_ignoredPoints, layer, geomTypes, featureClasses, matchLayer);
    }
    /**
     * Add a valid line feature.
     *
     * @param layer Layer name to be matched.
     * @param geomType Optional geometry type to be limited to. If specified, but does not match,
     * the feature is ignored.
     * @param featureClass Optional class/classes to match. If specified, but does not match, the
     * feature is ignored.
     * @param matchLayer Match condition for the layer name.
     * @param matchClass Match condition for `featureClass`.
     */
    processLine(layer, geomType, featureClass, matchLayer = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, matchClass = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match) {
        this.addItem(this.m_linesToProcess, layer, geomType, featureClass, matchLayer, matchClass);
    }
    /**
     * Add valid line features.
     *
     * @param layer Layer name to be matched.
     * @param geomType Optional geometry type to be limited to. If specified, but does not match,
     * the feature is ignored.
     * @param featureClasses Optional class/classes to match. If specified, but does not match, the
     * feature is ignored.
     * @param matchLayer Match condition for the layer name.
     * @param matchClass Match condition for `featureClass`.
     */
    processLines(layer, geomType, featureClasses, matchLayer = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match) {
        this.addItems(this.m_linesToProcess, layer, geomType, featureClasses, matchLayer);
    }
    /**
     * Ignore a line feature.
     *
     * @param layer Layer name to be matched
     * @param geomType Optional geometry type to be limited to. If specified, but does not match,
     * the feature is ignored.
     * @param featureClass Optional class/classes to match. If specified, but does not match, the
     * feature is ignored.
     * @param matchLayer Match condition for the layer name.
     * @param matchClass Match condition for `featureClass`.
     */
    ignoreLine(layer, geomType, featureClass, matchLayer = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, matchClass = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match) {
        this.addItem(this.m_linesToIgnore, layer, geomType, featureClass, matchLayer, matchClass);
    }
    /**
     * Ignore line features.
     *
     * @param layer Layer name to be matched.
     * @param geomType Optional geometry type to be limited to. If specified, but does not match,
     * the feature is ignored.
     * @param featureClasses Optional class/classes to match. If specified, but does not match, the
     * feature is ignored.
     * @param matchLayer Match condition for the layer name.
     * @param matchClass Match condition for `featureClass`.
     */
    ignoreLines(layer, geomType, featureClasses, matchLayer = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match) {
        this.addItems(this.m_linesToIgnore, layer, geomType, featureClasses, matchLayer);
    }
    /**
     * Add a valid polygon feature.
     *
     * @param layer Layer name to be matched.
     * @param geomType Optional geometry type to be limited to. If specified, but does not match,
     * the feature is ignored.
     * @param featureClass Optional class/classes to match. If specified, but does not match, the
     * feature is ignored.
     * @param matchLayer Match condition for the layer name.
     * @param matchClass Match condition for `featureClass`.
     */
    processPolygon(layer, geomType, featureClass, matchLayer = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, matchClass = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match) {
        this.addItem(this.m_polygonsToProcess, layer, geomType, featureClass, matchLayer, matchClass);
    }
    /**
     * Add valid polygon features.
     *
     * @param layer Layer name to be matched.
     * @param geomTypes Optional geometry type to be limited to. If specified, but does not match,
     * the feature is ignored.
     * @param featureClasses Optional class/classes to match. If specified, but does not match, the
     * feature is ignored.
     * @param matchLayer Match condition for the layer name.
     * @param matchClass Match condition for `featureClass`.
     */
    processPolygons(layer, geomType, featureClasses, matchLayer = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match) {
        this.addItems(this.m_polygonsToProcess, layer, geomType, featureClasses, matchLayer);
    }
    /**
     * Ignore a valid polygon feature.
     *
     * @param layer Layer name to be matched
     * @param geomType Optional geometry type to be limited to. If specified, but does not match,
     * the feature is ignored.
     * @param featureClass Optional class/classes to match. If specified, but does not match, the
     * feature is ignored.
     * @param matchLayer Match condition for the layer name.
     * @param matchClass Match condition for `featureClass`.
     */
    ignorePolygon(layer, geomType, featureClass, matchLayer = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, matchClass = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match) {
        this.addItem(this.m_polygonsToIgnore, layer, geomType, featureClass, matchLayer, matchClass);
    }
    /**
     * Ignore polygon features.
     *
     * @param layer Layer name to be matched.
     * @param geomTypes Optional geometry type to be limited to. If specified, but does not match,
     * the feature is ignored.
     * @param featureClasses Optional class/classes to match. If specified, but does not match, the
     * feature is ignored.
     * @param matchLayer Match condition for the layer name.
     * @param matchClass Match condition for `featureClass`.
     */
    ignorePolygons(layer, geomType, featureClasses, matchLayer = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match) {
        this.addItems(this.m_polygonsToIgnore, layer, geomType, featureClasses, matchLayer);
    }
    /**
     * Create a filter description that can be passed as an option to the [[OmvDataSource]].
     */
    createDescription() {
        return {
            processLayersDefault: this.m_processLayersDefault,
            processPointsDefault: this.m_processPointsDefault,
            processLinesDefault: this.m_processLinesDefault,
            processPolygonsDefault: this.m_processPolygonsDefault,
            layersToProcess: this.m_layersToProcess,
            layersToIgnore: this.m_layersToIgnore,
            pointsToProcess: this.m_pointsToProcess,
            pointsToIgnore: this.m_ignoredPoints,
            linesToProcess: this.m_linesToProcess,
            linesToIgnore: this.m_linesToIgnore,
            polygonsToProcess: this.m_polygonsToProcess,
            polygonsToIgnore: this.m_polygonsToIgnore
        };
    }
    addItem(items, layer, geomType, featureClass, matchLayer, matchClass, minLevel, maxLevel) {
        if (minLevel === undefined || isNaN(minLevel)) {
            minLevel = 0;
        }
        if (maxLevel === undefined || isNaN(maxLevel)) {
            maxLevel = Infinity;
        }
        const item = {
            layerName: {
                value: layer,
                match: matchLayer === undefined ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match : matchLayer
            },
            geometryTypes: geomType !== undefined
                ? Array.isArray(geomType)
                    ? geomType
                    : [geomType]
                : undefined,
            classes: [
                {
                    value: featureClass,
                    match: matchClass === undefined ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match : matchClass
                }
            ],
            minLevel,
            maxLevel
        };
        items.push(item);
    }
    addItems(items, layer, geomType, featureClasses, matchLayer, minLevel, maxLevel) {
        if (minLevel === undefined || isNaN(minLevel)) {
            minLevel = 0;
        }
        if (maxLevel === undefined || isNaN(maxLevel)) {
            maxLevel = Infinity;
        }
        const item = {
            layerName: {
                value: layer,
                match: matchLayer === undefined ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match : matchLayer
            },
            geometryTypes: geomType !== undefined
                ? Array.isArray(geomType)
                    ? geomType
                    : [geomType]
                : undefined,
            classes: featureClasses,
            minLevel,
            maxLevel
        };
        items.push(item);
    }
}
exports.OmvFeatureFilterDescriptionBuilder = OmvFeatureFilterDescriptionBuilder;
/**
 * `OmvFeatureFilter` implementation that uses a `OmvFeatureFilterDescription` to filter `TileData`
 * features before they are completely decoded.
 *
 * @hidden
 */
class OmvGenericFeatureFilter {
    constructor(description) {
        this.description = description;
    }
    static matchLayer(layer, layerItems, level) {
        for (const layerItem of layerItems) {
            if (level < layerItem.minLevel || level > layerItem.maxLevel) {
                continue;
            }
            if (OmvDecoderDefs_1.OmvFilterString.matchString(layer, layerItem.name)) {
                return true;
            }
        }
        return false;
    }
    wantsLayer(layer, level) {
        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToProcess, level)) {
            return true;
        }
        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToIgnore, level)) {
            return false;
        }
        return this.description.processLayersDefault;
    }
    wantsPointFeature(layer, geometryType, level) {
        return this.wantsFeature(this.description.pointsToProcess, this.description.pointsToIgnore, layer, geometryType, level, this.description.processPointsDefault);
    }
    wantsLineFeature(layer, geometryType, level) {
        return this.wantsFeature(this.description.linesToProcess, this.description.linesToIgnore, layer, geometryType, level, this.description.processLinesDefault);
    }
    wantsPolygonFeature(layer, geometryType, level) {
        return this.wantsFeature(this.description.polygonsToProcess, this.description.polygonsToIgnore, layer, geometryType, level, this.description.processPolygonsDefault);
    }
    wantsFeature(itemsToProcess, itemsToIgnore, layer, geometryType, level, defaultResult) {
        for (const item of itemsToProcess) {
            if (level < item.minLevel || level > item.maxLevel) {
                continue;
            }
            if (!OmvDecoderDefs_1.OmvFilterString.matchString(layer, item.layerName)) {
                // this rule is not for this layer
                continue;
            }
            if (item.geometryTypes !== undefined && item.geometryTypes.indexOf(geometryType) >= 0) {
                return true;
            }
        }
        for (const item of itemsToIgnore) {
            if (!OmvDecoderDefs_1.OmvFilterString.matchString(layer, item.layerName)) {
                // this rule is not for this layer
                continue;
            }
            if (item.geometryTypes !== undefined && item.geometryTypes.indexOf(geometryType) >= 0) {
                return false;
            }
        }
        return defaultResult;
    }
}
exports.OmvGenericFeatureFilter = OmvGenericFeatureFilter;
/**
 * `OmvFeatureModifier` implementation that uses a `OmvFeatureFilterDescription` to filter
 * `TileData` features before they are completely decoded.
 *
 * @hidden
 */
class OmvGenericFeatureModifier {
    constructor(description) {
        this.description = description;
    }
    static matchItems(layerName, featureClass, items) {
        for (const item of items) {
            if (!OmvDecoderDefs_1.OmvFilterString.matchString(layerName, item.layerName)) {
                continue;
            }
            const matchClasses = item.classes;
            if (featureClass !== undefined && matchClasses !== undefined) {
                for (const matchClass of matchClasses) {
                    if (OmvDecoderDefs_1.OmvFilterString.matchString(featureClass, matchClass)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    doProcessPointFeature(layer, env) {
        return this.doProcessFeature(this.description.pointsToProcess, this.description.pointsToIgnore, layer, env, this.description.processPointsDefault);
    }
    doProcessLineFeature(layer, env) {
        return this.doProcessFeature(this.description.linesToProcess, this.description.linesToIgnore, layer, env, this.description.processLinesDefault);
    }
    doProcessPolygonFeature(layer, env) {
        return this.doProcessFeature(this.description.polygonsToProcess, this.description.polygonsToIgnore, layer, env, this.description.processPolygonsDefault);
    }
    doProcessFeature(itemsToProcess, itemsToIgnore, layer, env, defaultResult) {
        if (layer === undefined || layer === undefined) {
            return defaultResult;
        }
        let featureClass;
        const featureClassThing = env.lookup("class");
        if (featureClassThing !== undefined) {
            featureClass = featureClassThing.toString();
        }
        if (featureClass &&
            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToProcess)) {
            return true;
        }
        if (featureClass &&
            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToIgnore)) {
            return false;
        }
        return defaultResult;
    }
}
exports.OmvGenericFeatureModifier = OmvGenericFeatureModifier;


/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvDataSource.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvDataSource.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_mapview_decoder_1 = __webpack_require__(/*! @here/harp-mapview-decoder */ "./node_modules/@here/harp-mapview-decoder/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ "./node_modules/@here/harp-omv-datasource/lib/OmvDecoderDefs.js");
const OmvRestClient_1 = __webpack_require__(/*! ./OmvRestClient */ "./node_modules/@here/harp-omv-datasource/lib/OmvRestClient.js");
const OmvTile_1 = __webpack_require__(/*! ./OmvTile */ "./node_modules/@here/harp-omv-datasource/lib/OmvTile.js");
/**
 * A helper function to retrieve the [[DataProvider]] from the [[OmvDataSource]]s parameters.
 *
 * @param params The parameters passed into the OmvDataSource.
 */
function getDataProvider(params) {
    if (params.dataProvider) {
        return params.dataProvider;
    }
    else if (params.baseUrl) {
        return new OmvRestClient_1.OmvRestClient(params);
    }
    else {
        throw new Error("OmvDataSource: missing baseUrl or dataProvider params");
    }
}
class OmvDataSource extends harp_mapview_decoder_1.TileDataSource {
    constructor(m_params) {
        super(m_params.tileFactory || new harp_mapview_decoder_1.TileFactory(OmvTile_1.OmvTile), {
            styleSetName: m_params.styleSetName || "omv",
            name: m_params.name,
            tilingScheme: harp_geoutils_1.webMercatorTilingScheme,
            dataProvider: getDataProvider(m_params),
            concurrentDecoderServiceName: OmvDecoderDefs_1.OMV_TILE_DECODER_SERVICE_TYPE,
            decoder: m_params.decoder,
            concurrentDecoderScriptUrl: m_params.concurrentDecoderScriptUrl,
            copyrightInfo: m_params.copyrightInfo,
            minZoomLevel: harp_utils_1.getOptionValue(m_params.minZoomLevel, 1),
            maxZoomLevel: harp_utils_1.getOptionValue(m_params.maxZoomLevel, 14),
            storageLevelOffset: harp_utils_1.getOptionValue(m_params.storageLevelOffset, -1)
        });
        this.m_params = m_params;
        this.cacheable = true;
        this.m_decoderOptions = {
            showMissingTechniques: this.m_params.showMissingTechniques === true,
            filterDescription: this.m_params.filterDescr,
            gatherFeatureIds: this.m_params.gatherFeatureIds === true,
            createTileInfo: this.m_params.createTileInfo === true,
            gatherRoadSegments: this.m_params.gatherRoadSegments === true,
            featureModifierId: this.m_params.featureModifierId,
            skipShortLabels: this.m_params.skipShortLabels,
            storageLevelOffset: harp_utils_1.getOptionValue(m_params.storageLevelOffset, -1)
        };
        this.tileBackgroundIsVisible = true;
    }
    /**
     * Set a theme for the data source instance.
     * @param styleSet The [[Theme]] to be added.
     */
    setStyleSet(styleSet, languages) {
        if (styleSet === undefined) {
            return;
        }
        this.m_tileLoaderCache.clear();
        this.decoder.configure(styleSet, languages, this.m_decoderOptions);
        this.mapView.markTilesDirty(this);
    }
    /**
     * Remove the current data filter.
     * Will be applied to the decoder, which might be shared with other omv datasources.
     */
    removeDataFilter() {
        this.decoder.configure(undefined, undefined, {
            filterDescription: null
        });
        this.mapView.markTilesDirty(this);
    }
    /**
     * Set a new data filter. Can also be done during the creation of an [[OmvDataSource]].
     * Will be applied to the decoder, which might be shared with other omv datasources.
     *
     * @param filterDescription Data filter description created with
     * [[OmvFeatureFilterDescriptionBuilder]].
     */
    setDataFilter(filterDescription) {
        this.m_decoderOptions.filterDescription =
            filterDescription !== null ? filterDescription : undefined;
        this.decoder.configure(undefined, undefined, {
            filterDescription
        });
        this.mapView.markTilesDirty(this);
    }
    shouldPreloadTiles() {
        return true;
    }
    /**
     * Check if a data source should be rendered or not depending on the zoom level.
     *
     * @param zoomLevel Zoom level.
     * @param tileKey Level of the tile.
     * @returns `true` if the data source should be rendered.
     */
    shouldRender(zoomLevel, tileKey) {
        if (tileKey.level > this.maxZoomLevel) {
            return false;
        }
        if (tileKey.level === this.maxZoomLevel && zoomLevel >= this.maxZoomLevel) {
            return true;
        }
        return super.shouldRender(zoomLevel, tileKey);
    }
    setLanguages(languages) {
        if (languages !== undefined) {
            this.m_decoder.configure(undefined, languages, undefined);
            this.mapView.markTilesDirty(this);
        }
    }
    get storageLevelOffset() {
        return super.storageLevelOffset;
    }
    set storageLevelOffset(levelOffset) {
        super.storageLevelOffset = levelOffset;
        this.m_decoderOptions.storageLevelOffset = this.storageLevelOffset;
        this.m_decoder.configure(undefined, undefined, {
            storageLevelOffset: this.storageLevelOffset
        });
    }
}
exports.OmvDataSource = OmvDataSource;


/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvDebugLabelsTile.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvDebugLabelsTile.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "./node_modules/@here/harp-mapview/index.js");
const DebugContext_1 = __webpack_require__(/*! @here/harp-mapview/lib/DebugContext */ "./node_modules/@here/harp-mapview/lib/DebugContext.js");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "./node_modules/@here/harp-text-canvas/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const TileGeometryCreator_1 = __webpack_require__(/*! ../../harp-mapview/lib/geometry/TileGeometryCreator */ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js");
const OmvTile_1 = __webpack_require__(/*! ./OmvTile */ "./node_modules/@here/harp-omv-datasource/lib/OmvTile.js");
const debugMaterial = new THREE.LineBasicMaterial({
    color: 0x000000,
    linewidth: 2,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
const debugCircleMaterial = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
const debugCircleMaterialWF = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
debugCircleMaterialWF.wireframe = true;
const debugCircleMaterial2WF = new THREE.MeshBasicMaterial({
    color: 0x8080ff,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
debugCircleMaterial2WF.wireframe = true;
const debugBlackCircleMaterial = new THREE.MeshBasicMaterial({
    color: 0x000000,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
const textRenderStyle = new harp_text_canvas_1.TextRenderStyle();
const textLayoutStyle = new harp_text_canvas_1.TextLayoutStyle();
class OmvDebugLabelsTile extends OmvTile_1.OmvTile {
    constructor(dataSource, tileKey) {
        super(dataSource, tileKey);
    }
    /**
     * Create [[TextElement]] objects from the given decoded [[Tile]] and list of materials.
     *
     * @param decodedTile The decoded tile.
     */
    createTextElements(decodedTile) {
        const geometryCreator = new TileGeometryCreator_1.TileGeometryCreator();
        geometryCreator.createTextElements(this, decodedTile);
        const colorMap = new Map();
        // activate in the browser with:
        // window.__debugContext.setValue("DEBUG_TEXT_PATHS", true)
        const debugTextPaths = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS");
        // allow limiting to specific names and/or index. There can be many paths with the same text
        const textFilter = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS.FILTER.TEXT");
        const indexFilter = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS.FILTER.INDEX");
        const zoomLevel = this.mapView.zoomLevel;
        if (this.preparedTextPaths !== undefined) {
            const tooManyPaths = this.preparedTextPaths.length > 500;
            for (const textPath of this.preparedTextPaths) {
                const technique = decodedTile.techniques[textPath.technique];
                if (!harp_datasource_protocol_1.isTextTechnique(technique)) {
                    continue;
                }
                if (technique.color !== undefined) {
                    colorMap.set(textPath.technique, new THREE.Color(harp_datasource_protocol_1.getPropertyValue(technique.color, zoomLevel)));
                }
                const text = textPath.text;
                if (debugTextPaths) {
                    const elementIndex = this.preparedTextPaths.indexOf(textPath);
                    const createDebugInfo = (!textFilter || (text && text.indexOf(textFilter) >= 0)) &&
                        (indexFilter === undefined || indexFilter === elementIndex);
                    if (createDebugInfo) {
                        const positions = new Array();
                        const indices = new Array();
                        const geometry = new THREE.BufferGeometry();
                        const baseVertex = positions.length / 3;
                        for (let i = 0; i < textPath.path.length; i += 2) {
                            const pointIndex = i / 2;
                            const x = textPath.path[i];
                            const y = textPath.path[i + 1];
                            const z = i / 3; // raise it a bit, so we get identify connectivity
                            // visually by tilting
                            positions.push(x, y, z);
                            if (!tooManyPaths) {
                                // give path point a simple geometry: a diamond
                                const circleGeometry = new THREE.CircleGeometry(2, 4);
                                circleGeometry.translate(x, y, z);
                                const cmesh = new THREE.Mesh(circleGeometry, i > 0 ? debugCircleMaterial : debugBlackCircleMaterial);
                                cmesh.renderOrder = 3000 - i;
                                this.objects.push(cmesh);
                                // give point index a label
                                const label = pointIndex % 5 === 0
                                    ? text + ":" + pointIndex
                                    : Number(pointIndex).toString();
                                const labelElement = new harp_mapview_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), new THREE.Vector3(x, y, z), textRenderStyle, textLayoutStyle, harp_datasource_protocol_1.getPropertyValue(technique.priority || 0, zoomLevel), technique.xOffset || 0.0, technique.yOffset || 0.0);
                                labelElement.minZoomLevel = technique.minZoomLevel;
                                labelElement.mayOverlap = true;
                                labelElement.reserveSpace = false;
                                labelElement.alwaysOnTop = true;
                                labelElement.ignoreDistance = true;
                                this.addUserTextElement(labelElement);
                            }
                        }
                        if (tooManyPaths) {
                            if (textPath.path.length > 0) {
                                const x = textPath.path[0];
                                const y = textPath.path[0 + 1];
                                const z = 0;
                                // give path point a simple geometry: a diamond
                                const circleGeometry = new THREE.CircleGeometry(2, 4);
                                circleGeometry.scale(5, 5, 5);
                                circleGeometry.translate(x, y, z);
                                const cmesh = new THREE.Mesh(circleGeometry, debugCircleMaterialWF);
                                cmesh.renderOrder = 3000;
                                this.objects.push(cmesh);
                            }
                            if (textPath.path.length > 1) {
                                const i = textPath.path.length - 2;
                                const x = textPath.path[i];
                                const y = textPath.path[i + 1];
                                const z = 0;
                                // give path point a simple geometry: a diamond
                                const circleGeometry = new THREE.CircleGeometry(2, 4);
                                circleGeometry.scale(3, 3, 3);
                                circleGeometry.translate(x, y, z);
                                const cmesh = new THREE.Mesh(circleGeometry, debugCircleMaterial2WF);
                                cmesh.renderOrder = 3000;
                                this.objects.push(cmesh);
                            }
                        }
                        // the lines of a path share a common geometry
                        const N = textPath.path.length / 2;
                        for (let i = 0; i < N; ++i) {
                            if (i > 0) {
                                indices.push(baseVertex + i);
                            }
                            if (i + 1 < N) {
                                indices.push(baseVertex + i);
                            }
                        }
                        geometry.addGroup(0, indices.length, 0);
                        geometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(positions), 3));
                        geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
                        const mesh = new THREE.LineSegments(geometry, debugMaterial);
                        mesh.renderOrder = 2000;
                        this.objects.push(mesh);
                    }
                }
            }
        }
    }
}
exports.OmvDebugLabelsTile = OmvDebugLabelsTile;


/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvDecoderDefs.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvDecoderDefs.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Feature Modifier ids to choose which OmvFeatureModifer should be used in OmvDecoder.
 */
var FeatureModifierId;
(function (FeatureModifierId) {
    /**
     * Identifier to use the OmvTomTomFeatureModifier in the OmvDecoder.
     */
    FeatureModifierId[FeatureModifierId["tomTom"] = 0] = "tomTom";
})(FeatureModifierId = exports.FeatureModifierId || (exports.FeatureModifierId = {}));
/**
 * Adding the match condition type and the matching function to the namespace of `OmvFilterString`.
 */
var OmvFilterString;
(function (OmvFilterString) {
    /**
     * Match condition.
     */
    let StringMatch;
    (function (StringMatch) {
        /** Matches any. */
        StringMatch[StringMatch["Any"] = 0] = "Any";
        /** Exact match. */
        StringMatch[StringMatch["Match"] = 1] = "Match";
        /** Matches if a test string starts with a filter string. */
        StringMatch[StringMatch["StartsWith"] = 2] = "StartsWith";
        /** Matches if a test string contains a filter string. */
        StringMatch[StringMatch["Contains"] = 3] = "Contains";
        /** Matches if a test string ends with a filter string. */
        StringMatch[StringMatch["EndsWith"] = 4] = "EndsWith";
    })(StringMatch = OmvFilterString.StringMatch || (OmvFilterString.StringMatch = {}));
    /**
     * Check for a string against a filter.
     *
     * @param str The string to check against a filter.
     * @param filterString The filter containing the match condition.
     * @returns `true` if the match condition is satisfied.
     */
    function matchString(str, filterString) {
        switch (filterString.match) {
            case OmvFilterString.StringMatch.Any:
                return true;
            case OmvFilterString.StringMatch.Match:
                return str === filterString.value;
            case OmvFilterString.StringMatch.StartsWith:
                return filterString.value.startsWith(str);
            case OmvFilterString.StringMatch.EndsWith:
                return filterString.value.endsWith(str);
            default:
                return str.indexOf(filterString.value) >= 0;
        }
    }
    OmvFilterString.matchString = matchString;
})(OmvFilterString = exports.OmvFilterString || (exports.OmvFilterString = {}));
var OmvGeometryType;
(function (OmvGeometryType) {
    OmvGeometryType[OmvGeometryType["UNKNOWN"] = 0] = "UNKNOWN";
    OmvGeometryType[OmvGeometryType["POINT"] = 1] = "POINT";
    OmvGeometryType[OmvGeometryType["LINESTRING"] = 2] = "LINESTRING";
    OmvGeometryType[OmvGeometryType["POLYGON"] = 3] = "POLYGON";
})(OmvGeometryType = exports.OmvGeometryType || (exports.OmvGeometryType = {}));
/**
 * Default OMV tile decoder service type.
 *
 * Used for requesting decoder services using [[WorkerServiceManager]].
 */
exports.OMV_TILE_DECODER_SERVICE_TYPE = "omv-tile-decoder";
/**
 * Default OMV tiler service type.
 *
 * Used for requesting tiler services using [[WorkerServiceManager]].
 */
exports.OMV_TILER_SERVICE_TYPE = "omv-tiler";


/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvRestClient.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvRestClient.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(/*! @here/harp-fetch */ "./node_modules/@here/harp-fetch/index.web.js");
const harp_transfer_manager_1 = __webpack_require__(/*! @here/harp-transfer-manager */ "./node_modules/@here/harp-transfer-manager/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.js");
const logger = harp_utils_1.LoggerManager.instance.create("OmvRestClient");
// tslint:disable:max-line-length
var APIFormat;
(function (APIFormat) {
    /**
     * Use the REST API format of HERE Vector Tiles Server component version 1.
     *
     * Usage:
     *
     *     <OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>/omv
     *
     * If [[OmvRestClientParams.authenticationToken]] is provided, it will be added as HTTP header:
     *
     *     Authorization: Bearer $authenticationToken
     *
     * Format definition:
     * `//http|s://<base-url>/{API version}/{layers}/{projection}/{z}/{x}/{y}/{format}`
     *
     * Default authentication method used: [[AuthenticationTypeBearer]].
     */
    APIFormat[APIFormat["HereV1"] = 0] = "HereV1";
    /**
     * Use the REST API format of Mapbox Vector Tile API v4.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/v4/{map_id}/{z}/{x}/{y}{@2x}.{format}?[style]&access_token={access_token}`
     *
     * Sample URL:
     * `http://a.tiles.mapbox.com/v4/mapbox.mapbox-streets-v7/14/4823/6160.mvt?access_token=your-mapbox-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["MapboxV4"] = 1] = "MapboxV4";
    /**
     * Use the REST API format of XYZ Vector Tile API in MVT format.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.mvt?access_token=your-xyz-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZMVT"] = 2] = "XYZMVT";
    /**
     * Use the REST API format of XYZ Vector Tile API in JSON format.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.json?access_token=your-xyz-api-key`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZJson"] = 3] = "XYZJson";
    /**
     * Use the REST API format of XYZ Vector Tile API in OMV format.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/tiles/herebase.02/<zoom>/<X>/<Y>/omv?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/tiles/herebase.02/{z}/{x}/{y}/{format}?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/tiles/herebase.02/14/2649/6338/omv?access_token=your-xyz-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZOMV"] = 4] = "XYZOMV";
    /**
     * Use the REST API format of Tomtoms Vector Tile API v1.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.pbf?key=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `<http|https>://<baseURL>/map/<versionNumber>/tile/<layer>/<style>/<zoom>/<X>/<Y>.<format>?key=<apiKey>[&view=<view>][&language=<language>]`
     *
     * Sample URL:
     * `http://api.tomtom.com/map/1/tile/basic/main/0/0/0.pbf?key=<apiKey>`
     *
     * Default authentication method used: [[AuthenticationTypeTomTomV1]].
     */
    APIFormat[APIFormat["TomtomV1"] = 5] = "TomtomV1";
    /**
     * Use the REST API format of XYZ Space Vector Tile API in OMV format.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/hub/spaces/<space-id>/tile/web/<zoom>_<X>_<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/hub/spaces/{spaceId}/tile/web/{z}_{x}_{y}.mvt?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/hub/spaces/your-space-id/tile/web/{z}_{x}_{y}.mvt?access_token=your-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZSpace"] = 6] = "XYZSpace";
})(APIFormat = exports.APIFormat || (exports.APIFormat = {}));
var AuthenticationMethod;
(function (AuthenticationMethod) {
    AuthenticationMethod[AuthenticationMethod["QueryString"] = 0] = "QueryString";
    AuthenticationMethod[AuthenticationMethod["AuthorizationHeader"] = 1] = "AuthorizationHeader";
})(AuthenticationMethod = exports.AuthenticationMethod || (exports.AuthenticationMethod = {}));
/**
 * Authentication method, where token will be provided as HTTP Header:
 *
 *    Authorization: Bearer $authenticationToken
 */
exports.AuthenticationTypeBearer = {
    method: AuthenticationMethod.AuthorizationHeader,
    name: "Bearer"
};
/**
 * TomTomV1 API compatible authorization method, where token will be provided as HTTP Header:
 *
 *    Authorization: Bearer $authenticationToken
 */
exports.AuthenticationTypeTomTomV1 = {
    method: AuthenticationMethod.QueryString,
    name: "key"
};
exports.AuthenticationTypeAccessToken = {
    method: AuthenticationMethod.QueryString,
    name: "access_token"
};
/**
 * REST client supporting getting protobuf OMV Tile from REST-based servers.
 */
class OmvRestClient {
    constructor(params) {
        this.params = params;
        this.downloadManager =
            params.downloadManager === undefined
                ? harp_transfer_manager_1.TransferManager.instance()
                : params.downloadManager;
    }
    /** Overriding abstract method, in this case doing nothing. */
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            // not needed
        });
    }
    /** Overriding abstract method, in this case always returning `true`. */
    ready() {
        return true;
    }
    /**
     * Asynchronously fetches a tile from this restful server.
     *
     * **Note:** If the tile doesn't exist, a successful response with a `404` status code is
     * returned.
     *
     * @example
     * ```typescript
     * const response = layer.getTile(tileKey);
     * if (!response.ok) {
     *     // a network error happened
     *     console.error("Unable to download tile", response.statusText);
     *     return;
     * }
     * if (response.status === 404) {
     *     // 404 -, no data exists at the given tile. Do nothing.
     *     return;
     * }
     *
     * // the response is ok and contains data, access it e.g. as arrayBuffer:
     * const payload = await response.arrayBuffer();
     * ```
     *
     * @param tileKey The tile key of the tile.
     * @param tileRequestInit Optional request options to be passed to fetch when downloading a
     * tile.
     * @returns A `Promise` of the HTTP response that contains the payload of the requested tile.
     */
    getTile(tileKey, abortSignal) {
        return __awaiter(this, void 0, void 0, function* () {
            const init = { signal: abortSignal };
            let tileUrl = this.dataUrl(tileKey);
            const authenticationCode = yield this.getActualAuthenticationCode();
            tileUrl = this.applyAuthCode(tileUrl, init, authenticationCode);
            if (this.params.apiFormat === APIFormat.XYZJson) {
                return this.downloadManager.downloadJson(tileUrl, init);
            }
            return this.downloadManager.downloadArrayBuffer(tileUrl, init);
        });
    }
    /**
     * Get actual authentication code/token for this request according to configuration.
     */
    getActualAuthenticationCode() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.params.authenticationCode === "string") {
                return this.params.authenticationCode;
            }
            else if (this.params.authenticationCode !== undefined) {
                return this.params.authenticationCode();
            }
            else if (this.params.getBearerToken !== undefined) {
                return this.params.getBearerToken();
            }
            else {
                return undefined;
            }
        });
    }
    /**
     * Get default authnentication method basing on apiFormat and other params.
     */
    getDefaultAuthMethod() {
        if (this.params.getBearerToken !== undefined) {
            return exports.AuthenticationTypeBearer;
        }
        switch (this.params.apiFormat) {
            case APIFormat.HereV1:
                return exports.AuthenticationTypeBearer;
            case APIFormat.MapboxV4:
            case APIFormat.XYZOMV:
            case APIFormat.XYZMVT:
            case APIFormat.XYZSpace:
            case APIFormat.XYZJson:
                return exports.AuthenticationTypeAccessToken;
            case APIFormat.TomtomV1:
                return exports.AuthenticationTypeTomTomV1;
            default:
                logger.warn(`#getDefaultAuthMethod: Not supported API format: ${this.params.apiFormat}`);
                return undefined;
        }
    }
    /**
     * Apply athentication code/token using configured (or default) authentication method.
     *
     * @param url
     * @param init request extra data
     * @param authenticationCode authentication/token to be applied
     * @return new url to be used
     */
    applyAuthCode(url, init, authenticationCode) {
        if (authenticationCode === undefined) {
            return url;
        }
        const authMethod = this.params.authenticationMethod || this.getDefaultAuthMethod();
        if (authMethod === undefined) {
            return url;
        }
        if (authMethod.method === AuthenticationMethod.AuthorizationHeader) {
            if (init.headers === undefined) {
                init.headers = new Headers();
            }
            const authType = authMethod.name || "Bearer";
            init.headers.append("Authorization", `${authType} ${authenticationCode}`);
        }
        else if (authMethod.method === AuthenticationMethod.QueryString) {
            const attrName = authMethod.name || "access_token";
            url = this.addQueryParams(url, [[attrName, authenticationCode]]);
        }
        return url;
    }
    /**
     * Get actual tile URL depending on configured API format.
     */
    dataUrl(tileKey) {
        let path = [`/${tileKey.level}`, tileKey.column, tileKey.row].join(this.params.apiFormat === APIFormat.XYZSpace ? "_" : "/");
        switch (this.params.apiFormat) {
            case APIFormat.HereV1:
            case APIFormat.XYZOMV:
                path += "/omv";
                break;
            case APIFormat.MapboxV4:
                path += ".mvt";
                break;
            case APIFormat.XYZMVT:
                path += ".mvt";
                break;
            case APIFormat.XYZJson:
                path += ".json";
                break;
            case APIFormat.XYZSpace:
                path += ".mvt";
                break;
            case APIFormat.TomtomV1:
                path += ".pbf";
                break;
            default:
                logger.warn(`Not supported API format: ${this.params.apiFormat}`);
                break;
        }
        return this.params.baseUrl + path;
    }
    addQueryParams(url, queryParams) {
        let queryString = "";
        let concatinator = url.indexOf("?") !== -1 ? "&" : "?";
        for (const param of queryParams) {
            queryString += concatinator + param[0] + "=" + param[1];
            if (concatinator === "?") {
                concatinator = "&";
            }
        }
        return url + queryString;
    }
}
exports.OmvRestClient = OmvRestClient;


/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvTile.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvTile.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "./node_modules/@here/harp-mapview/index.js");
class OmvTile extends harp_mapview_1.Tile {
    constructor(dataSource, tileKey) {
        super(dataSource, tileKey);
    }
}
exports.OmvTile = OmvTile;


/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/rendering/FontCatalog */ "./node_modules/@here/harp-text-canvas/lib/rendering/FontCatalog.js"));
__export(__webpack_require__(/*! ./lib/rendering/GlyphData */ "./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js"));
__export(__webpack_require__(/*! ./lib/rendering/TextStyle */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js"));
__export(__webpack_require__(/*! ./lib/rendering/TextBufferObject */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js"));
__export(__webpack_require__(/*! ./lib/TextCanvas */ "./node_modules/@here/harp-text-canvas/lib/TextCanvas.js"));
__export(__webpack_require__(/*! ./lib/utils/ContextualArabicConverter */ "./node_modules/@here/harp-text-canvas/lib/utils/ContextualArabicConverter.js"));
__export(__webpack_require__(/*! ./lib/utils/MaterialUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js"));
__export(__webpack_require__(/*! ./lib/utils/TypesettingUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js"));
__export(__webpack_require__(/*! ./lib/utils/UnicodeUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js"));


/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/TextCanvas.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/TextCanvas.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const TextBufferObject_1 = __webpack_require__(/*! ./rendering/TextBufferObject */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js");
const TextGeometry_1 = __webpack_require__(/*! ./rendering/TextGeometry */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js");
const TextStyle_1 = __webpack_require__(/*! ./rendering/TextStyle */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js");
const LineTypesetter_1 = __webpack_require__(/*! ./typesetting/LineTypesetter */ "./node_modules/@here/harp-text-canvas/lib/typesetting/LineTypesetter.js");
const PathTypesetter_1 = __webpack_require__(/*! ./typesetting/PathTypesetter */ "./node_modules/@here/harp-text-canvas/lib/typesetting/PathTypesetter.js");
const MaterialUtils_1 = __webpack_require__(/*! ./utils/MaterialUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js");
const tempTextPosition = new THREE.Vector3();
const tempTextBounds = {
    array: [new THREE.Box2()],
    offset: 0
};
let tempVertexBuffer = new Float32Array();
/**
 * Default's [[TextCanvas]] layer identifier.
 */
exports.DEFAULT_TEXT_CANVAS_LAYER = 0;
/**
 * three.js text rendering engine which can manage and render high-quality, transformable, stylable
 * and properly layout SDF and MSDF text.
 */
class TextCanvas {
    /**
     * Constructs a new `TextCanvas`.
     *
     * @param params `TextCanvas` construction parameters.
     *
     * @returns New `TextCanvas`.
     */
    constructor(params) {
        this.m_renderer = params.renderer;
        this.m_fontCatalog = params.fontCatalog;
        this.minGlyphCount = params.minGlyphCount;
        this.maxGlyphCount = params.maxGlyphCount;
        if (params.material === undefined) {
            this.m_ownsMaterial = true;
            this.m_material = MaterialUtils_1.createSdfTextMaterial({ fontCatalog: params.fontCatalog });
        }
        else {
            this.m_ownsMaterial = false;
            this.m_material = params.material;
        }
        if (params.backgroundMaterial === undefined) {
            this.m_ownsBgMaterial = true;
            this.m_bgMaterial = MaterialUtils_1.createSdfTextMaterial({
                fontCatalog: params.fontCatalog,
                isBackground: true
            });
        }
        else {
            this.m_ownsBgMaterial = false;
            this.m_bgMaterial = params.backgroundMaterial;
        }
        this.m_defaultLayer = {
            id: exports.DEFAULT_TEXT_CANVAS_LAYER,
            storage: new TextGeometry_1.TextGeometry(new THREE.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)
        };
        this.m_layers = [this.m_defaultLayer];
        this.m_defaultTextRenderStyle = new TextStyle_1.TextRenderStyle();
        this.m_currentTextRenderStyle = this.m_defaultTextRenderStyle;
        this.m_defaultTextLayoutStyle = new TextStyle_1.TextLayoutStyle();
        this.m_currentTextLayoutStyle = this.m_defaultTextLayoutStyle;
        this.m_lineTypesetter = new LineTypesetter_1.LineTypesetter();
        this.m_pathTypesetter = new PathTypesetter_1.PathTypesetter();
    }
    /**
     * Currently active [[FontCatalog]].
     */
    get fontCatalog() {
        return this.m_fontCatalog;
    }
    set fontCatalog(value) {
        this.m_fontCatalog = value;
        const material = this.m_material;
        material.uniforms.sdfTexture.value = this.m_fontCatalog.texture;
        material.uniforms.sdfParams.value = new THREE.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);
        material.defines.MSDF = this.m_fontCatalog.type === "msdf" ? 1.0 : 0.0;
        const bgMaterial = this.m_bgMaterial;
        bgMaterial.uniforms.sdfTexture.value = this.m_fontCatalog.texture;
        bgMaterial.uniforms.sdfParams.value = new THREE.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);
        bgMaterial.defines.MSDF = this.m_fontCatalog.type === "msdf" ? 1.0 : 0.0;
    }
    /**
     * Currently active text rendering material.
     */
    get material() {
        return this.m_material;
    }
    set material(value) {
        if (this.m_ownsMaterial) {
            this.m_material.dispose();
            this.m_ownsMaterial = false;
        }
        this.m_material = value;
        for (const layer of this.m_layers) {
            layer.storage.mesh.material = this.m_material;
        }
    }
    /**
     * Currently active text background rendering material.
     */
    get backgroundMaterial() {
        return this.m_bgMaterial;
    }
    set backgroundMaterial(value) {
        if (this.m_ownsBgMaterial) {
            this.m_bgMaterial.dispose();
            this.m_ownsBgMaterial = false;
        }
        this.m_bgMaterial = value;
        for (const layer of this.m_layers) {
            layer.storage.backgroundMesh.material = this.m_bgMaterial;
        }
    }
    /**
     * Currently active text rendering style.
     */
    get textRenderStyle() {
        return this.m_currentTextRenderStyle;
    }
    set textRenderStyle(style) {
        this.m_currentTextRenderStyle = style;
    }
    /**
     * Currently active text layout style.
     */
    get textLayoutStyle() {
        return this.m_currentTextLayoutStyle;
    }
    set textLayoutStyle(style) {
        this.m_currentTextLayoutStyle = style;
    }
    /**
     * Clears all the placed glyphs in this `TextCanvas` (as well as resetting the current style).
     */
    clear() {
        for (const layer of this.m_layers) {
            layer.storage.clear();
        }
        this.m_currentTextRenderStyle = this.m_defaultTextRenderStyle;
    }
    /**
     * Renders the content of this `TextCanvas`.
     *
     * @param camera Orthographic camera.
     * @param target Optional render target.
     * @param clear Optional render target clear operation.
     */
    render(camera, target, clear) {
        this.m_fontCatalog.update(this.m_renderer);
        let oldTarget = null;
        if (target !== undefined) {
            oldTarget = this.m_renderer.getRenderTarget();
            this.m_renderer.setRenderTarget(target);
        }
        if (clear === true) {
            this.m_renderer.clear(true);
        }
        for (const layer of this.m_layers) {
            layer.storage.update();
            this.m_renderer.clear(false, true);
            this.m_renderer.render(layer.storage.scene, camera);
        }
        if (target !== undefined) {
            this.m_renderer.setRenderTarget(oldTarget);
        }
    }
    /**
     * Creates a new `TextCanvas` rendering layer and returns. If there was already a layer for the
     * input `layerId`, it just returns this one instead.
     *
     * @param layerId Desired layer identifier.
     *
     * @returns Created [[TextCanvasLayer]].
     */
    addLayer(layerId) {
        let result = this.getLayer(layerId);
        if (result === undefined) {
            result = {
                id: layerId,
                storage: new TextGeometry_1.TextGeometry(new THREE.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)
            };
            this.m_layers.push(result);
            this.m_layers.sort((a, b) => {
                return a.id - b.id;
            });
        }
        return result;
    }
    /**
     * Retrieves a specific `TextCanvas` rendering layer.
     *
     * @param layerId Desired layer identifier.
     *
     * @returns Selected [[TextCanvasLayer]].
     */
    getLayer(layerId) {
        return this.m_layers.find(layer => layer.id === layerId);
    }
    /**
     * Retrieves all `TextCanvas` rendering layers.
     *
     * @returns Array of [[TextCanvasLayer]]s.
     */
    getAllLayers() {
        return this.m_layers;
    }
    /**
     * Returns the computed bounding box for the input text. The current [[TextRenderStyle]] and
     * [[TextLayoutStyle]] will influence the results of this function.
     *
     * @param text Input text. Provide an array of [[GlyphData]] for better performance.
     * @param outputBounds Output text bounding box.
     * @param params Optional measurement parameters.
     *
     * @returns Result of the measurement. If `false`, some error occurred during execution and the
     * input text couldn't be properly measured.
     */
    measureText(text, outputBounds, params) {
        tempTextPosition.set(0, 0, 0);
        let path;
        let pathOverflow;
        let upperCaseArray;
        let outputCharacterBounds;
        if (params !== undefined) {
            path = params.path;
            pathOverflow = params.pathOverflow;
            outputCharacterBounds = params.outputCharacterBounds;
            if (params.path !== undefined) {
                const pathOrigin = params.path.getPoint(0);
                if (pathOrigin === null) {
                    return false;
                }
                tempTextPosition.set(pathOrigin.x, pathOrigin.y, 0.0);
            }
            if (params.letterCaseArray) {
                upperCaseArray = params.letterCaseArray;
            }
        }
        return this.placeText({
            input: text,
            layer: this.m_defaultLayer,
            textPath: path,
            textPathOverflow: pathOverflow,
            bounds: outputBounds,
            individualBounds: outputCharacterBounds,
            letterCaseArray: upperCaseArray
        });
    }
    /**
     * Adds the input text to this `TextCanvas` in the specified screen position. The current
     * [[TextRenderStyle]] and [[TextLayoutStyle]] will influence the results of this function.
     *
     * @param text Input text. Provide an array of [[GlyphData]] for better performance.
     * @param position Screen position.
     * @param params Optional addition parameters.
     *
     * @returns Result of the addition. If `false`, some error occurred during execution and the
     * input text couldn't be properly added.
     */
    addText(text, position, params) {
        tempTextPosition.copy(position);
        let path;
        let pathOverflow;
        let upperCaseArray;
        let targetLayer = this.m_defaultLayer;
        if (params !== undefined) {
            path = params.path;
            pathOverflow = params.pathOverflow;
            if (params.layer !== undefined) {
                let tempLayer = this.getLayer(params.layer);
                if (tempLayer === undefined) {
                    tempLayer = this.addLayer(params.layer);
                }
                targetLayer = tempLayer;
            }
            if (params.path !== undefined) {
                tempTextPosition.set(0, 0, tempTextPosition.z);
            }
            if (params.letterCaseArray) {
                upperCaseArray = params.letterCaseArray;
            }
        }
        const prevDrawCount = targetLayer.storage.drawCount;
        const result = this.placeText({
            input: text,
            textPath: path,
            textPathOverflow: pathOverflow,
            layer: targetLayer,
            letterCaseArray: upperCaseArray
        });
        if (result && params !== undefined) {
            if (params.updatePosition === true) {
                position.copy(tempTextPosition);
            }
            if (params.pickingData !== undefined) {
                targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);
            }
        }
        else if (!result) {
            targetLayer.storage.m_drawCount = prevDrawCount;
        }
        return result;
    }
    /**
     * Creates a new [[TextBufferObject]]. The computed text vertex buffer is equivalent to the
     * result of performing the `addText` function for the input text in the screen origin.
     *
     * @param text Input text. Provide an array of [[GlyphData]] for better performance.
     * @param params Optional creation parameters.
     *
     * @returns New [[TextBufferObject]] (or `undefined` if requested text glyphs couldn't be
     * retrieved from the current [[FontCatalog]]).
     */
    createTextBufferObject(text, params) {
        tempTextPosition.set(0, 0, 0);
        let glyphArray;
        let upperCaseArray;
        const smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps;
        if (typeof text !== "string") {
            glyphArray = text;
            if (params !== undefined && params.letterCaseArray) {
                upperCaseArray = params.letterCaseArray;
            }
        }
        else {
            upperCaseArray = [];
            glyphArray = this.m_fontCatalog.getGlyphs(text, this.m_currentTextRenderStyle, smallCapsEnabled ? upperCaseArray : undefined);
            if (glyphArray === undefined) {
                return undefined;
            }
        }
        let path;
        let pathOverflow;
        let textBounds;
        let characterBounds;
        let renderStyle;
        let layoutStyle;
        if (params !== undefined) {
            path = params.path;
            pathOverflow = params.pathOverflow;
            if (params.outputBounds === true) {
                textBounds = new THREE.Box2();
            }
            if (params.outputCharacterBounds === true) {
                characterBounds = [];
            }
            if (params.storeStyles === true) {
                renderStyle = this.m_currentTextRenderStyle;
                layoutStyle = this.m_currentTextLayoutStyle;
            }
        }
        this.placeText({
            input: text,
            layer: this.m_defaultLayer,
            computeTextBuffer: true,
            textPath: path,
            textPathOverflow: pathOverflow,
            bounds: textBounds,
            individualBounds: characterBounds,
            letterCaseArray: upperCaseArray
        });
        return new TextBufferObject_1.TextBufferObject(glyphArray, new Float32Array(tempVertexBuffer), textBounds, characterBounds, renderStyle, layoutStyle);
    }
    /**
     * Adds a previously created [[TextBufferObject]] to the `TextCanvas`. Additional parameters can
     * be provided to override the attributes stored in the buffer.
     *
     * @param textBufferObject [[TextBufferObject]] to add.
     * @param params Optional addition parameters.
     *
     * @returns Result of the addition. If `false`, some error occurred during execution and the
     * input text couldn't be properly added.
     */
    addTextBufferObject(textBufferObject, params) {
        let targetLayer = this.m_defaultLayer;
        let position;
        let scale;
        let rotation;
        let color;
        let opacity;
        let bgColor;
        let bgOpacity;
        if (params !== undefined) {
            if (params.layer !== undefined) {
                let tempLayer = this.getLayer(params.layer);
                if (tempLayer === undefined) {
                    tempLayer = this.addLayer(params.layer);
                }
                targetLayer = tempLayer;
            }
            position = params.position;
            scale = params.scale;
            rotation = params.rotation;
            color = params.color;
            opacity = params.opacity;
            bgColor = params.backgroundColor;
            bgOpacity = params.backgroundOpacity;
        }
        const prevDrawCount = targetLayer.storage.drawCount;
        const result = targetLayer.storage.addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity);
        if (result && params !== undefined) {
            if (params.pickingData !== undefined) {
                targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);
            }
        }
        else if (!result) {
            targetLayer.storage.m_drawCount = prevDrawCount;
        }
        return result;
    }
    /**
     * Executes the `pickCallback` for all previously stored picking data for text covering the
     * specified screen position.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickCallback Callback to be called for every picked element.
     */
    pickText(position, callback) {
        for (const layer of this.m_layers) {
            layer.storage.pick(position, callback);
        }
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `TextCanvas`.
     *
     * @param info The info object to increment with the values from this `TextCanvas`.
     */
    getMemoryUsage(info) {
        this.m_fontCatalog.updateMemoryUsage(info);
        for (const layer of this.m_layers) {
            layer.storage.updateMemoryUsage(info);
        }
    }
    // Places all glyphs for input text. Depending on parameters, it can store the resulting glyphs
    // in the current [[TextGeometry]] (or into a separate buffer) or compute the bounding box for
    // the input (as a whole or on a per-character basis).
    placeText(params) {
        if (params.input.length === 0 || this.m_currentTextLayoutStyle.maxLines === 0) {
            if (params.bounds !== undefined) {
                params.bounds.min.set(0, 0);
                params.bounds.max.set(0, 0);
            }
            if (params.individualBounds !== undefined) {
                params.individualBounds.length = 0;
            }
            return true;
        }
        let glyphArray;
        let smallCapsTransformations;
        const smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps;
        if (typeof params.input !== "string") {
            glyphArray = params.input;
            if (params.letterCaseArray) {
                smallCapsTransformations = params.letterCaseArray;
            }
        }
        else {
            smallCapsTransformations = [];
            glyphArray = this.m_fontCatalog.getGlyphs(params.input, this.m_currentTextRenderStyle, smallCapsEnabled ? smallCapsTransformations : undefined);
            if (glyphArray === undefined) {
                return false;
            }
        }
        let glyphBounds;
        if (params.individualBounds !== undefined) {
            tempTextBounds.array = params.individualBounds;
            tempTextBounds.offset = 0;
            glyphBounds = tempTextBounds;
        }
        if (params.bounds !== undefined) {
            params.bounds.min.set(Infinity, Infinity);
            params.bounds.max.set(-Infinity, -Infinity);
        }
        if (params.computeTextBuffer === true) {
            tempVertexBuffer = new Float32Array(glyphArray.length * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT);
        }
        const isPath = params.textPath !== undefined;
        const typesettingParams = {
            glyphs: glyphArray,
            fontCatalog: this.m_fontCatalog,
            textRenderStyle: this.m_currentTextRenderStyle,
            textLayoutStyle: this.m_currentTextLayoutStyle,
            position: tempTextPosition,
            geometry: params.layer.storage,
            smallCapsArray: smallCapsEnabled ? smallCapsTransformations : undefined,
            globalBounds: params.bounds,
            individualBounds: glyphBounds,
            vertexBuffer: params.computeTextBuffer === true ? tempVertexBuffer : undefined
        };
        let result = true;
        if (isPath) {
            Object.assign(typesettingParams, {
                path: params.textPath,
                pathOverflow: params.textPathOverflow === true
            });
            result = this.m_pathTypesetter.arrangeGlyphs(typesettingParams);
        }
        else {
            result = this.m_lineTypesetter.arrangeGlyphs(typesettingParams);
        }
        if (glyphBounds !== undefined) {
            glyphBounds.array.length = glyphBounds.offset;
        }
        return result;
    }
}
exports.TextCanvas = TextCanvas;


/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/FontCatalog.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/FontCatalog.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const GlyphData_1 = __webpack_require__(/*! ./GlyphData */ "./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js");
const GlyphTextureCache_1 = __webpack_require__(/*! ./GlyphTextureCache */ "./node_modules/@here/harp-text-canvas/lib/rendering/GlyphTextureCache.js");
const TextStyle_1 = __webpack_require__(/*! ./TextStyle */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js");
const ASSETS_PATH = "_Assets/";
const BOLD_ASSETS_PATH = "_BoldAssets/";
const ITALIC_ASSETS_PATH = "_ItalicAssets/";
const BOLD_ITALIC_ASSETS_PATH = "_BoldItalicAssets/";
const REPLACEMENT_PATH = "_Assets/Extra/";
/**
 * Collection of font assets used to render glyphs when using a [[TextCanvas]].
 *
 * @summary A `FontCatalog` works as a stack of SDF bitmap fonts (using the BMFont format) designed
 * to cover the widest Unicode code point range possible. In order to manage all these assets
 * elegantly, the assets inside the `FontCatalog` are stored on a per-Unicode-Block basis, and
 * assets for a block are only loaded once a glyph belonging to that block is requested.
 *
 * Bitmap information coming from all different fonts is then stored in a unified WebGL GPU Texture
 * resource, which can be sampled to render all currently loaded glyphs.
 *
 */
class FontCatalog {
    /**
     * @hidden
     * Creates a new FontCatalog.
     *
     * @param url FontCatalog's URL.
     * @param name FontCatalog's name.
     * @param type FontCatalog's type (sdf or msdf).
     * @param size FontCatalog's glyph size (pixels).
     * @param maxWidth FontCatalog's maximum glyph width (pixels).
     * @param maxHeight FontCatalog's maximum glyph height (pixels).
     * @param distanceRange Distance range used to generate the SDF bitmaps.
     * @param fonts Array of supported fonts.
     * @param unicodeBlocks Array of supported Unicode blocks.
     * @param maxCodePointCount Maximum number of unique code points bitmaps this `FontCatalog`'s
     * internal texture can store simultaneously.
     * @param m_replacementGlyph [[GlyphData]] to be used whenever a Unicode code point is not
     * supported by this `FontCatalog`.
     *
     * @returns New FontCatalog.
     */
    constructor(url, name, type, size, maxWidth, maxHeight, distanceRange, fonts, unicodeBlocks, maxCodePointCount, m_replacementGlyph) {
        this.url = url;
        this.name = name;
        this.type = type;
        this.size = size;
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this.distanceRange = distanceRange;
        this.fonts = fonts;
        this.unicodeBlocks = unicodeBlocks;
        this.maxCodePointCount = maxCodePointCount;
        this.m_replacementGlyph = m_replacementGlyph;
        this.m_glyphTextureCache = new GlyphTextureCache_1.GlyphTextureCache(maxCodePointCount, this.maxWidth + 1, this.maxHeight + 1);
        this.m_loadingJson = new Map();
        this.m_loadingPages = new Map();
        this.m_loadingGlyphs = new Map();
        this.m_loadedJson = new Map();
        this.m_loadedPages = new Map();
        this.m_loadedGlyphs = new Map();
    }
    /**
     * Loads a `FontCatalog`.
     *
     * @param url Asset url.
     * @param maxCodePointCount Maximum number of unique code points bitmaps this `FontCatalog`'s
     * internal texture can store simultaneously.
     *
     * @returns `FontCatalog` Promise.
     */
    static load(path, maxCodePointCount) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = new URL(path, window.location.href);
            const fontCatalog = yield FontCatalog.loadJSON(url.href);
            const replacementDirUrl = new URL(`${fontCatalog.name}${REPLACEMENT_PATH}`, url);
            const replacementJson = yield FontCatalog.loadJSON(replacementDirUrl.href + "Specials.json");
            const replacementTexture = yield FontCatalog.loadTexture(replacementDirUrl.href + "Specials.png");
            replacementTexture.wrapS = THREE.ClampToEdgeWrapping;
            replacementTexture.wrapT = THREE.ClampToEdgeWrapping;
            replacementTexture.minFilter = THREE.NearestFilter;
            replacementTexture.needsUpdate = true;
            const replacementFont = fontCatalog.fonts.find((font) => font.name === "Extra");
            const replacementGlyph = new GlyphData_1.GlyphData(65533, "Specials", replacementJson.chars[0].width, replacementJson.chars[0].height, replacementJson.chars[0].xadvance, replacementJson.chars[0].xoffset, replacementJson.chars[0].yoffset, 0.0, 0.0, 1.0, 1.0, replacementTexture, replacementFont);
            const fontCatalogInfo = new FontCatalog(url.href.substr(0, url.href.lastIndexOf("/")), fontCatalog.name, fontCatalog.type, fontCatalog.size, fontCatalog.maxWidth, fontCatalog.maxHeight, fontCatalog.distanceRange, fontCatalog.fonts, fontCatalog.supportedBlocks, maxCodePointCount, replacementGlyph);
            return fontCatalogInfo;
        });
    }
    static loadTexture(url) {
        return new Promise(resolve => {
            new THREE.TextureLoader().load(url, resolve);
        });
    }
    static loadJSON(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(url);
            if (!response.ok) {
                throw new Error(`${url} Status Text:  ${response.statusText}`);
            }
            const rawJSON = yield response.text();
            return JSON.parse(rawJSON);
        });
    }
    /**
     * Release all allocated resources.
     */
    dispose() {
        this.fonts.length = 0;
        this.unicodeBlocks.length = 0;
        this.m_glyphTextureCache.dispose();
        this.m_loadingJson.clear();
        this.m_loadingPages.clear();
        this.m_loadingGlyphs.clear();
        this.m_loadedJson.clear();
        this.m_loadedPages.clear();
        this.m_loadedGlyphs.clear();
    }
    /**
     * Removes all loaded (and loading) assets.
     */
    clear() {
        this.m_glyphTextureCache.clear();
        this.m_loadingJson.clear();
        this.m_loadingPages.clear();
        this.m_loadingGlyphs.clear();
        this.m_loadedJson.clear();
        this.m_loadedPages.clear();
        this.m_loadedGlyphs.clear();
    }
    /**
     * Updates the internal WebGLRenderTarget.
     * The update will copy the newly introduced glyphs since the previous update.
     *
     * @param renderer WebGLRenderer.
     */
    update(renderer) {
        this.m_glyphTextureCache.update(renderer);
    }
    /**
     * Internal WebGL Texture.
     */
    get texture() {
        return this.m_glyphTextureCache.texture;
    }
    /**
     * Internal WebGL Texture size.
     */
    get textureSize() {
        return this.m_glyphTextureCache.textureSize;
    }
    /**
     * Current internal loading state.
     */
    get isLoading() {
        return (this.m_loadingJson.size > 0 ||
            this.m_loadingPages.size > 0 ||
            this.m_loadingGlyphs.size > 0);
    }
    /**
     * Loads the description file for a specific [[UnicodeBlock]]. This speeds up consequent calls
     * to `FontCatalog`.loadCharset() that require glyphs from this block to be loaded.
     *
     * @param block Requested [[UnicodeBlock]].
     * @param font [[Font]] to retrieve this Unicode block from.
     * @param fontStyle [[FontStyle]] assets to load.
     * @param loadPages If `true`, all pages in this Unicode block will also be loaded.
     *
     * @returns Loaded Unicode Block json.
     */
    loadBlock(block, font, fontStyle, loadPages) {
        return __awaiter(this, void 0, void 0, function* () {
            const assetsPath = this.getAssetsPath(fontStyle, font);
            const jsonPath = `${assetsPath}/${block.name.replace(/ /g, "_")}.json`;
            let json = this.m_loadedJson.get(jsonPath);
            if (json === undefined) {
                let jsonPromise = this.m_loadingJson.get(jsonPath);
                if (jsonPromise === undefined) {
                    try {
                        jsonPromise = FontCatalog.loadJSON(jsonPath);
                        this.m_loadingJson.set(jsonPath, jsonPromise);
                        json = yield jsonPromise;
                        this.m_loadingJson.delete(jsonPath);
                        this.m_loadedJson.set(jsonPath, json);
                    }
                    catch (e) {
                        // tslint:disable-next-line:no-console
                        console.error(e);
                        this.m_loadingJson.delete(jsonPath);
                    }
                }
                else {
                    json = yield jsonPromise;
                }
            }
            const pagePromises = [];
            if (loadPages === true) {
                for (const page of json.pages) {
                    pagePromises.push(this.loadPage(`${assetsPath}/${page}`));
                }
            }
            yield Promise.all(pagePromises);
            return json;
        });
    }
    /**
     * Releases the description file for a specific [[UnicodeBlock]] (and all downloaded pages).
     * Safe to call when no assets for this block have been loaded.
     *
     * @param block Requested [[UnicodeBlock]].
     * @param font [[Font]] to remove this Unicode block from.
     * @param fontStyle [[FontStyle]] assets to remove.
     */
    removeBlock(block, font, fontStyle) {
        const assetsPath = this.getAssetsPath(fontStyle, font);
        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, "_")}.json`;
        const json = this.m_loadedJson.get(jsonPath);
        if (json !== undefined) {
            for (const page of json.pages) {
                const pagePath = `${assetsPath}/${page}`;
                this.m_loadingPages.delete(pagePath);
                this.m_loadedPages.delete(pagePath);
            }
            this.m_loadingJson.delete(jsonPath);
            this.m_loadedJson.delete(jsonPath);
        }
    }
    /**
     * Loads all the required glyphs needed to render the input text. Character repetition will not
     * be considered, and only styled assets (with applied font selection, style and variants) will
     * be loaded.
     *
     * @param input Input text.
     * @param style Specific [[TextRenderStyle]] for which glyphs will be loaded.
     *
     * @returns Promise containing an array of all loaded [[GlyphData]] for the input text.
     */
    loadCharset(input, style) {
        return __awaiter(this, void 0, void 0, function* () {
            const fontName = style.fontName;
            const fontStyle = style.fontStyle;
            const shouldTransform = style.fontVariant === TextStyle_1.FontVariant.AllCaps ||
                style.fontVariant === TextStyle_1.FontVariant.SmallCaps;
            const charset = (shouldTransform ? input.toUpperCase() : input).replace(/[\s\S](?=([\s\S]+))/g, (c, s) => {
                return s.indexOf(c) + 1 ? "" : c;
            });
            const glyphPromises = [];
            for (const char of charset) {
                const codePoint = char.codePointAt(0);
                const font = this.getFont(codePoint, fontName);
                const fontHash = `${font.name}_${fontStyle}`;
                const glyphHash = `${fontHash}_${codePoint}`;
                let fontGlyphMap = this.m_loadedGlyphs.get(fontHash);
                if (fontGlyphMap === undefined) {
                    fontGlyphMap = new Map();
                    this.m_loadedGlyphs.set(fontHash, fontGlyphMap);
                }
                const glyph = fontGlyphMap.get(codePoint);
                if (glyph === undefined) {
                    let glyphPromise = this.m_loadingGlyphs.get(glyphHash);
                    if (glyphPromise === undefined) {
                        if (font.charset.indexOf(String.fromCodePoint(codePoint)) === -1) {
                            const replacementGlyph = this.createReplacementGlyph(codePoint, char, font);
                            fontGlyphMap.set(codePoint, replacementGlyph);
                            this.m_glyphTextureCache.add(glyphHash, replacementGlyph);
                            continue;
                        }
                        let charUnicodeBlock;
                        for (const block of this.unicodeBlocks) {
                            if (codePoint >= block.min && codePoint <= block.max) {
                                charUnicodeBlock = block;
                                break;
                            }
                        }
                        glyphPromise = this.loadAssets(codePoint, fontStyle, charUnicodeBlock, font);
                        this.m_loadingGlyphs.set(glyphHash, glyphPromise);
                        glyphPromise.then((loadedGlyph) => {
                            this.m_loadingGlyphs.delete(glyphHash);
                            fontGlyphMap.set(codePoint, loadedGlyph);
                            this.m_glyphTextureCache.add(glyphHash, loadedGlyph);
                        });
                    }
                    glyphPromises.push(glyphPromise);
                }
                else if (!this.m_glyphTextureCache.has(glyphHash)) {
                    glyphPromises.push(Promise.resolve(glyph));
                    this.m_glyphTextureCache.add(glyphHash, glyph);
                }
            }
            return Promise.all(glyphPromises);
        });
    }
    /**
     * Retrieves the loaded [[GlyphData]] for a specific character.
     * Returns `undefined` if the assets for this glyph haven't been loaded yet.
     *
     * @param codePoint Character's Unicode code point.
     * @param font [[Font]] to get this glyph from.
     * @param fontStyle Specific [[FontStyle]] to get glyphs for.
     *
     * @returns [[GlyphData]] for this code point.
     */
    getGlyph(codePoint, font, fontStyle) {
        const fontGlyphMap = this.m_loadedGlyphs.get(`${font.name}_${fontStyle}`);
        if (fontGlyphMap === undefined) {
            return undefined;
        }
        return fontGlyphMap.get(codePoint);
    }
    /**
     * Retrieves the loaded [[GlyphData]] for the specified text.
     * Returns `undefined` if the assets for these glyphs haven't been loaded yet.
     *
     * @param input Input text.
     * @param style Specific [[TextRenderStyle]] to get glyphs for.
     * @param letterCaseArray Array containing the original letter case for the requested glyphs.
     *
     * @returns Array containing [[GlyphData]] for each character of the input text.
     */
    getGlyphs(input, style, letterCaseArray) {
        const result = [];
        const fontName = style.fontName;
        const fontStyle = style.fontStyle;
        const fontVariant = style.fontVariant;
        const shouldTransform = fontVariant === TextStyle_1.FontVariant.AllCaps || fontVariant === TextStyle_1.FontVariant.SmallCaps;
        for (const character of input) {
            const transformedCharacter = shouldTransform ? character.toUpperCase() : character;
            for (const char of transformedCharacter) {
                const codePoint = char.codePointAt(0);
                const font = this.getFont(codePoint, fontName);
                const glyphData = this.getGlyph(codePoint, font, fontStyle);
                if (glyphData !== undefined) {
                    result.push(glyphData);
                    if (letterCaseArray !== undefined) {
                        letterCaseArray.push(char !== character);
                    }
                }
                else {
                    return undefined;
                }
            }
        }
        return result;
    }
    /**
     * Gets the best matched font for a specific character.
     *
     * @param codePoint Character's Unicode code point.
     * @param fontName Font name suggestion.
     *
     * @returns Best matched font.
     */
    getFont(codePoint, fontName) {
        let selectedFontName = this.fonts[0].name;
        for (const block of this.unicodeBlocks) {
            if (codePoint >= block.min && codePoint <= block.max) {
                selectedFontName =
                    fontName !== undefined &&
                        block.fonts.find(element => {
                            return element === fontName;
                        }) !== undefined
                        ? fontName
                        : block.fonts[0];
                break;
            }
        }
        return this.fonts.find(element => {
            return element.name === selectedFontName;
        });
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `FontCatalog`.
     *
     * @param info The info object to increment with the values from this `FontCatalog`.
     */
    updateMemoryUsage(info) {
        let numBytes = 0;
        for (const block of this.unicodeBlocks) {
            numBytes += (block.max - block.min) * 2;
        }
        // Always stored in RGBA internally.
        let textureBytes = this.m_glyphTextureCache.textureSize.x * this.m_glyphTextureCache.textureSize.y * 4;
        for (const page in this.m_loadedPages.entries) {
            if (this.m_loadedPages.get(page) !== undefined) {
                const loadedPage = this.m_loadedPages.get(page);
                if (loadedPage !== undefined) {
                    textureBytes += loadedPage.image.width * loadedPage.image.height * 4;
                }
            }
        }
        info.heapSize += numBytes + textureBytes;
        info.gpuSize += textureBytes;
    }
    createReplacementGlyph(codePoint, char, font) {
        const replacementGlyph = this.m_replacementGlyph.clone();
        replacementGlyph.codePoint = codePoint;
        replacementGlyph.character = char;
        replacementGlyph.font = font;
        return replacementGlyph;
    }
    loadAssets(codePoint, fontStyle, block, font) {
        return __awaiter(this, void 0, void 0, function* () {
            const json = yield this.loadBlock(block, font, fontStyle);
            if (json === undefined) {
                return this.m_replacementGlyph;
            }
            const sourceGlyphData = json.chars.find(char => char.id === codePoint);
            const assetsPath = this.getAssetsPath(fontStyle, font);
            const texturePath = `${assetsPath}/${json.pages[sourceGlyphData.page]}`;
            const texture = yield this.loadPage(texturePath);
            const glyphData = new GlyphData_1.GlyphData(sourceGlyphData.id, block.name, sourceGlyphData.width, sourceGlyphData.height, sourceGlyphData.xadvance, sourceGlyphData.xoffset, sourceGlyphData.yoffset, sourceGlyphData.x / texture.image.width, 1.0 - (sourceGlyphData.y + sourceGlyphData.height) / texture.image.height, (sourceGlyphData.x + sourceGlyphData.width) / texture.image.width, 1.0 - sourceGlyphData.y / texture.image.height, texture, font);
            return glyphData;
        });
    }
    loadPage(pagePath) {
        return __awaiter(this, void 0, void 0, function* () {
            let page = this.m_loadedPages.get(pagePath);
            if (page === undefined) {
                let pagePromise = this.m_loadingPages.get(pagePath);
                if (pagePromise === undefined) {
                    pagePromise = FontCatalog.loadTexture(pagePath);
                    this.m_loadingPages.set(pagePath, pagePromise);
                    page = yield pagePromise;
                    page.wrapS = THREE.ClampToEdgeWrapping;
                    page.wrapT = THREE.ClampToEdgeWrapping;
                    page.minFilter = THREE.NearestFilter;
                    page.needsUpdate = true;
                    if (this.m_loadingPages.delete(pagePath)) {
                        this.m_loadedPages.set(pagePath, page);
                    }
                    this.m_loadingPages.delete(pagePath);
                }
                else {
                    page = yield pagePromise;
                }
            }
            return page;
        });
    }
    getAssetsPath(fontStyle, font) {
        let fontStylePath = ASSETS_PATH;
        switch (fontStyle) {
            case TextStyle_1.FontStyle.Bold:
                if (font.bold !== undefined) {
                    fontStylePath = BOLD_ASSETS_PATH;
                }
                break;
            case TextStyle_1.FontStyle.Italic:
                if (font.italic !== undefined) {
                    fontStylePath = ITALIC_ASSETS_PATH;
                }
                break;
            case TextStyle_1.FontStyle.BoldItalic:
                if (font.boldItalic !== undefined) {
                    fontStylePath = BOLD_ITALIC_ASSETS_PATH;
                }
                else if (font.italic !== undefined) {
                    fontStylePath = ITALIC_ASSETS_PATH;
                }
                else if (font.bold !== undefined) {
                    fontStylePath = BOLD_ASSETS_PATH;
                }
                break;
        }
        return `${this.url}/${this.name}${fontStylePath}${font.name}`;
    }
}
exports.FontCatalog = FontCatalog;


/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js");
/**
 * Structure containing all the required information necessary to render a BMFont glyph using
 * [[TextCanvas]].
 */
class GlyphData {
    /**
     * Creates a new `GlyphData` object.
     *
     * @param codePoint Unicode code point.
     * @param block Unicode block.
     * @param width Glyph' width.
     * @param height Glyph' height.
     * @param advanceX Amount of pixel to move after placing this glyph.
     * @param offsetX Horizontal offset from the glyph' origin.
     * @param offsetY Vertical offset from the glyph' origin.
     * @param u0 Glyph' left texture coordinate.
     * @param v0 Glyph' bottom texture coordinate.
     * @param u1 Glyph' right texture coordinate.
     * @param v1 Glyph' top texture coordinate.
     * @param texture Glyph' source texture atlas page.
     * @param font Glyph' font.
     *
     * @returns New `GlyphData`.
     */
    constructor(codePoint, block, width, height, advanceX, offsetX, offsetY, u0, v0, u1, v1, texture, font) {
        this.codePoint = codePoint;
        this.block = block;
        this.width = width;
        this.height = height;
        this.advanceX = advanceX;
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.texture = texture;
        this.font = font;
        /**
         * Array containing the positions for all corners of this glyph.
         */
        this.positions = [];
        /**
         * Array containing the source texture coordinates for all corners of this glyph.
         * Used to sample the original texture atlas pages.
         */
        this.sourceTextureCoordinates = [];
        /**
         * Array containing the dynamic texture coordinates for all corners of this glyph.
         * Used to sample the dynamic texture atlas page.
         */
        this.dynamicTextureCoordinates = [];
        /**
         * Source texture atlas' page copy index.
         */
        this.copyIndex = 0;
        /**
         * Flag indicating if glyph can be currently rendered.
         */
        this.isInCache = false;
        this.character = String.fromCodePoint(codePoint);
        this.direction = UnicodeUtils_1.UnicodeUtils.getDirection(codePoint, block);
        const left = this.offsetX;
        const right = left + this.width;
        const top = font.metrics.lineHeight - this.offsetY;
        const bottom = top - this.height;
        this.positions.push(new THREE.Vector3(left, bottom, 1.0), new THREE.Vector3(right, bottom, 1.0), new THREE.Vector3(left, top, 1.0), new THREE.Vector3(right, top, 1.0));
        this.sourceTextureCoordinates.push(new THREE.Vector2(u0, v0), new THREE.Vector2(u1, v0), new THREE.Vector2(u0, v1), new THREE.Vector2(u1, v1));
        this.dynamicTextureCoordinates.push(new THREE.Vector2(0.0, 0.0), new THREE.Vector2(1.0, 0.0), new THREE.Vector2(0.0, 1.0), new THREE.Vector2(1.0, 1.0));
    }
    /**
     * Clone this `GlyphData`.
     *
     * @returns Cloned `GlyphData`.
     */
    clone() {
        return new GlyphData(this.codePoint, this.block, this.width, this.height, this.advanceX, this.offsetX, this.offsetY, this.sourceTextureCoordinates[0].x, this.sourceTextureCoordinates[0].y, this.sourceTextureCoordinates[3].x, this.sourceTextureCoordinates[3].y, this.texture, this.font);
    }
}
exports.GlyphData = GlyphData;


/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/GlyphTextureCache.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/GlyphTextureCache.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_lrucache_1 = __webpack_require__(/*! @here/harp-lrucache */ "./node_modules/@here/harp-lrucache/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const GlyphData_1 = __webpack_require__(/*! ./GlyphData */ "./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js");
const TextMaterials_1 = __webpack_require__(/*! ./TextMaterials */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js");
/**
 * Maximum number of texture atlas pages we can copy from in a single go. This amount is determined
 * by the maximum number of texture units available on a pixel shader for all devices:
 * https://webglstats.com/webgl/parameter/MAX_TEXTURE_IMAGE_UNITS
 */
const MAX_NUM_COPY_PAGES = 8;
/**
 * Maximum texture size supported. This amount is determined by the maximum texture size supported
 * for all devices:
 * https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE
 */
const MAX_TEXTURE_SIZE = 4096;
/**
 * @hidden
 * Unified glyph SDF bitmap storage for all fonts in a [[FontCatalog]].
 * Implemented as an abstraction layer on top of an LRUCache and WebGLRenderTarget.
 */
class GlyphTextureCache {
    /**
     * Creates a `GlyphTextureCache` object.
     *
     * @param capacity Cache's maximum glyph capacity.
     * @param entryWidth Maximum entry width.
     * @param entryHeight Maximum entry height.
     *
     * @returns New `GlyphTextureCache`.
     */
    constructor(capacity, entryWidth, entryHeight) {
        this.capacity = capacity;
        this.entryWidth = entryWidth;
        this.entryHeight = entryHeight;
        const nRows = Math.floor(Math.sqrt(capacity));
        this.m_cacheHeight = nRows * nRows < capacity ? nRows + 1 : nRows;
        this.m_cacheWidth = nRows * this.m_cacheHeight < capacity ? nRows + 1 : nRows;
        this.m_textureSize = new THREE.Vector2(this.m_cacheWidth * entryWidth, this.m_cacheHeight * entryHeight);
        if (this.m_textureSize.y > MAX_TEXTURE_SIZE || this.m_textureSize.x > MAX_TEXTURE_SIZE) {
            // tslint:disable-next-line:no-console
            console.warn("GlyphTextureCache texture size (" +
                this.m_textureSize.x +
                ", " +
                this.m_textureSize.y +
                ") exceeds WebGL's widely supported MAX_TEXTURE_SIZE (" +
                MAX_TEXTURE_SIZE +
                ").\n" +
                "This could result in rendering errors on some devices.\n" +
                "Please consider reducing its capacity or input assets size.");
        }
        this.m_entryCache = new harp_lrucache_1.LRUCache(capacity);
        this.initCacheEntries();
        this.m_scene = new THREE.Scene();
        this.m_camera = new THREE.OrthographicCamera(0, this.m_textureSize.x, this.m_textureSize.y, 0);
        this.m_camera.position.z = 1;
        this.m_camera.updateMatrixWorld(false);
        this.m_rt = new THREE.WebGLRenderTarget(this.m_textureSize.x, this.m_textureSize.y, {
            wrapS: THREE.ClampToEdgeWrapping,
            wrapT: THREE.ClampToEdgeWrapping,
            depthBuffer: false,
            stencilBuffer: false
        });
        this.m_copyTextureSet = new Set();
        this.m_copyTransform = new THREE.Matrix3();
        this.m_copyPositions = [];
        this.m_copyPositions.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());
        this.m_copyMaterial = new TextMaterials_1.GlyphCopyMaterial();
        this.m_copyVertexBuffer = new THREE.InterleavedBuffer(new Float32Array(capacity * 20), 5);
        this.m_copyVertexBuffer.setDynamic(true);
        this.m_copyPositionAttribute = new THREE.InterleavedBufferAttribute(this.m_copyVertexBuffer, 3, 0);
        this.m_copyUVAttribute = new THREE.InterleavedBufferAttribute(this.m_copyVertexBuffer, 2, 3);
        this.m_copyGeometry = new THREE.BufferGeometry();
        this.m_copyGeometry.addAttribute("position", this.m_copyPositionAttribute);
        this.m_copyGeometry.addAttribute("uv", this.m_copyUVAttribute);
        const copyIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);
        copyIndexBuffer.setDynamic(true);
        this.m_copyGeometry.setIndex(copyIndexBuffer);
        this.m_copyMesh = new THREE.Mesh(this.m_copyGeometry, this.m_copyMaterial);
        this.m_copyMesh.frustumCulled = false;
        this.m_copyGeometryDrawCount = 0;
        this.m_clearMaterial = new TextMaterials_1.GlyphClearMaterial();
        this.m_clearPositionAttribute = new THREE.BufferAttribute(new Float32Array(capacity * 8), 2);
        this.m_clearPositionAttribute.setDynamic(true);
        this.m_clearGeometry = new THREE.BufferGeometry();
        this.m_clearGeometry.addAttribute("position", this.m_clearPositionAttribute);
        const clearIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);
        clearIndexBuffer.setDynamic(true);
        this.m_clearGeometry.setIndex(clearIndexBuffer);
        this.m_clearMesh = new THREE.Mesh(this.m_clearGeometry, this.m_clearMaterial);
        this.m_clearMesh.frustumCulled = false;
        this.m_clearGeometryDrawCount = 0;
        this.m_scene.add(this.m_clearMesh, this.m_copyMesh);
    }
    /**
     * Release all allocated resources.
     */
    dispose() {
        this.m_entryCache.clear();
        this.m_scene.remove(this.m_clearMesh, this.m_copyMesh);
        this.m_rt.dispose();
        this.m_clearMaterial.dispose();
        this.m_copyMaterial.dispose();
        this.m_copyTextureSet.clear();
        this.m_clearGeometry.dispose();
        this.m_copyGeometry.dispose();
    }
    /**
     * Internal WebGL Texture.
     */
    get texture() {
        return this.m_rt.texture;
    }
    /**
     * Internal WebGL Texture size.
     */
    get textureSize() {
        return this.m_textureSize;
    }
    /**
     * Add a new entry to the GlyphTextureCache. If the limit of entries is hit, the least requested
     * entry will be replaced.
     *
     * @param hash Entry's hash.
     * @param glyph Entry's glyph data.
     */
    add(hash, glyph) {
        const entry = this.m_entryCache.get(hash);
        if (entry !== undefined) {
            return;
        }
        const oldestEntry = this.m_entryCache.oldest;
        if (oldestEntry === null) {
            throw new Error("GlyphTextureCache is uninitialized!");
        }
        this.clearCacheEntry(oldestEntry.value);
        this.copyGlyphToCache(hash, glyph, oldestEntry.value.location);
    }
    /**
     * Checks if an entry is in the cache.
     *
     * @param hash Entry's hash.
     *
     * @returns Test result.
     */
    has(hash) {
        return this.m_entryCache.has(hash);
    }
    /**
     * Retrieves an entry from the cache.
     *
     * @param hash Entry's hash.
     *
     * @returns Retrieval result.
     */
    get(hash) {
        return this.m_entryCache.get(hash);
    }
    /**
     * Clears the internal LRUCache.
     */
    clear() {
        this.m_copyGeometryDrawCount = 0;
        this.m_clearGeometryDrawCount = 0;
        this.m_entryCache.clear();
        this.m_copyTextureSet.clear();
        this.initCacheEntries();
    }
    /**
     * Updates the internal WebGLRenderTarget.
     * The update will copy the newly introduced glyphs since the previous update.
     *
     * @param renderer WebGLRenderer.
     */
    update(renderer) {
        let oldRenderTarget = null;
        const willClearGeometry = this.m_clearGeometryDrawCount > 0;
        const willCopyGeometry = this.m_copyGeometryDrawCount > 0;
        if (willClearGeometry || willCopyGeometry) {
            oldRenderTarget = renderer.getRenderTarget();
            renderer.setRenderTarget(this.m_rt);
        }
        if (willClearGeometry) {
            this.m_clearPositionAttribute.needsUpdate = true;
            this.m_clearPositionAttribute.updateRange.offset = 0;
            this.m_clearPositionAttribute.updateRange.count = this.m_clearGeometryDrawCount * 8;
            this.m_clearGeometry.index.needsUpdate = true;
            this.m_clearGeometry.index.updateRange.offset = 0;
            this.m_clearGeometry.index.updateRange.count = this.m_clearGeometryDrawCount * 6;
            this.m_clearGeometry.setDrawRange(0, this.m_clearGeometryDrawCount * 6);
            this.m_clearMesh.visible = true;
            this.m_copyMesh.visible = false;
            renderer.render(this.m_scene, this.m_camera);
            this.m_clearGeometryDrawCount = 0;
            this.m_clearMesh.visible = false;
        }
        if (willCopyGeometry) {
            this.m_copyVertexBuffer.needsUpdate = true;
            this.m_copyVertexBuffer.updateRange.offset = 0;
            this.m_copyVertexBuffer.updateRange.count = this.m_copyGeometryDrawCount * 20;
            this.m_copyGeometry.index.needsUpdate = true;
            this.m_copyGeometry.index.updateRange.offset = 0;
            this.m_copyGeometry.index.updateRange.count = this.m_copyGeometryDrawCount * 6;
            this.m_copyGeometry.setDrawRange(0, this.m_copyGeometryDrawCount * 6);
            this.m_copyMesh.visible = true;
            const srcPages = Array.from(this.m_copyTextureSet);
            const nCopies = Math.ceil(this.m_copyTextureSet.size / MAX_NUM_COPY_PAGES);
            for (let copyIndex = 0; copyIndex < nCopies; copyIndex++) {
                const pageOffset = copyIndex * MAX_NUM_COPY_PAGES;
                this.m_copyMaterial.uniforms.pageOffset.value = pageOffset;
                for (let i = 0; i < MAX_NUM_COPY_PAGES; i++) {
                    const pageIndex = pageOffset + i;
                    if (pageIndex < this.m_copyTextureSet.size) {
                        this.m_copyMaterial.uniforms["page" + i].value = srcPages[pageIndex];
                    }
                }
                renderer.render(this.m_scene, this.m_camera);
            }
            this.m_copyTextureSet.clear();
            this.m_copyGeometryDrawCount = 0;
        }
        if (willClearGeometry || willCopyGeometry) {
            renderer.setRenderTarget(oldRenderTarget);
        }
    }
    initCacheEntries() {
        const dummyMetrics = {
            size: 0,
            distanceRange: 0,
            base: 0,
            lineHeight: 0,
            lineGap: 0,
            capHeight: 0,
            xHeight: 0
        };
        const dummyFont = {
            name: "",
            metrics: dummyMetrics,
            charset: ""
        };
        const dummyGlyphData = new GlyphData_1.GlyphData(0, "", 0, 0, 0, 0, 0, 0, 0, 0, 0, THREE.Texture.DEFAULT_IMAGE, dummyFont);
        for (let i = 0; i < this.m_cacheHeight; i++) {
            for (let j = 0; j < this.m_cacheWidth; j++) {
                const dummyEntry = {
                    glyphData: dummyGlyphData,
                    location: new THREE.Vector2(j, i)
                };
                this.m_entryCache.set(`Dummy_${i * this.m_cacheHeight + j}`, dummyEntry);
            }
        }
    }
    copyGlyphToCache(hash, glyph, cacheLocation) {
        this.m_copyTextureSet.add(glyph.texture);
        let copyTextureIndex = 0;
        for (const value of this.m_copyTextureSet.values()) {
            if (value === glyph.texture) {
                break;
            }
            copyTextureIndex++;
        }
        glyph.copyIndex = copyTextureIndex;
        this.m_copyTransform.set(1.0, 0.0, cacheLocation.x * this.entryWidth - glyph.offsetX, 0.0, 1.0, cacheLocation.y * this.entryHeight - glyph.positions[0].y, 0.0, 0.0, 0.0);
        for (let i = 0; i < 4; ++i) {
            this.m_copyPositions[i].set(glyph.positions[i].x, glyph.positions[i].y);
            this.m_copyPositions[i].applyMatrix3(this.m_copyTransform);
        }
        if (this.m_copyGeometryDrawCount >= this.capacity) {
            return;
        }
        const baseVertex = this.m_copyGeometryDrawCount * 4;
        const baseIndex = this.m_copyGeometryDrawCount * 6;
        for (let i = 0; i < 4; ++i) {
            this.m_copyPositionAttribute.setXYZ(baseVertex + i, this.m_copyPositions[i].x, this.m_copyPositions[i].y, glyph.copyIndex);
            this.m_copyUVAttribute.setXY(baseVertex + i, glyph.sourceTextureCoordinates[i].x, glyph.sourceTextureCoordinates[i].y);
        }
        this.m_copyGeometry.index.setX(baseIndex, baseVertex);
        this.m_copyGeometry.index.setX(baseIndex + 1, baseVertex + 1);
        this.m_copyGeometry.index.setX(baseIndex + 2, baseVertex + 2);
        this.m_copyGeometry.index.setX(baseIndex + 3, baseVertex + 2);
        this.m_copyGeometry.index.setX(baseIndex + 4, baseVertex + 1);
        this.m_copyGeometry.index.setX(baseIndex + 5, baseVertex + 3);
        ++this.m_copyGeometryDrawCount;
        const u0 = this.m_copyPositions[0].x / this.m_textureSize.x;
        const v0 = this.m_copyPositions[0].y / this.m_textureSize.y;
        const u1 = this.m_copyPositions[3].x / this.m_textureSize.x;
        const v1 = this.m_copyPositions[3].y / this.m_textureSize.y;
        glyph.dynamicTextureCoordinates[0].set(u0, v0);
        glyph.dynamicTextureCoordinates[1].set(u1, v0);
        glyph.dynamicTextureCoordinates[2].set(u0, v1);
        glyph.dynamicTextureCoordinates[3].set(u1, v1);
        glyph.isInCache = true;
        this.m_entryCache.set(hash, {
            glyphData: glyph,
            location: cacheLocation
        });
    }
    clearCacheEntry(entry) {
        entry.glyphData.isInCache = false;
        this.m_copyPositions[0].set(entry.location.x * this.entryWidth, entry.location.y * this.entryHeight);
        this.m_copyPositions[1].set((entry.location.x + 1) * this.entryWidth, entry.location.y * this.entryHeight);
        this.m_copyPositions[2].set(entry.location.x * this.entryWidth, (entry.location.y + 1) * this.entryHeight);
        this.m_copyPositions[3].set((entry.location.x + 1) * this.entryWidth, (entry.location.y + 1) * this.entryHeight);
        if (this.m_clearGeometryDrawCount >= this.capacity) {
            return;
        }
        const baseVertex = this.m_clearGeometryDrawCount * 4;
        const baseIndex = this.m_clearGeometryDrawCount * 6;
        for (let i = 0; i < 4; ++i) {
            this.m_clearPositionAttribute.setXY(baseVertex + i, this.m_copyPositions[i].x, this.m_copyPositions[i].y);
        }
        this.m_clearGeometry.index.setX(baseIndex, baseVertex);
        this.m_clearGeometry.index.setX(baseIndex + 1, baseVertex + 1);
        this.m_clearGeometry.index.setX(baseIndex + 2, baseVertex + 2);
        this.m_clearGeometry.index.setX(baseIndex + 3, baseVertex + 2);
        this.m_clearGeometry.index.setX(baseIndex + 4, baseVertex + 1);
        this.m_clearGeometry.index.setX(baseIndex + 5, baseVertex + 3);
        ++this.m_clearGeometryDrawCount;
    }
}
exports.GlyphTextureCache = GlyphTextureCache;


/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Object containing vertex buffer data generated by [[TextCanvas]].
 */
class TextBufferObject {
    /**
     * Constructs a new `TextBufferObject`.
     *
     * @param glyphs Input glyphs.
     * @param buffer Buffer containing the data generated by [[TextCanvas]].
     * @param bounds Optional text bounds.
     * @param characterBounds Optional character bounds.
     * @param textRenderStyle [[TextRenderStyle]] applied by [[TextCanvas]].
     * @param textLayoutStyle [[TextLayoutStyle]] applied by [[TextCanvas]].
     *
     * @returns New `TextBufferObject`.
     */
    constructor(glyphs, buffer, bounds, characterBounds, textRenderStyle, textLayoutStyle) {
        this.glyphs = glyphs;
        this.buffer = buffer;
        this.bounds = bounds;
        this.characterBounds = characterBounds;
        this.textRenderStyle = textRenderStyle;
        this.textLayoutStyle = textLayoutStyle;
    }
}
exports.TextBufferObject = TextBufferObject;


/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
exports.MAX_CAPACITY = 65536;
exports.VERTEX_BUFFER_STRIDE = 16;
exports.INDEX_BUFFER_STRIDE = 1;
exports.VERTICES_PER_QUAD = 4;
exports.INDICES_PER_QUAD = 6;
exports.QUAD_VERTEX_MEMORY_FOOTPRINT = exports.VERTICES_PER_QUAD * exports.VERTEX_BUFFER_STRIDE;
exports.QUAD_INDEX_MEMORY_FOOTPRINT = exports.INDICES_PER_QUAD * exports.INDEX_BUFFER_STRIDE;
/**
 * Number of bytes for float in an Float32Array.
 */
const NUM_BYTES_PER_FLOAT = 4;
/**
 * Number of bytes for integer number in an UInt32Array.
 */
const NUM_BYTES_PER_INT32 = 4;
/**
 * Procedural geometry that holds vertex attribute data for all glyphs in a [[TextCanvas]].
 */
class TextGeometry {
    /**
     * Creates a new `TextGeometry`.
     *
     * @param material Material used to render foreground glyphs.
     * @param backgroundMaterial Material used to render background glyphs.
     * @param initialSize Initial amount of glyphs that can be stored.
     * @param capacity Maximum glyph capacity.
     *
     * @returns New `TextGeometry`.
     */
    constructor(scene, material, backgroundMaterial, initialSize, capacity) {
        this.scene = scene;
        this.capacity = Math.min(capacity, exports.MAX_CAPACITY);
        this.m_currentCapacity = Math.min(initialSize, capacity);
        this.m_drawCount = 0;
        this.m_updateOffset = 0;
        this.m_pickingCount = 0;
        this.m_vertexBuffer = new THREE.InterleavedBuffer(new Float32Array(this.m_currentCapacity * exports.QUAD_VERTEX_MEMORY_FOOTPRINT), exports.VERTEX_BUFFER_STRIDE);
        this.m_vertexBuffer.setDynamic(true);
        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);
        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);
        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);
        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);
        this.m_indexBuffer = new THREE.BufferAttribute(new Uint32Array(this.m_currentCapacity * exports.QUAD_INDEX_MEMORY_FOOTPRINT), exports.INDEX_BUFFER_STRIDE);
        this.m_indexBuffer.setDynamic(true);
        this.m_geometry = new THREE.BufferGeometry();
        this.m_geometry.addAttribute("position", this.m_positionAttribute);
        this.m_geometry.addAttribute("uv", this.m_uvAttribute);
        this.m_geometry.addAttribute("color", this.m_colorAttribute);
        this.m_geometry.addAttribute("bgColor", this.m_bgColorAttribute);
        this.m_geometry.setIndex(this.m_indexBuffer);
        this.m_pickingDataArray = new Array(this.m_currentCapacity);
        this.m_mesh = new THREE.Mesh(this.m_geometry, material);
        this.m_bgMesh = new THREE.Mesh(this.m_geometry, backgroundMaterial);
        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;
        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;
        this.scene.add(this.m_bgMesh, this.m_mesh);
    }
    /**
     * Count of currently drawn glyphs.
     */
    get drawCount() {
        return this.m_drawCount;
    }
    /**
     * Mesh used to render foreground glyphs.
     */
    get mesh() {
        return this.m_mesh;
    }
    /**
     * Mesh used to render background glyphs.
     */
    get backgroundMesh() {
        return this.m_bgMesh;
    }
    /**
     * Release all allocated resources.
     */
    dispose() {
        this.scene.remove(this.m_bgMesh, this.m_mesh);
        this.m_geometry.dispose();
    }
    /**
     * Clear the geometry.
     */
    clear() {
        this.m_drawCount = 0;
        this.m_updateOffset = 0;
        this.m_pickingCount = 0;
    }
    /**
     * Update the GPU resources to reflect the latest additions to the geometry.
     */
    update() {
        if (this.drawCount > this.m_updateOffset) {
            this.m_vertexBuffer.needsUpdate = true;
            this.m_vertexBuffer.updateRange.offset =
                this.m_updateOffset * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;
            this.m_vertexBuffer.updateRange.count =
                (this.m_drawCount - this.m_updateOffset) * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;
            this.m_indexBuffer.needsUpdate = true;
            this.m_indexBuffer.updateRange.offset =
                this.m_updateOffset * exports.QUAD_INDEX_MEMORY_FOOTPRINT;
            this.m_indexBuffer.updateRange.count =
                (this.m_drawCount - this.m_updateOffset) * exports.QUAD_INDEX_MEMORY_FOOTPRINT;
        }
        this.m_updateOffset = this.m_drawCount;
        this.m_geometry.setDrawRange(0, this.m_drawCount * exports.INDICES_PER_QUAD);
    }
    /**
     * Add a new glyph to the `TextGeometry`.
     *
     * @param glyphData [[GlyphData]] holding the glyph description.
     * @param corners Transformed glyph corners.
     * @param weight Foreground glyph sampling weight.
     * @param bgWeight Foreground glyph sampling weight.
     * @param mirrored If `true`, UVs will be horizontally mirrored (needed for RTL punctuation).
     * @param style Currently set [[TextRenderStyle]].
     *
     * @returns Result of the addition.
     */
    add(glyphData, corners, weight, bgWeight, mirrored, style) {
        if (this.m_drawCount >= this.capacity) {
            return false;
        }
        else if (this.m_drawCount >= this.m_currentCapacity) {
            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);
            this.resizeBuffers(newSize);
        }
        const baseVertex = this.m_drawCount * exports.VERTICES_PER_QUAD;
        const baseIndex = this.m_drawCount * exports.INDICES_PER_QUAD;
        for (let i = 0; i < exports.VERTICES_PER_QUAD; ++i) {
            this.m_positionAttribute.setXYZW(baseVertex + i, corners[i].x, corners[i].y, corners[i].z, (mirrored ? -1.0 : 1.0) * style.rotation);
            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;
            this.m_uvAttribute.setXYZW(baseVertex + i, glyphData.dynamicTextureCoordinates[mirroredUVIdx].x, glyphData.dynamicTextureCoordinates[mirroredUVIdx].y, weight, bgWeight);
            this.m_colorAttribute.setXYZW(baseVertex + i, style.color.r, style.color.g, style.color.b, style.opacity);
            this.m_bgColorAttribute.setXYZW(baseVertex + i, style.backgroundColor.r, style.backgroundColor.g, style.backgroundColor.b, style.backgroundOpacity);
        }
        this.m_indexBuffer.setX(baseIndex, baseVertex);
        this.m_indexBuffer.setX(baseIndex + 1, baseVertex + 1);
        this.m_indexBuffer.setX(baseIndex + 2, baseVertex + 2);
        this.m_indexBuffer.setX(baseIndex + 3, baseVertex + 2);
        this.m_indexBuffer.setX(baseIndex + 4, baseVertex + 1);
        this.m_indexBuffer.setX(baseIndex + 5, baseVertex + 3);
        ++this.m_drawCount;
        return true;
    }
    /**
     * Add a new glyph to a text buffer.
     *
     * @param buffer Target buffer where glyph attributes will be stored.
     * @param offset Offset of the target buffer.
     * @param glyphData [[GlyphData]] holding the glyph description.
     * @param corners Transformed glyph corners.
     * @param weight Foreground glyph sampling weight.
     * @param bgWeight Foreground glyph sampling weight.
     * @param mirrored If `true`, UVs will be mirrored (needed for RTL punctuation).
     * @param style Currently set [[TextRenderStyle]].
     */
    addToBuffer(buffer, offset, glyphData, corners, weight, bgWeight, mirrored, style) {
        for (let i = 0; i < exports.VERTICES_PER_QUAD; ++i) {
            const vertexOffset = offset + exports.VERTEX_BUFFER_STRIDE * i;
            buffer[vertexOffset] = corners[i].x;
            buffer[vertexOffset + 1] = corners[i].y;
            buffer[vertexOffset + 2] = corners[i].z;
            buffer[vertexOffset + 3] = (mirrored ? -1.0 : 1.0) * style.rotation;
            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;
            buffer[vertexOffset + 4] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].x;
            buffer[vertexOffset + 5] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].y;
            buffer[vertexOffset + 6] = weight;
            buffer[vertexOffset + 7] = bgWeight;
            buffer[vertexOffset + 8] = style.color.r;
            buffer[vertexOffset + 9] = style.color.g;
            buffer[vertexOffset + 10] = style.color.b;
            buffer[vertexOffset + 11] = style.opacity;
            buffer[vertexOffset + 12] = style.backgroundColor.r;
            buffer[vertexOffset + 13] = style.backgroundColor.g;
            buffer[vertexOffset + 14] = style.backgroundColor.b;
            buffer[vertexOffset + 15] = style.backgroundOpacity;
        }
    }
    /**
     * Add a previously computed [[TextBufferObject]] to the `TextGeometry`. Extra parameters can
     * be passed to override the passed attribute data.
     *
     * @param textBufferObject [[TextBufferObject]] containing computed glyphs.
     * @param position Override position value.
     * @param scale Override scale value.
     * @param rotation Override rotation value.
     * @param color Override color value.
     * @param opacity Override opacity value.
     * @param bgColor Override background color value.
     * @param bgOpacity Override background opacity value.
     *
     * @returns Result of the addition.
     */
    addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity) {
        if (this.m_drawCount + textBufferObject.glyphs.length >= this.capacity) {
            return false;
        }
        else if (this.m_drawCount + textBufferObject.glyphs.length >= this.m_currentCapacity) {
            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);
            this.resizeBuffers(newSize);
        }
        const s = scale || 1.0;
        const r = rotation || 0.0;
        const cosR = Math.cos(r);
        const sinR = Math.sin(r);
        const offsetX = position !== undefined ? position.x : 0.0;
        const offsetY = position !== undefined ? position.y : 0.0;
        const offsetZ = position !== undefined ? position.z : 0.0;
        const buffer = textBufferObject.buffer;
        const rot = buffer[3];
        const rotSign = rot < 0 ? -1.0 : 1.0;
        const red = color !== undefined ? color.r : buffer[8];
        const green = color !== undefined ? color.g : buffer[9];
        const blue = color !== undefined ? color.b : buffer[10];
        const alpha = opacity !== undefined ? opacity : buffer[11];
        const bgRed = bgColor !== undefined ? bgColor.r : buffer[12];
        const bgGreen = bgColor !== undefined ? bgColor.g : buffer[13];
        const bgBlue = bgColor !== undefined ? bgColor.b : buffer[14];
        const bgAlpha = bgOpacity !== undefined ? bgOpacity : buffer[15];
        const targetOffset = this.m_drawCount * exports.VERTICES_PER_QUAD;
        for (let i = 0; i < textBufferObject.glyphs.length; ++i) {
            const srcOffset = i * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;
            const glyph = textBufferObject.glyphs[i];
            if (!glyph.isInCache) {
                return false;
            }
            const mirrored = buffer[srcOffset + 4] > buffer[srcOffset + exports.VERTEX_BUFFER_STRIDE + 4];
            const w = buffer[srcOffset + 6];
            const bw = buffer[srcOffset + 7];
            for (let j = 0; j < exports.VERTICES_PER_QUAD; ++j) {
                const x = buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE];
                const y = buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 1];
                this.m_positionAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, x * s * cosR + y * s * -sinR + offsetX, x * s * sinR + y * s * cosR + offsetY, buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 2] + offsetZ, buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 3] + rotSign * r);
                const mirroredUVIdx = mirrored ? ((j + 1) % 2) + Math.floor(j / 2) * 2 : j;
                this.m_uvAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, glyph.dynamicTextureCoordinates[mirroredUVIdx].x, glyph.dynamicTextureCoordinates[mirroredUVIdx].y, w, (bw - w) / s + w);
                this.m_colorAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, red, green, blue, alpha);
                this.m_bgColorAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, bgRed, bgGreen, bgBlue, bgAlpha);
            }
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 1, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 1);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 2, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 2);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 3, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 2);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 4, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 1);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 5, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 3);
        }
        this.m_drawCount += textBufferObject.glyphs.length;
        return true;
    }
    /**
     * Adds picking data for glyphs from the specified start until the last glyph added.
     *
     * @param startIdx First glyph index that this picking data is associated to.
     * @param endIdx Last glyph index that this picking data is associated to.
     * @param pickingData Picking data to be added.
     */
    addPickingData(startIdx, endIdx, pickingData) {
        if (this.m_pickingCount >= this.m_currentCapacity) {
            return false;
        }
        this.m_pickingDataArray[this.m_pickingCount] = {
            start: Math.min(startIdx, this.capacity),
            end: Math.min(endIdx, this.capacity),
            data: pickingData
        };
        ++this.m_pickingCount;
        return true;
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple glyphs
     * are found, the order of the results is unspecified.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickCallback Callback to be called for every picked element.
     */
    pick(screenPosition, pickCallback) {
        for (const pickingData of this.m_pickingDataArray) {
            if (pickingData === undefined) {
                return;
            }
            for (let i = pickingData.start; i < pickingData.end; ++i) {
                const positionIndex = i * exports.VERTICES_PER_QUAD;
                const minX = Math.min(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));
                if (screenPosition.x < minX) {
                    continue;
                }
                const maxX = Math.max(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));
                if (screenPosition.x > maxX) {
                    continue;
                }
                const minY = Math.min(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));
                if (screenPosition.y < minY) {
                    continue;
                }
                const maxY = Math.max(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));
                if (screenPosition.y > maxY) {
                    continue;
                }
                pickCallback(pickingData.data);
                break;
            }
        }
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `TextGeometry`.
     *
     * @param info The info object to increment with the values from this `TextGeometry`.
     */
    updateMemoryUsage(info) {
        const numBytes = this.m_vertexBuffer.count * NUM_BYTES_PER_FLOAT +
            this.m_indexBuffer.count * NUM_BYTES_PER_INT32;
        info.heapSize += numBytes;
        info.gpuSize += numBytes;
    }
    resizeBuffers(size) {
        this.m_currentCapacity = size;
        const newVertexBuffer = new Float32Array(size * exports.QUAD_VERTEX_MEMORY_FOOTPRINT);
        newVertexBuffer.set(this.m_vertexBuffer.array);
        this.m_vertexBuffer = new THREE.InterleavedBuffer(newVertexBuffer, exports.VERTEX_BUFFER_STRIDE);
        this.m_vertexBuffer.setDynamic(true);
        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);
        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);
        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);
        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);
        const newIndexBuffer = new Uint32Array(size * exports.QUAD_INDEX_MEMORY_FOOTPRINT);
        newIndexBuffer.set(this.m_indexBuffer.array);
        this.m_indexBuffer = new THREE.BufferAttribute(newIndexBuffer, exports.INDEX_BUFFER_STRIDE);
        this.m_indexBuffer.setDynamic(true);
        this.m_geometry.dispose();
        this.m_geometry = new THREE.BufferGeometry();
        this.m_geometry.addAttribute("position", this.m_positionAttribute);
        this.m_geometry.addAttribute("uv", this.m_uvAttribute);
        this.m_geometry.addAttribute("color", this.m_colorAttribute);
        this.m_geometry.addAttribute("bgColor", this.m_bgColorAttribute);
        this.m_geometry.setIndex(this.m_indexBuffer);
        this.m_pickingDataArray.length = this.m_currentCapacity;
        this.scene.remove(this.m_bgMesh, this.m_mesh);
        this.m_mesh = new THREE.Mesh(this.m_geometry, this.m_mesh.material);
        this.m_bgMesh = new THREE.Mesh(this.m_geometry, this.m_bgMesh.material);
        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;
        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;
        this.scene.add(this.m_bgMesh, this.m_mesh);
    }
}
exports.TextGeometry = TextGeometry;


/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const SdfShaderChunks = {
    sdf_attributes: `
        attribute vec4 position;
        attribute vec4 uv;
        attribute vec4 color;
        attribute vec4 bgColor;
        `,
    sdf_varying: `
        varying vec4 vColor;
        varying float vWeight;
        varying vec2 vUv;
        varying float vRotation;
        `,
    sdf_varying_computation: `
        #if BG_TEXT
        vColor = bgColor;
        vWeight = uv.w;
        #else
        vColor = color;
        vWeight = uv.z;
        #endif
        vUv = vec2(uv.xy);
        vRotation = position.w;
        `,
    sdf_frag_uniforms: `
        uniform sampler2D sdfTexture;
        uniform vec4 sdfParams;
        `,
    sdf_sampling_functions: `
        float median(float r, float g, float b) {
            return max(min(r, g), min(max(r, g), b));
        }

        float getDistance(vec2 uvOffset) {
            vec3 sample = texture2D(sdfTexture, vUv.xy + uvOffset).rgb;
            #if MSDF
            return median(sample.r, sample.g, sample.b);
            #else
            return sample.r;
            #endif
        }

        float getOpacity(vec2 uvOffset, float weight) {
            vec2 uv = vUv + uvOffset;
            vec2 rotatedUVs = abs(vec2(
                cos(vRotation) * uv.x - sin(vRotation) * uv.y,
                sin(vRotation) * uv.x + cos(vRotation) * uv.y));

            float dx = dFdx(rotatedUVs.x) * sdfParams.x;
            float dy = dFdy(rotatedUVs.y) * sdfParams.y;
            float toPixels = sdfParams.w * inversesqrt( dx * dx + dy * dy );

            float dist = getDistance(uvOffset) + min(weight, 0.5 - 1.0 / sdfParams.w) - 0.5;
            return clamp(dist * toPixels + 0.5, 0.0, 1.0);
        }
        `
};
Object.assign(THREE.ShaderChunk, SdfShaderChunks);
const clearVertexSource = `
    attribute vec2 position;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);
    }`;
const clearFragmentSource = `
    precision highp float;
    precision highp int;

    void main() {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
    }`;
const copyVertexSource = `
    attribute vec3 position;
    attribute vec2 uv;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    varying vec3 vUv;

    void main() {
        vUv = vec3(uv.xy, position.z);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);
    }`;
const copyFragmentSource = `
    precision highp float;
    precision highp int;

    uniform float pageOffset;
    uniform sampler2D page0;
    uniform sampler2D page1;
    uniform sampler2D page2;
    uniform sampler2D page3;
    uniform sampler2D page4;
    uniform sampler2D page5;
    uniform sampler2D page6;
    uniform sampler2D page7;

    varying vec3 vUv;

    void main() {
        vec4 sample = vec4(0.0);
        if (vUv.z < pageOffset || vUv.z > (pageOffset + 7.0)) discard;
        else if (vUv.z < pageOffset + 1.0) sample = texture2D(page0, vUv.xy);
        else if (vUv.z < pageOffset + 2.0) sample = texture2D(page1, vUv.xy);
        else if (vUv.z < pageOffset + 3.0) sample = texture2D(page2, vUv.xy);
        else if (vUv.z < pageOffset + 4.0) sample = texture2D(page3, vUv.xy);
        else if (vUv.z < pageOffset + 5.0) sample = texture2D(page4, vUv.xy);
        else if (vUv.z < pageOffset + 6.0) sample = texture2D(page5, vUv.xy);
        else if (vUv.z < pageOffset + 7.0) sample = texture2D(page6, vUv.xy);
        else sample = texture2D(page7, vUv.xy);

        gl_FragColor = sample;
    }`;
const sdfTextVertexSource = `
    #include <sdf_attributes>
    #include <sdf_varying>

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    void main() {
        #include <sdf_varying_computation>
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
    }`;
const sdfTextFragmentSource = `
    precision highp float;
    precision highp int;

    #include <sdf_varying>
    #include <sdf_frag_uniforms>
    #include <sdf_sampling_functions>

    void main() {
        vec4 color = vColor;
        color.a *= getOpacity(vec2(0.0), vWeight);
        if (color.a < 0.05) {
            discard;
        }
        gl_FragColor = color;
    }`;
/**
 * @hidden
 * Material used for clearing glyphs from a [[GlyphTextureCache]].
 */
class GlyphClearMaterial extends THREE.RawShaderMaterial {
    /**
     * Creates a new `GlyphClearMaterial`.
     *
     * @returns New `GlyphClearMaterial`.
     */
    constructor() {
        const shaderParams = {
            name: "GlyphClearMaterial",
            vertexShader: clearVertexSource,
            fragmentShader: clearFragmentSource,
            uniforms: {},
            depthTest: false,
            depthWrite: false
        };
        super(shaderParams);
    }
}
exports.GlyphClearMaterial = GlyphClearMaterial;
/**
 * @hidden
 * Material used for copying glyphs into a [[GlyphTextureCache]].
 */
class GlyphCopyMaterial extends THREE.RawShaderMaterial {
    /**
     * Creates a new `GlyphCopyMaterial`.
     *
     * @returns New `GlyphCopyMaterial`.
     */
    constructor() {
        const shaderParams = {
            name: "GlyphCopyMaterial",
            vertexShader: copyVertexSource,
            fragmentShader: copyFragmentSource,
            uniforms: {
                pageOffset: new THREE.Uniform(0.0),
                page0: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page1: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page2: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page3: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page4: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page5: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page6: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page7: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE)
            },
            depthTest: false,
            depthWrite: false
        };
        super(shaderParams);
    }
}
exports.GlyphCopyMaterial = GlyphCopyMaterial;
/**
 * @hidden
 * Material designed to render transformable, high quality SDF text.
 */
class SdfTextMaterial extends THREE.RawShaderMaterial {
    /**
     * Creates a new `SdfTextMaterial`.
     *
     * @param params Material parameters.
     *
     * @returns New `SdfTextMaterial`.
     */
    constructor(params) {
        const shaderParams = {
            name: "SdfTextMaterial",
            vertexShader: params.vertexSource !== undefined ? params.vertexSource : sdfTextVertexSource,
            fragmentShader: params.fragmentSource !== undefined ? params.fragmentSource : sdfTextFragmentSource,
            uniforms: {
                sdfTexture: new THREE.Uniform(params.texture),
                sdfParams: new THREE.Uniform(new THREE.Vector4(params.textureSize.x, params.textureSize.y, params.size, params.distanceRange))
            },
            defines: {
                MSDF: params.isMsdf ? 1.0 : 0.0,
                BG_TEXT: params.isBackground ? 1.0 : 0.0
            },
            depthTest: true,
            depthWrite: true,
            side: THREE.DoubleSide,
            transparent: true
        };
        super(shaderParams);
        this.extensions.derivatives = true;
    }
}
exports.SdfTextMaterial = SdfTextMaterial;


/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Unit of measurement used to specify a font's size.
 */
var FontUnit;
(function (FontUnit) {
    FontUnit[FontUnit["Em"] = 0] = "Em";
    FontUnit[FontUnit["Pixel"] = 1] = "Pixel";
    FontUnit[FontUnit["Point"] = 2] = "Point";
    FontUnit[FontUnit["Percent"] = 3] = "Percent";
})(FontUnit = exports.FontUnit || (exports.FontUnit = {}));
/**
 * Style to be used when rendering glyphs.
 */
var FontStyle;
(function (FontStyle) {
    FontStyle[FontStyle["Regular"] = 0] = "Regular";
    FontStyle[FontStyle["Bold"] = 1] = "Bold";
    FontStyle[FontStyle["Italic"] = 2] = "Italic";
    FontStyle[FontStyle["BoldItalic"] = 3] = "BoldItalic";
})(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
/**
 * Variant to be used when rendering.
 */
var FontVariant;
(function (FontVariant) {
    FontVariant[FontVariant["Regular"] = 0] = "Regular";
    FontVariant[FontVariant["AllCaps"] = 1] = "AllCaps";
    FontVariant[FontVariant["SmallCaps"] = 2] = "SmallCaps";
})(FontVariant = exports.FontVariant || (exports.FontVariant = {}));
/**
 * Vertical alignment to be used when placing text.
 */
var VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment[VerticalAlignment["Above"] = 0] = "Above";
    VerticalAlignment[VerticalAlignment["Center"] = -0.5] = "Center";
    VerticalAlignment[VerticalAlignment["Below"] = -1] = "Below";
})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));
/**
 * Horizontal alignment to be used when placing text.
 */
var HorizontalAlignment;
(function (HorizontalAlignment) {
    HorizontalAlignment[HorizontalAlignment["Left"] = 0] = "Left";
    HorizontalAlignment[HorizontalAlignment["Center"] = -0.5] = "Center";
    HorizontalAlignment[HorizontalAlignment["Right"] = -1] = "Right";
})(HorizontalAlignment = exports.HorizontalAlignment || (exports.HorizontalAlignment = {}));
/**
 * Text wrapping rule used when `lineWidth` is reached.
 */
var WrappingMode;
(function (WrappingMode) {
    WrappingMode[WrappingMode["None"] = 0] = "None";
    WrappingMode[WrappingMode["Character"] = 1] = "Character";
    WrappingMode[WrappingMode["Word"] = 2] = "Word";
})(WrappingMode = exports.WrappingMode || (exports.WrappingMode = {}));
/**
 * Namespace containing default values for all members of [[TextRenderParameters]] and
 * [[TextLayoutParameters]].
 */
var DefaultTextStyle;
(function (DefaultTextStyle) {
    DefaultTextStyle.DEFAULT_FONT_NAME = "";
    DefaultTextStyle.DEFAULT_FONT_SIZE = {
        unit: Object.freeze(FontUnit.Pixel),
        size: Object.freeze(16.0),
        backgroundSize: Object.freeze(0.0)
    };
    DefaultTextStyle.DEFAULT_FONT_STYLE = FontStyle.Regular;
    DefaultTextStyle.DEFAULT_FONT_VARIANT = FontVariant.Regular;
    DefaultTextStyle.DEFAULT_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_COLOR = new THREE.Color(0x000000);
    DefaultTextStyle.DEFAULT_OPACITY = 1.0;
    DefaultTextStyle.DEFAULT_BACKGROUND_COLOR = new THREE.Color(0x000000);
    DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY = 0.0;
    DefaultTextStyle.DEFAULT_TRACKING = 0.0;
    DefaultTextStyle.DEFAULT_LEADING = 0.0;
    DefaultTextStyle.DEFAULT_MAX_LINES = Infinity;
    DefaultTextStyle.DEFAULT_LINE_WIDTH = Infinity;
    DefaultTextStyle.DEFAULT_CANVAS_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_LINE_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_WRAPPING_MODE = WrappingMode.Word;
    DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT = VerticalAlignment.Above;
    DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT = HorizontalAlignment.Left;
})(DefaultTextStyle = exports.DefaultTextStyle || (exports.DefaultTextStyle = {}));
/**
 * [[TextCanvas]] text rendering style.
 */
class TextRenderStyle {
    /**
     * Creates a new `TextRenderStyle`.
     *
     * @param params Input [[TextRenderParameters]].
     *
     * @returns New `TextRenderStyle`.
     */
    constructor(params = {}) {
        this.m_params = {
            fontName: params.fontName !== undefined
                ? params.fontName
                : DefaultTextStyle.DEFAULT_FONT_NAME,
            fontSize: params.fontSize !== undefined
                ? params.fontSize
                : {
                    unit: DefaultTextStyle.DEFAULT_FONT_SIZE.unit,
                    size: DefaultTextStyle.DEFAULT_FONT_SIZE.size,
                    backgroundSize: DefaultTextStyle.DEFAULT_FONT_SIZE.backgroundSize
                },
            fontStyle: params.fontStyle !== undefined
                ? params.fontStyle
                : DefaultTextStyle.DEFAULT_FONT_STYLE,
            fontVariant: params.fontVariant !== undefined
                ? params.fontVariant
                : DefaultTextStyle.DEFAULT_FONT_VARIANT,
            rotation: params.rotation !== undefined ? params.rotation : DefaultTextStyle.DEFAULT_ROTATION,
            color: params.color !== undefined
                ? params.color
                : new THREE.Color(DefaultTextStyle.DEFAULT_COLOR),
            opacity: params.opacity !== undefined ? params.opacity : DefaultTextStyle.DEFAULT_OPACITY,
            backgroundColor: params.backgroundColor !== undefined
                ? params.backgroundColor
                : new THREE.Color(DefaultTextStyle.DEFAULT_BACKGROUND_COLOR),
            backgroundOpacity: params.backgroundOpacity !== undefined
                ? params.backgroundOpacity
                : DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY
        };
    }
    /**
     * Current [[TextRenderParameters]] for this style.
     */
    get params() {
        return this.m_params;
    }
    set params(value) {
        this.m_params = Object.assign({}, this.m_params, value);
    }
    /**
     * Name of the preferred [[Font]] to be used when rendering.
     */
    get fontName() {
        return this.m_params.fontName;
    }
    set fontName(value) {
        this.m_params.fontName = value;
    }
    /**
     * Collection of unit and sizes to apply for the currently active [[Font]].
     */
    get fontSize() {
        return this.m_params.fontSize;
    }
    set fontSize(value) {
        this.m_params.fontSize = value;
    }
    /**
     * Glyph style to apply for the currently active [[Font]].
     */
    get fontStyle() {
        return this.m_params.fontStyle;
    }
    set fontStyle(value) {
        this.m_params.fontStyle = value;
    }
    /**
     * Glyph variant to apply for the currently active [[Font]].
     */
    get fontVariant() {
        return this.m_params.fontVariant;
    }
    set fontVariant(value) {
        this.m_params.fontVariant = value;
    }
    /**
     * Glyph local rotation (radians).
     */
    get rotation() {
        return this.m_params.rotation;
    }
    set rotation(value) {
        this.m_params.rotation = value;
    }
    /**
     * Glyph color.
     */
    get color() {
        return this.m_params.color;
    }
    set color(value) {
        this.m_params.color = value;
    }
    /**
     * Glyph background color.
     */
    get backgroundColor() {
        return this.m_params.backgroundColor;
    }
    set backgroundColor(value) {
        this.m_params.backgroundColor = value;
    }
    /**
     * Glyph opacity.
     */
    get opacity() {
        return this.m_params.opacity;
    }
    set opacity(value) {
        this.m_params.opacity = value;
    }
    /**
     * Glyph background opacity.
     */
    get backgroundOpacity() {
        return this.m_params.backgroundOpacity;
    }
    set backgroundOpacity(value) {
        this.m_params.backgroundOpacity = value;
    }
    /**
     * Clone this `TextRenderStyle`.
     *
     * @param params Input [[TextRenderParameters]].
     *
     * @returns Cloned `TextRenderStyle`.
     */
    clone(params = {}) {
        return new TextRenderStyle(Object.assign({}, this.m_params, params));
    }
}
exports.TextRenderStyle = TextRenderStyle;
/**
 * [[TextCanvas]] text rendering style.
 */
class TextLayoutStyle {
    /**
     * Creates a new `TextLayoutStyle`.
     *
     * @param params Input [[TextLayoutParameters]].
     *
     * @returns New `TextLayoutStyle`.
     */
    constructor(params = {}) {
        this.m_params = {
            tracking: params.tracking !== undefined ? params.tracking : DefaultTextStyle.DEFAULT_TRACKING,
            leading: params.leading !== undefined ? params.leading : DefaultTextStyle.DEFAULT_LEADING,
            maxLines: params.maxLines !== undefined
                ? params.maxLines
                : DefaultTextStyle.DEFAULT_MAX_LINES,
            lineWidth: params.lineWidth !== undefined
                ? params.lineWidth
                : DefaultTextStyle.DEFAULT_LINE_WIDTH,
            canvasRotation: params.canvasRotation !== undefined
                ? params.canvasRotation
                : DefaultTextStyle.DEFAULT_CANVAS_ROTATION,
            lineRotation: params.lineRotation !== undefined
                ? params.lineRotation
                : DefaultTextStyle.DEFAULT_LINE_ROTATION,
            wrappingMode: params.wrappingMode !== undefined
                ? params.wrappingMode
                : DefaultTextStyle.DEFAULT_WRAPPING_MODE,
            verticalAlignment: params.verticalAlignment !== undefined
                ? params.verticalAlignment
                : DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT,
            horizontalAlignment: params.horizontalAlignment !== undefined
                ? params.horizontalAlignment
                : DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT
        };
    }
    /**
     * Current [[TextLayoutParameters]] for this style.
     */
    get params() {
        return this.m_params;
    }
    set params(value) {
        this.m_params = Object.assign({}, this.m_params, value);
    }
    /**
     * Inter-glyph spacing (pixels). Scaled by [[FontSize]].
     */
    get tracking() {
        return this.m_params.tracking;
    }
    set tracking(value) {
        this.m_params.tracking = value;
    }
    /**
     * Inter-line spacing (pixels). Scaled by [[FontSize]].
     */
    get leading() {
        return this.m_params.leading;
    }
    set leading(value) {
        this.m_params.leading = value;
    }
    /**
     * Maximum number of lines to be considered when using [[TextCanvas]].
     */
    get maxLines() {
        return this.m_params.maxLines;
    }
    set maxLines(value) {
        this.m_params.maxLines = value;
    }
    /**
     * Maximum line width (pixels).
     */
    get lineWidth() {
        return this.m_params.lineWidth;
    }
    set lineWidth(value) {
        this.m_params.lineWidth = value;
    }
    /**
     * [[TextCanvas]] rotation (radians).
     */
    get canvasRotation() {
        return this.m_params.canvasRotation;
    }
    set canvasRotation(value) {
        this.m_params.canvasRotation = value;
    }
    /**
     * Line typesetting rotation (radians).
     */
    get lineRotation() {
        return this.m_params.lineRotation;
    }
    set lineRotation(value) {
        this.m_params.lineRotation = value;
    }
    /**
     * Wrapping (line-breaking) mode.
     */
    get wrappingMode() {
        return this.m_params.wrappingMode;
    }
    set wrappingMode(value) {
        this.m_params.wrappingMode = value;
    }
    /**
     * Text position regarding the baseline.
     */
    get verticalAlignment() {
        return this.m_params.verticalAlignment;
    }
    set verticalAlignment(value) {
        this.m_params.verticalAlignment = value;
    }
    /**
     * Text position inside a line.
     */
    get horizontalAlignment() {
        return this.m_params.horizontalAlignment;
    }
    set horizontalAlignment(value) {
        this.m_params.horizontalAlignment = value;
    }
    /**
     * Clone this `TextLayoutStyle`.
     *
     * @param params Input [[TextLayoutParameters]].
     *
     * @returns Cloned `TextLayoutStyle`.
     */
    clone(params = {}) {
        return new TextLayoutStyle(Object.assign({}, this.m_params, params));
    }
}
exports.TextLayoutStyle = TextLayoutStyle;


/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/typesetting/LineTypesetter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/typesetting/LineTypesetter.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const TextGeometry_1 = __webpack_require__(/*! ../rendering/TextGeometry */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js");
const TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js");
const TypesettingUtils_1 = __webpack_require__(/*! ../utils/TypesettingUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js");
/**
 * @hidden
 * [[Typesetter]] implementation that handles multi-line complex layout text.
 */
class LineTypesetter {
    /**
     * Creates a `LineTypesetter` object.
     *
     * @returns New `LineTypesetter`.
     */
    constructor() {
        this.m_tempTransform = new THREE.Matrix3();
        this.m_tempCorners = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
        this.m_tempLineDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempRunDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempPixelSize = 1.0;
        this.m_tempPixelBgSize = 1.0;
        this.m_tempScale = 1.0;
        this.m_tempSmallCaps = false;
    }
    /**
     * Arranges the specified glyphs using this `LineTypesetter`. Text will be placed into multiple
     * bidirectional lines, that will be generated taking into account [[textLayoutStyle]] features,
     * such as:
     * - Maximum line width.
     * - Word and character wrapping.
     * - Maximum number of lines.
     * - Vertical and horizontal alignment.
     * - Leading (spacing between lines).
     *
     * @param params Typesetting parameters.
     *
     * @returns If `false`, some error occurred during execution and the output should be dismissed.
     */
    arrangeGlyphs(params) {
        // Initializes common typesetting parameters (used across all functions in this class).
        this.m_currentParams = params;
        this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);
        this.m_tempRunDirection = this.m_tempLineDirection;
        this.m_tempPixelSize = TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);
        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;
        this.m_tempPixelBgSize = Math.min(TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);
        this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== undefined;
        this.m_currentParams.position.y +=
            this.m_currentParams.textLayoutStyle.verticalAlignment *
                this.m_currentParams.glyphs[0].font.metrics.capHeight *
                this.m_tempScale;
        const isOnlyMeasured = this.m_currentParams.globalBounds !== undefined &&
            this.m_currentParams.vertexBuffer === undefined;
        // Compute line origin and height.
        const origin = this.m_currentParams.position.x;
        const lineHeight = this.m_currentParams.glyphs[0].font.metrics.lineHeight +
            this.m_currentParams.textLayoutStyle.leading;
        // Initialize line-breaking and wrapping variables.
        let lineStartIdx = 0;
        let glyphWrapIdx = 0;
        let wordWrapIdx = 0;
        let lineStartX = 0;
        let lineCurrX = 0;
        let glyphWrapX = 0;
        let wordWrapX = 0;
        let lineCount = 0;
        let isBidirectionalLine = false;
        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {
            if (lineCount > this.m_currentParams.textLayoutStyle.maxLines - 1) {
                break;
            }
            const glyphData = this.m_currentParams.glyphs[i];
            if (!glyphData.isInCache && !isOnlyMeasured) {
                return false;
            }
            const isNewLine = UnicodeUtils_1.UnicodeUtils.isNewLine(glyphData.codePoint);
            const isWhiteSpace = UnicodeUtils_1.UnicodeUtils.isWhiteSpace(glyphData.codePoint);
            // Check if this line should be treated as bidirectional.
            if (!isBidirectionalLine && glyphData.direction === -this.m_tempLineDirection) {
                isBidirectionalLine = true;
            }
            // Advance the line's current X offset (only for printable characters).
            if (UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                lineCurrX +=
                    (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *
                        this.m_tempScale *
                        (this.m_tempSmallCaps
                            ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant)
                            : 1.0);
            }
            // If this is the first character in a line, update the line's X offset values (needed
            // to properly center and wrap).
            if (i === lineStartIdx) {
                lineStartX = lineCurrX;
                glyphWrapX = lineCurrX;
                wordWrapX = lineCurrX;
            }
            // Check if should break the current line.
            if (isNewLine ||
                (this.m_currentParams.textLayoutStyle.wrappingMode !== TextStyle_1.WrappingMode.None &&
                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth)) {
                // Perform wrapping.
                if (this.m_currentParams.textLayoutStyle.wrappingMode !== TextStyle_1.WrappingMode.None) {
                    let wrapPointIdx = glyphWrapIdx;
                    let wrapPointX = glyphWrapX;
                    // Only wrap words when more than a single word fits into the current line.
                    if (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&
                        wordWrapX !== lineStartX) {
                        wrapPointIdx = wordWrapIdx;
                        wrapPointX = wordWrapX;
                    }
                    lineCurrX = wrapPointX;
                    i = Math.min(isNewLine ? (lineStartIdx === i ? wrapPointIdx : i) : wrapPointIdx, this.m_currentParams.glyphs.length - 1);
                }
                // Calculate the correct starting position for the line base on alignment, and place
                // all glyphs in it.
                const lineAlignment = this.m_tempLineDirection === UnicodeUtils_1.UnicodeUtils.Direction.RTL && isBidirectionalLine
                    ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment
                    : this.m_currentParams.textLayoutStyle.horizontalAlignment;
                this.m_currentParams.position.x =
                    this.m_currentParams.position.x + lineCurrX * lineAlignment;
                if (!this.placeLine(lineStartIdx, i, this.m_tempLineDirection, isBidirectionalLine)) {
                    return false;
                }
                // Update the line position.
                this.m_currentParams.position.y -= lineHeight * this.m_tempScale;
                this.m_currentParams.position.x = origin;
                // Find the beginning of a new line (removing trailing white spaces).
                while (i !== lineStartIdx &&
                    i + 1 < this.m_currentParams.glyphs.length &&
                    UnicodeUtils_1.UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint)) {
                    ++i;
                }
                lineStartIdx = i + 1;
                if (lineStartIdx === this.m_currentParams.glyphs.length) {
                    break;
                }
                // Only reset the line's direction when a new line character is found (to keep
                // correct bidirectional behaviour when a bidirectional run is placed between
                // multiple lines).
                if (isNewLine) {
                    this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, lineStartIdx);
                    this.m_tempRunDirection = this.m_tempLineDirection;
                }
                // Reset the line placement parameters.
                lineStartX = 0;
                lineCurrX = 0;
                glyphWrapIdx = lineStartIdx;
                glyphWrapX = 0;
                wordWrapIdx = lineStartIdx;
                wordWrapX = 0;
                isBidirectionalLine = false;
                lineCount++;
            }
            // If not, should if we should record any new wrapping points.
            else if (this.m_currentParams.textLayoutStyle.wrappingMode !== TextStyle_1.WrappingMode.None &&
                !isWhiteSpace) {
                // Update the per-glyph wrapping point.
                glyphWrapIdx = i;
                glyphWrapX = lineCurrX;
                // Update the word wrapping point (only if mode is correctly set and we are
                // currently placed at the end of a word).
                if (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&
                    i + 1 < this.m_currentParams.glyphs.length &&
                    (UnicodeUtils_1.UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint) ||
                        UnicodeUtils_1.UnicodeUtils.isNewLine(this.m_currentParams.glyphs[i + 1].codePoint))) {
                    wordWrapIdx = i;
                    wordWrapX = lineCurrX;
                }
            }
        }
        // If we still haven't placed all characters, place a final line.
        if (lineCount <= this.m_currentParams.textLayoutStyle.maxLines - 1 &&
            lineStartIdx <= this.m_currentParams.glyphs.length - 1) {
            const offset = this.m_tempLineDirection === UnicodeUtils_1.UnicodeUtils.Direction.RTL && isBidirectionalLine
                ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment
                : this.m_currentParams.textLayoutStyle.horizontalAlignment;
            this.m_currentParams.position.setX(this.m_currentParams.position.x + lineCurrX * offset);
            if (!this.placeLine(lineStartIdx, this.m_currentParams.glyphs.length - 1, this.m_tempLineDirection, isBidirectionalLine)) {
                return false;
            }
        }
        return true;
    }
    // Place characters alongside a line. Text direction is taken into account, and text is broken
    // into directional runs.
    placeLine(startIdx, endIdx, direction, isBidirectional) {
        // If the line is not bidirectional, place it as a single directional run.
        if (!isBidirectional) {
            return this.placeRun(startIdx, endIdx, direction);
        }
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        const smallCapsArray = this.m_currentParams.smallCapsArray;
        const textRenderStyle = this.m_currentParams.textRenderStyle;
        const textLayoutStyle = this.m_currentParams.textLayoutStyle;
        const position = this.m_currentParams.position;
        // Initialize line placement parameters.
        const isRTL = direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;
        const origin = position.x;
        let offset = 0;
        let runStart = startIdx;
        for (let i = startIdx; i <= endIdx; ++i) {
            const glyphData = glyphDataArray[i];
            // If the current glyph changes the line direction, place the current run.
            if (glyphData.direction === -this.m_tempRunDirection) {
                if (isRTL) {
                    position.x = origin + offset;
                }
                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                    return false;
                }
                if (!isRTL) {
                    position.x = origin + offset;
                }
                runStart = i;
                this.m_tempRunDirection *= -1.0;
            }
            // If the current glyph has neutral direction (i.e. white space) and we're in the middle
            // of a run with direction opposite to the line's main direction, check for the closest
            // strong direction in the run.
            else if (glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                this.m_tempRunDirection === -direction) {
                let neutralIdx = i;
                while (neutralIdx + 1 < glyphDataArray.length &&
                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1) {
                    ++neutralIdx;
                }
                // If the closest strong direction in the run is not the current run's direction,
                // place the current run.
                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {
                    if (isRTL) {
                        position.x = origin + offset;
                    }
                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                        return false;
                    }
                    if (!isRTL) {
                        position.x = origin + offset;
                    }
                    runStart = i;
                    this.m_tempRunDirection *= -1.0;
                }
            }
            // Advance the offset position in the line.
            offset +=
                (glyphData.advanceX + textLayoutStyle.tracking) *
                    this.m_tempScale *
                    (this.m_tempSmallCaps
                        ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(glyphDataArray, smallCapsArray, i, textRenderStyle.fontVariant)
                        : 1.0) *
                    direction;
        }
        // If we still haven't placed all characters in the line, place a final run.
        if (runStart <= endIdx) {
            if (isRTL) {
                position.x = origin + offset;
            }
            if (!this.placeRun(runStart, endIdx, this.m_tempRunDirection)) {
                return false;
            }
            if (!isRTL) {
                position.x = origin + offset;
            }
        }
        return true;
    }
    // Place a directional run of index inside a line.
    placeRun(startIdx, endIdx, direction) {
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        const smallCapsArray = this.m_currentParams.smallCapsArray;
        const fontCatalog = this.m_currentParams.fontCatalog;
        const textRenderStyle = this.m_currentParams.textRenderStyle;
        const textLayoutStyle = this.m_currentParams.textLayoutStyle;
        const position = this.m_currentParams.position;
        const geometry = this.m_currentParams.geometry;
        const globalBounds = this.m_currentParams.globalBounds;
        const individualBounds = this.m_currentParams.individualBounds;
        const vertexBuffer = this.m_currentParams.vertexBuffer;
        // Move through the glyph array following the run's direction (as the order of the glyphs in
        // memory might not match the order on glyphs on scree).
        const start = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? startIdx : endIdx;
        const end = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? endIdx : startIdx;
        for (let i = start; direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction) {
            // Only process printable characters.
            const glyphData = glyphDataArray[i];
            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                continue;
            }
            // When placing a RTL run, we need to check for weak runs (numerical runs of characters
            // that don't change the overall run direction, but should always be displayed as LTR
            // text).
            if (startIdx !== endIdx &&
                i !== 0 &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL &&
                glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak) {
                let weakRunStart = i;
                let weakGlyph = glyphDataArray[weakRunStart - 1];
                while (weakRunStart !== startIdx &&
                    (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak ||
                        (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                            !UnicodeUtils_1.UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))) {
                    --weakRunStart;
                    weakGlyph = glyphDataArray[weakRunStart - 1];
                }
                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils_1.UnicodeUtils.Direction.LTR);
                i = weakRunStart;
                continue;
            }
            // Compute various rendering parameters for this glyph.
            const glyphFont = glyphData.font;
            const glyphFontMetrics = glyphFont.metrics;
            const fontStyle = textRenderStyle.fontStyle;
            const isBoldEmulated = (fontStyle === TextStyle_1.FontStyle.Bold && glyphFont.bold === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.bold === undefined &&
                    glyphFont.boldItalic === undefined);
            const isItalicEmulated = (fontStyle === TextStyle_1.FontStyle.Italic && glyphFont.italic === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.italic === undefined &&
                    glyphFont.boldItalic === undefined);
            const isSmallCaps = this.m_tempSmallCaps
                ? smallCapsArray[i] && textRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps
                : false;
            const smallCapsScale = isSmallCaps
                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight
                : 1.0;
            const glyphScale = this.m_tempScale * smallCapsScale;
            const emulationWeight = ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *
                (fontCatalog.size / fontCatalog.distanceRange);
            const bgWeight = (0.5 * this.m_tempPixelBgSize) /
                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));
            const isMirrored = UnicodeUtils_1.UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;
            const verticalOffset = glyphFontMetrics.lineHeight -
                glyphFontMetrics.base -
                glyphFontMetrics.distanceRange * 0.5;
            // Compute the glyphs transformation matrix and apply to all corners of a glyph.
            TypesettingUtils_1.TypesettingUtils.computeGlyphTransform(this.m_tempTransform, position, glyphScale, textLayoutStyle.canvasRotation, textRenderStyle.rotation);
            for (let j = 0; j < 4; ++j) {
                const glyphVertexPosition = glyphData.positions[j];
                const horizontalOffset = isItalicEmulated && j > 1
                    ? TypesettingUtils_1.TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size
                    : 0.0;
                this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);
                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);
            }
            // Depending on the typesetting options, add the computed glyph to the TextGeometry or
            // update the text bounds.
            if (globalBounds === undefined && vertexBuffer === undefined) {
                if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {
                    return false;
                }
            }
            else {
                if (globalBounds !== undefined) {
                    TypesettingUtils_1.TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);
                }
                if (vertexBuffer !== undefined) {
                    geometry.addToBuffer(vertexBuffer, i * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);
                }
            }
            // Advance the current position and proceed to next glyph in the run.
            position.set(position.x +
                (glyphData.advanceX + textLayoutStyle.tracking) *
                    glyphScale *
                    Math.cos(textLayoutStyle.lineRotation), position.y +
                (glyphData.advanceX + textLayoutStyle.tracking) *
                    glyphScale *
                    Math.sin(textLayoutStyle.lineRotation), position.z);
        }
        return true;
    }
}
exports.LineTypesetter = LineTypesetter;


/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/typesetting/PathTypesetter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/typesetting/PathTypesetter.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const TextGeometry_1 = __webpack_require__(/*! ../rendering/TextGeometry */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js");
const TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js");
const TypesettingUtils_1 = __webpack_require__(/*! ../utils/TypesettingUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js");
/**
 * @hidden
 * [[Typesetter]] implementation that arranges glyphs alongside a specified path.
 */
class PathTypesetter {
    /**
     * Creates a `PathTypesetter` object.
     *
     * @returns New `PathTypesetter`.
     */
    constructor() {
        this.m_tempTransform = new THREE.Matrix3();
        this.m_tempCorners = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
        this.m_tempLineDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempRunDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempPixelSize = 1.0;
        this.m_tempPixelBgSize = 1.0;
        this.m_tempScale = 1.0;
        this.m_tempSmallCaps = false;
        this.m_tempPathPosition = new THREE.Vector3();
        this.m_tempPathLength = 0.0;
        this.m_tempPathOffset = 0.0;
    }
    /**
     * Arranges the specified glyphs using this `PathTypesetter`. Text will be placed into a single
     * bidirectional line that follows the specified path. Characters will be orientated and placed
     * alongside this path following [[TextLayout]]'s [[VerticalAlignment]] and
     * [[HorizontalAlignment]].
     *
     * @param params Typesetting parameters.
     *
     * @returns If `false`, some error occurred during execution and the output should be dismissed.
     */
    arrangeGlyphs(params) {
        // Initializes common typesetting parameters (used across all functions in this class).
        this.m_currentParams = params;
        this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);
        this.m_tempRunDirection = this.m_tempLineDirection;
        this.m_tempPixelSize = TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);
        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;
        this.m_tempPixelBgSize = Math.min(TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);
        this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== undefined;
        this.m_tempPathLength = this.m_currentParams.path.getLength();
        this.m_tempPathOffset = 0.0;
        const isOnlyMeasured = this.m_currentParams.globalBounds !== undefined &&
            this.m_currentParams.vertexBuffer === undefined;
        // To be able to properly set the horizontal alignment on a path, we need to first retrieve
        // how much of the path the input text covers, so we can calculate the correct initial
        // offset.
        let isBidirectional = false;
        let pathWidth = 0.0;
        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {
            const glyphData = this.m_currentParams.glyphs[i];
            if (!glyphData.isInCache && !isOnlyMeasured) {
                return false;
            }
            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                continue;
            }
            if (!isBidirectional && glyphData.direction === -this.m_tempLineDirection) {
                isBidirectional = true;
            }
            pathWidth +=
                (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *
                    this.m_tempScale *
                    (this.m_tempSmallCaps
                        ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant)
                        : 1.0);
        }
        this.m_tempPathOffset = Math.min(Math.max(-this.m_currentParams.textLayoutStyle.horizontalAlignment +
            (this.m_currentParams.textLayoutStyle.horizontalAlignment * pathWidth) /
                this.m_tempPathLength, 0), 1);
        // Place the input text as a single path line.
        return this.placeLine(this.m_tempLineDirection, isBidirectional);
    }
    // Place characters alongside a path line. Text direction is taken into account, and text is
    // broken into directional runs.
    placeLine(direction, isBidirectional) {
        // If the line is not bidirectional, place it as a single directional run.
        if (!isBidirectional) {
            return this.placeRun(0, this.m_currentParams.glyphs.length - 1, direction);
        }
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        // Initialize line placement parameters.
        let runStart = 0;
        for (let i = runStart; i < glyphDataArray.length; ++i) {
            const glyphData = glyphDataArray[i];
            // If the current glyph changes the line direction, place the current run.
            if (glyphData.direction === -this.m_tempRunDirection) {
                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                    return false;
                }
                runStart = i;
                this.m_tempRunDirection *= -1.0;
            }
            // If the current glyph has neutral direction (i.e. white space) and we're in the middle
            // of a run with direction opposite to the line's main direction, check for the closest
            // strong direction in the run.
            else if (glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                this.m_tempRunDirection === -direction) {
                let neutralIdx = i;
                while (neutralIdx + 1 < glyphDataArray.length &&
                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1) {
                    ++neutralIdx;
                }
                // If the closest strong direction in the run is not the current run's direction,
                // place the current run.
                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {
                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                        return false;
                    }
                    runStart = i;
                    this.m_tempRunDirection *= -1.0;
                }
            }
        }
        // If we still haven't placed all characters in the line, place a final run.
        if (runStart < glyphDataArray.length) {
            if (!this.placeRun(runStart, glyphDataArray.length - 1, this.m_tempRunDirection)) {
                return false;
            }
        }
        return true;
    }
    // Place a directional run of index inside a path line.
    placeRun(startIdx, endIdx, direction) {
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        const smallCapsArray = this.m_currentParams.smallCapsArray;
        const fontCatalog = this.m_currentParams.fontCatalog;
        const textRenderStyle = this.m_currentParams.textRenderStyle;
        const textLayoutStyle = this.m_currentParams.textLayoutStyle;
        const position = this.m_currentParams.position;
        const geometry = this.m_currentParams.geometry;
        const globalBounds = this.m_currentParams.globalBounds;
        const individualBounds = this.m_currentParams.individualBounds;
        const vertexBuffer = this.m_currentParams.vertexBuffer;
        const path = this.m_currentParams.path;
        const defaultGlyphRotation = textRenderStyle.rotation;
        const normalDisplacement = textLayoutStyle.verticalAlignment *
            glyphDataArray[0].font.metrics.capHeight *
            this.m_tempScale;
        // Move through the glyph array following the run's direction (as the order of the glyphs in
        // memory might not match the order on glyphs on scree).
        const start = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? startIdx : endIdx;
        const end = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? endIdx : startIdx;
        for (let i = start; direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction) {
            // Only process printable characters.
            const glyphData = glyphDataArray[i];
            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                continue;
            }
            // When placing a RTL run, we need to check for weak runs (numerical runs of characters
            // that don't change the overall run direction, but should always be displayed as LTR
            // text).
            if (startIdx !== endIdx &&
                i !== 0 &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL &&
                glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak) {
                let weakRunStart = i;
                let weakGlyph = glyphDataArray[weakRunStart - 1];
                while (weakRunStart !== startIdx &&
                    (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak ||
                        (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                            !UnicodeUtils_1.UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))) {
                    --weakRunStart;
                    weakGlyph = glyphDataArray[weakRunStart - 1];
                }
                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils_1.UnicodeUtils.Direction.LTR);
                i = weakRunStart;
                continue;
            }
            // Compute various rendering parameters for this glyph.
            const glyphFont = glyphData.font;
            const glyphFontMetrics = glyphFont.metrics;
            const fontStyle = textRenderStyle.fontStyle;
            const isBoldEmulated = (fontStyle === TextStyle_1.FontStyle.Bold && glyphFont.bold === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.bold === undefined &&
                    glyphFont.boldItalic === undefined);
            const isItalicEmulated = (fontStyle === TextStyle_1.FontStyle.Italic && glyphFont.italic === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.italic === undefined &&
                    glyphFont.boldItalic === undefined);
            const isSmallCaps = this.m_tempSmallCaps
                ? smallCapsArray[i] && textRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps
                : false;
            const smallCapsScale = isSmallCaps
                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight
                : 1.0;
            const glyphScale = this.m_tempScale * smallCapsScale;
            const emulationWeight = ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *
                (fontCatalog.size / fontCatalog.distanceRange);
            const bgWeight = (0.5 * this.m_tempPixelBgSize) /
                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));
            const isMirrored = UnicodeUtils_1.UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;
            const verticalOffset = glyphFontMetrics.lineHeight -
                glyphFontMetrics.base -
                glyphFontMetrics.distanceRange * 0.5;
            // Update the current interpolated path position and angle.
            const textPoint = path.getPoint(this.m_tempPathOffset);
            if (textPoint === null) {
                return this.m_currentParams.pathOverflow;
            }
            const tangent = path.getTangent(this.m_tempPathOffset);
            const normal = new THREE.Vector2(-tangent.y, tangent.x).multiplyScalar(normalDisplacement);
            const angle = Math.atan2(tangent.y, tangent.x);
            this.m_tempPathPosition.set(normal.x + textPoint.x, normal.y + textPoint.y, position.z);
            textRenderStyle.rotation = defaultGlyphRotation + angle;
            // Compute the glyphs transformation matrix and apply to all corners of a glyph.
            TypesettingUtils_1.TypesettingUtils.computeGlyphTransform(this.m_tempTransform, this.m_tempPathPosition, glyphScale, 0.0, textRenderStyle.rotation);
            for (let j = 0; j < 4; ++j) {
                const glyphVertexPosition = glyphData.positions[j];
                const horizontalOffset = isItalicEmulated && j > 1
                    ? TypesettingUtils_1.TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size
                    : 0.0;
                this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);
                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);
                this.m_tempCorners[j].x -= position.x;
                this.m_tempCorners[j].y -= position.y;
            }
            // Depending on the typesetting options, add the computed glyph to the TextGeometry or
            // update the text bounds.
            if (globalBounds === undefined && vertexBuffer === undefined) {
                if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {
                    return false;
                }
            }
            else {
                if (globalBounds !== undefined) {
                    TypesettingUtils_1.TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);
                }
                if (vertexBuffer !== undefined) {
                    geometry.addToBuffer(vertexBuffer, i * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);
                }
            }
            // Restore the original glyph rotation.
            textRenderStyle.rotation = defaultGlyphRotation;
            // Advance the current position and proceed to next glyph in the run.
            this.m_tempPathOffset +=
                ((glyphData.advanceX + textLayoutStyle.tracking) * glyphScale) /
                    this.m_tempPathLength;
        }
        return true;
    }
}
exports.PathTypesetter = PathTypesetter;


/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/utils/ContextualArabicConverter.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/utils/ContextualArabicConverter.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ContextualForm;
(function (ContextualForm) {
    ContextualForm[ContextualForm["Initial"] = 0] = "Initial";
    ContextualForm[ContextualForm["Medial"] = 1] = "Medial";
    ContextualForm[ContextualForm["Final"] = 2] = "Final";
})(ContextualForm || (ContextualForm = {}));
var CombinedForm;
(function (CombinedForm) {
    CombinedForm[CombinedForm["Isolated"] = 0] = "Isolated";
    CombinedForm[CombinedForm["Connected"] = 1] = "Connected";
})(CombinedForm || (CombinedForm = {}));
/**
 * Converter between arabic isolated forms (in Unicode Block 'Arabic') and their contextual forms
 * (in Unicode Block 'Arabic Presentation Forms-B').
 */
class ContextualArabicConverter {
    constructor() {
        this.m_singleCharactersMap = new Map();
        this.m_combinedCharactersMap = new Map();
        // Single characters.
        this.m_singleCharactersMap.set(0x0621, [undefined, undefined, undefined]); // HAMZA
        this.m_singleCharactersMap.set(0x0622, [undefined, undefined, 0xfe82]); // ALEF_MADDA
        this.m_singleCharactersMap.set(0x0623, [undefined, undefined, 0xfe84]); // ALEF_HAMZA_ABOVE
        this.m_singleCharactersMap.set(0x0624, [undefined, undefined, 0xfe86]); // WAW_HAMZA
        this.m_singleCharactersMap.set(0x0625, [undefined, undefined, 0xfe88]); // ALEF_HAMZA_BELOW
        this.m_singleCharactersMap.set(0x0626, [0xfe8b, 0xfe8c, 0xfe8a]); // YEH_HAMZA
        this.m_singleCharactersMap.set(0x0627, [undefined, undefined, 0xfe8e]); // ALEF
        this.m_singleCharactersMap.set(0x0628, [0xfe91, 0xfe92, 0xfe90]); // BEH
        this.m_singleCharactersMap.set(0x0629, [undefined, undefined, 0xfe94]); // TEH_MARBUTA
        this.m_singleCharactersMap.set(0x062a, [0xfe97, 0xfe98, 0xfe96]); // TEH
        this.m_singleCharactersMap.set(0x062b, [0xfe9b, 0xfe9c, 0xfe9a]); // THEH
        this.m_singleCharactersMap.set(0x062c, [0xfe9f, 0xfea0, 0xfe9e]); // JEEM
        this.m_singleCharactersMap.set(0x062d, [0xfea3, 0xfea4, 0xfea2]); // HAH
        this.m_singleCharactersMap.set(0x062e, [0xfea7, 0xfea8, 0xfea6]); // KHAH
        this.m_singleCharactersMap.set(0x062f, [undefined, undefined, 0xfeaa]); // DAL
        this.m_singleCharactersMap.set(0x0630, [undefined, undefined, 0xfeac]); // THAL
        this.m_singleCharactersMap.set(0x0631, [undefined, undefined, 0xfeae]); // REH
        this.m_singleCharactersMap.set(0x0632, [undefined, undefined, 0xfeb0]); // ZAIN
        this.m_singleCharactersMap.set(0x0633, [0xfeb3, 0xfeb4, 0xfeb2]); // SEEN
        this.m_singleCharactersMap.set(0x0634, [0xfeb7, 0xfeb8, 0xfeb6]); // SHEEN
        this.m_singleCharactersMap.set(0x0635, [0xfebb, 0xfebc, 0xfeba]); // SAD
        this.m_singleCharactersMap.set(0x0636, [0xfebf, 0xfec0, 0xfebe]); // DAD
        this.m_singleCharactersMap.set(0x0637, [0xfec3, 0xfec4, 0xfec2]); // TAH
        this.m_singleCharactersMap.set(0x0638, [0xfec7, 0xfec8, 0xfec6]); // ZAH
        this.m_singleCharactersMap.set(0x0639, [0xfecb, 0xfecc, 0xfeca]); // AIN
        this.m_singleCharactersMap.set(0x063a, [0xfecf, 0xfed0, 0xfece]); // GHAIN
        this.m_singleCharactersMap.set(0x0640, [0x0640, 0x0640, 0x0640]); // TATWEEL
        this.m_singleCharactersMap.set(0x0641, [0xfed3, 0xfed4, 0xfed2]); // FEH
        this.m_singleCharactersMap.set(0x0642, [0xfed7, 0xfed8, 0xfed6]); // QAF
        this.m_singleCharactersMap.set(0x0643, [0xfedb, 0xfedc, 0xfeda]); // KAF
        this.m_singleCharactersMap.set(0x0644, [0xfedf, 0xfee0, 0xfede]); // LAM
        this.m_singleCharactersMap.set(0x0645, [0xfee3, 0xfee4, 0xfee2]); // MEEM
        this.m_singleCharactersMap.set(0x0646, [0xfee7, 0xfee8, 0xfee6]); // NOON
        this.m_singleCharactersMap.set(0x0647, [0xfeeb, 0xfeec, 0xfeea]); // HEH
        this.m_singleCharactersMap.set(0x0648, [undefined, undefined, 0xfeee]); // WAW
        this.m_singleCharactersMap.set(0x0649, [undefined, undefined, 0xfef0]); // ALEF_MAKSURA
        this.m_singleCharactersMap.set(0x064a, [0xfef3, 0xfef4, 0xfef2]); // YEH
        this.m_singleCharactersMap.set(0x067e, [0xfb58, 0xfb59, 0xfb57]); // PEH
        this.m_singleCharactersMap.set(0x06cc, [0xfbfe, 0xfbff, 0xfbfd]); // Farsi Yeh
        this.m_singleCharactersMap.set(0x0686, [0xfb7c, 0xfb7d, 0xfb7b]); // Tcheh
        this.m_singleCharactersMap.set(0x06a9, [0xfb90, 0xfb91, 0xfb8f]); // Keheh
        this.m_singleCharactersMap.set(0x06af, [0xfb94, 0xfb95, 0xfb93]); // Gaf
        this.m_singleCharactersMap.set(0x0698, [undefined, undefined, 0xfb8b]); // Jeh
        // Combined characters.
        this.m_combinedCharactersMap.set(0x0644, new Map());
        // LAM_ALEF_MADDA
        this.m_combinedCharactersMap.get(0x0644).set(0x0622, [0xfef5, 0xfef6]);
        // LAM_ALEF_HAMZA_ABOVE
        this.m_combinedCharactersMap.get(0x0644).set(0x0623, [0xfef7, 0xfef8]);
        // LAM_ALEF_HAMZA_BELOW
        this.m_combinedCharactersMap.get(0x0644).set(0x0625, [0xfef9, 0xfefa]);
        // LAM_ALEF
        this.m_combinedCharactersMap.get(0x0644).set(0x0627, [0xfefb, 0xfefc]);
        // Neutral characters.
        this.m_neutralCharacters = [
            0x0610,
            0x0612,
            0x0613,
            0x0614,
            0x0615,
            0x064b,
            0x064c,
            0x064d,
            0x064e,
            0x064f,
            0x0650,
            0x0651,
            0x0652,
            0x0653,
            0x0654,
            0x0655,
            0x0656,
            0x0657,
            0x0658,
            0x0670,
            0x06d6,
            0x06d7,
            0x06d8,
            0x06d9,
            0x06da,
            0x06db,
            0x06dc,
            0x06df,
            0x06e0,
            0x06e1,
            0x06e2,
            0x06e3,
            0x06e4,
            0x06e7,
            0x06e8,
            0x06ea,
            0x06eb,
            0x06ec,
            0x06ed // ARABIC SMALL LOW MEEM
        ];
    }
    static get instance() {
        if (this.m_instance === undefined) {
            this.m_instance = new ContextualArabicConverter();
        }
        return this.m_instance;
    }
    /**
     * Converts isolated arabic characters into their contextual form.
     *
     * @param input String with isolated arabic characters.
     */
    convert(input) {
        let output = "";
        for (let i = 0; i < input.length; ++i) {
            const currentCodePoint = input.charCodeAt(i);
            // Only process arabic characters in the map.
            if (this.isArabicCharacter(currentCodePoint)) {
                // Find the first previous non-neutral character.
                let prevIndex = i - 1;
                for (; prevIndex >= 0; --prevIndex) {
                    if (!this.isNeutral(input.charCodeAt(prevIndex))) {
                        break;
                    }
                }
                // Check if the previous character has ligatures with following characters.
                let prevCodePoint = prevIndex >= 0 ? input.charCodeAt(prevIndex) : undefined;
                if (prevCodePoint !== undefined) {
                    const prevMap = this.getCharacterMap(prevCodePoint);
                    if (prevMap === undefined ||
                        (prevMap[ContextualForm.Initial] === undefined &&
                            prevMap[ContextualForm.Medial] === undefined)) {
                        prevCodePoint = undefined;
                    }
                }
                // Find the first next non-neutral character.
                let nextIndex = i + 1;
                for (; nextIndex < input.length; ++nextIndex) {
                    if (!this.isNeutral(input.charCodeAt(nextIndex))) {
                        break;
                    }
                }
                // Check if the next character has ligatures with previous characters.
                let nextCodePoint = nextIndex < input.length ? input.charCodeAt(nextIndex) : undefined;
                if (nextCodePoint !== undefined) {
                    const nextMap = this.getCharacterMap(nextCodePoint);
                    if (nextMap === undefined ||
                        (nextMap[ContextualForm.Medial] === undefined &&
                            nextMap[ContextualForm.Final] === undefined)) {
                        nextCodePoint = undefined;
                    }
                }
                // Check for Lam Alef combinated forms.
                if (currentCodePoint === 0x0644 &&
                    nextCodePoint !== undefined &&
                    (nextCodePoint === 0x0622 ||
                        nextCodePoint === 0x0623 ||
                        nextCodePoint === 0x0625 ||
                        nextCodePoint === 0x0627)) {
                    const combinedMap = this.getCombinedCharacterMap(currentCodePoint, nextCodePoint);
                    if (prevCodePoint !== undefined) {
                        output += String.fromCharCode(combinedMap[CombinedForm.Connected]);
                    }
                    else {
                        output += String.fromCharCode(combinedMap[CombinedForm.Isolated]);
                    }
                    // Skip the next character and continue.
                    ++i;
                    continue;
                }
                // Check for single character contextual forms.
                const map = this.getCharacterMap(currentCodePoint);
                // Intermediate.
                if (prevCodePoint !== undefined &&
                    nextCodePoint !== undefined &&
                    map[ContextualForm.Medial] !== undefined) {
                    output += String.fromCharCode(map[ContextualForm.Medial]);
                }
                // Final.
                else if (prevCodePoint !== undefined && map[ContextualForm.Final] !== undefined) {
                    output += String.fromCharCode(map[ContextualForm.Final]);
                }
                // Initial.
                else if (nextCodePoint !== undefined && map[ContextualForm.Initial] !== undefined) {
                    output += String.fromCharCode(map[ContextualForm.Initial]);
                }
                // Isolated.
                else {
                    output += String.fromCharCode(currentCodePoint);
                }
            }
            else {
                output += String.fromCharCode(currentCodePoint);
            }
        }
        return output;
    }
    isArabicCharacter(codePoint) {
        return this.m_singleCharactersMap.has(codePoint);
    }
    getCharacterMap(codePoint) {
        return this.m_singleCharactersMap.get(codePoint);
    }
    getCombinedCharacterMap(codePoint, nextCodePoint) {
        const map = this.m_combinedCharactersMap.get(codePoint);
        if (map !== undefined) {
            return map.get(nextCodePoint);
        }
        return undefined;
    }
    isNeutral(codePoint) {
        for (const character of this.m_neutralCharacters) {
            if (character === codePoint) {
                return true;
            }
        }
        return false;
    }
}
exports.ContextualArabicConverter = ContextualArabicConverter;


/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const TextMaterials_1 = __webpack_require__(/*! ../rendering/TextMaterials */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js");
/**
 * Helper function designed to create [[SdfTextMaterials]] that can be rendered using
 * [[TextCanvas]].
 *
 * @param params Material parameters.
 *
 * @returns New `SdfTextMaterial`.
 */
function createSdfTextMaterial(params) {
    return new TextMaterials_1.SdfTextMaterial({
        texture: params.fontCatalog.texture,
        textureSize: params.fontCatalog.textureSize,
        size: params.fontCatalog.size,
        distanceRange: params.fontCatalog.distanceRange,
        isMsdf: params.fontCatalog.type === "msdf",
        isBackground: params.isBackground === true,
        vertexSource: params.vertexSource,
        fragmentSource: params.fragmentSource
    });
}
exports.createSdfTextMaterial = createSdfTextMaterial;


/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js");
/**
 * Collection of different constants and utility functions used by [[Typesetter]]s.
 */
var TypesettingUtils;
(function (TypesettingUtils) {
    /**
     * Ratio between EMs and Pixels.
     */
    TypesettingUtils.EM_TO_PX = 16.0;
    /**
     * Ratio between Points and Pixels.
     */
    TypesettingUtils.PT_TO_PX = 1.25;
    /**
     * Angle used when emulating italic fonts (oblique).
     */
    TypesettingUtils.OBLIQUE_ANGLE = 0.174533;
    /**
     * Horizontal offset used when emulating italic fonts (oblique).
     */
    TypesettingUtils.OBLIQUE_OFFSET = Math.tan(TypesettingUtils.OBLIQUE_ANGLE);
    /**
     * Convert between any size specified in any [[FontUnit]] to pixels.
     *
     * @param size Font size (specified in `unit`).
     * @param unit Size unit.
     * @param originalSize Original size (pixels)
     *
     * @returns Pixel size.
     */
    function getPixelSize(size, unit, originalSize) {
        let result = size;
        switch (unit) {
            case TextStyle_1.FontUnit.Em:
                result *= TypesettingUtils.EM_TO_PX;
                break;
            case TextStyle_1.FontUnit.Point:
                result *= TypesettingUtils.PT_TO_PX;
                break;
            case TextStyle_1.FontUnit.Percent:
                result *= (1.0 / 100) * originalSize;
                break;
        }
        return result;
    }
    TypesettingUtils.getPixelSize = getPixelSize;
    /**
     * Gets the scale applied to a certain character when using the [[FontVariant]].`SmallCaps`.
     *
     * @param glyphs Array containing [[TransformedGlyphData]].
     * @param index Index to `glyphDataArray`.
     * @param fontVariant Currently active [[FontVariant]].
     *
     * @returns Glyph `SmallCaps` scale.
     */
    function getSmallCapsScale(glyphs, smallCapsTransformations, index, fontVariant) {
        const isSmallCaps = smallCapsTransformations[index] && fontVariant === TextStyle_1.FontVariant.SmallCaps;
        return isSmallCaps
            ? glyphs[index].font.metrics.xHeight / glyphs[index].font.metrics.capHeight
            : 1.0;
    }
    TypesettingUtils.getSmallCapsScale = getSmallCapsScale;
    /**
     * Returns the first strong direction (LTR or RTL) found for a given array of [[GlyphData]].
     *
     * @param glyphs Array containing [[GlyphData]].
     * @param offset `glyphDataArray` offset.
     *
     * @returns Strong direction.
     */
    function getDirection(glyphs, offset) {
        let result = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        let index = offset;
        while (glyphs[index].direction !== UnicodeUtils_1.UnicodeUtils.Direction.LTR &&
            glyphs[index].direction !== UnicodeUtils_1.UnicodeUtils.Direction.RTL &&
            index < glyphs.length - 1) {
            ++index;
        }
        if (Math.abs(glyphs[index].direction) === 1.0) {
            result = glyphs[index].direction;
        }
        return result;
    }
    TypesettingUtils.getDirection = getDirection;
    /**
     * Computes the transformation matrix for a glyph.
     *
     * @param transform Matrix used to store the results.
     * @param position Glyph' position.
     * @param scale Glyph' scale.
     * @param rotation [[TextCanvas]] rotation.
     * @param localRotation Glyph' local rotation.
     */
    function computeGlyphTransform(transform, position, scale, rotation, localRotation) {
        const cosAngle = Math.cos(rotation);
        const sinAngle = Math.sin(rotation);
        const localCosAngle = Math.cos(localRotation);
        const localSinAngle = Math.sin(localRotation);
        transform.set(scale * localCosAngle, scale * -localSinAngle, cosAngle * position.x - sinAngle * position.y, scale * localSinAngle, scale * localCosAngle, sinAngle * position.x + cosAngle * position.y, 0, 0, 1.0);
    }
    TypesettingUtils.computeGlyphTransform = computeGlyphTransform;
    /**
     * Updates the supplied bounds with the computed screen-space corners for a given glyph.
     *
     * @param corners Glyph' corners.
     * @param globalBounds Global text bounds.
     * @param individualBounds Individual per-character bounds.
     */
    function updateBounds(corners, globalBounds, individualBounds) {
        const minX = Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
        const maxX = Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
        const minY = Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y);
        const maxY = Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y);
        if (individualBounds !== undefined) {
            if (individualBounds.array[individualBounds.offset] !== undefined) {
                individualBounds.array[individualBounds.offset].min.set(minX, minY);
                individualBounds.array[individualBounds.offset].max.set(maxX, maxY);
            }
            else {
                individualBounds.array.push(new THREE.Box2(new THREE.Vector2(minX, minY), new THREE.Vector2(maxX, maxY)));
            }
            ++individualBounds.offset;
        }
        globalBounds.min.set(Math.min(globalBounds.min.x, minX), Math.min(globalBounds.min.y, minY));
        globalBounds.max.set(Math.max(globalBounds.max.x, maxX), Math.max(globalBounds.max.y, maxY));
    }
    TypesettingUtils.updateBounds = updateBounds;
})(TypesettingUtils = exports.TypesettingUtils || (exports.TypesettingUtils = {}));


/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Namespace containing useful information when dealing with Unicode's code points.
 */
var UnicodeUtils;
(function (UnicodeUtils) {
    /**
     * Range of Unicode code points considered as white space.
     * https://en.wikipedia.org/wiki/Whitespace_character
     */
    UnicodeUtils.whiteSpaceRanges = [
        [0x0009, 0x0009],
        [0x0020, 0x0020],
        [0x1680, 0x1680],
        [0x2000, 0x2006],
        [0x2008, 0x200a],
        [0x205f, 0x3000],
        [0x180e, 0x180e],
        [0x200b, 0x200d]
    ];
    /**
     * Checks if a character should be considered as a white space.
     *
     * @param codePoint Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isWhiteSpace(codePoint) {
        for (const range of UnicodeUtils.whiteSpaceRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return true;
            }
        }
        return false;
    }
    UnicodeUtils.isWhiteSpace = isWhiteSpace;
    /**
     * Range of Unicode code points considered as `NewLine`.
     * https://en.wikipedia.org/wiki/Newline#Unicode
     */
    UnicodeUtils.newLineRanges = [[0x000a, 0x000d], [0x0085, 0x0085], [0x2028, 0x2029]];
    /**
     * Checks if a character should be considered as a new line.
     *
     * @param codePoint Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isNewLine(codePoint) {
        for (const range of UnicodeUtils.newLineRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return true;
            }
        }
        return false;
    }
    UnicodeUtils.isNewLine = isNewLine;
    /**
     * Range of Unicode code points considered as non-printable.
     * https://en.wikipedia.org/wiki/Unicode_control_characters
     */
    UnicodeUtils.nonPrintableRanges = [[0x0000, 0x001f], [0x007f, 0x009f]];
    /**
     * Checks if a character's can be printed (rendered).
     *
     * @param codePoint Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isPrintable(codePoint) {
        for (const range of UnicodeUtils.nonPrintableRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return false;
            }
        }
        return true;
    }
    UnicodeUtils.isPrintable = isPrintable;
    /**
     * Unicode code point direction.
     */
    let Direction;
    (function (Direction) {
        Direction[Direction["Neutral"] = 0] = "Neutral";
        Direction[Direction["Weak"] = 0.5] = "Weak";
        Direction[Direction["LTR"] = 1] = "LTR";
        Direction[Direction["RTL"] = -1] = "RTL";
    })(Direction = UnicodeUtils.Direction || (UnicodeUtils.Direction = {}));
    // TODO: Review/Remove/Add any additional needed blocks (HARP-3330).
    /**
     * Unicode Blocks which have inherent RTL direction.
     * These blocks correspond to the scripts described here:
     * https://en.wikipedia.org/wiki/Right-to-left#List_of_RTL_scripts
     */
    UnicodeUtils.rtlBlocks = [
        "Hebrew",
        "Alphabetic Presentation Forms",
        "Arabic",
        "Arabic Supplement",
        "Arabic Extended-A",
        "Arabic Presentation Forms-A",
        "Arabic Presentation Forms-B",
        "Arabic Mathematical Alphabetic Symbols",
        "Indic Siyaq Numbers",
        "Rumi Numeral Symbols",
        "Syriac",
        "Syriac Supplement",
        "Samaritan",
        "Mandaic",
        "Thaana",
        "Mende Kikakui",
        "NKo",
        "Adlam",
        "Hanifi Rohingya"
    ];
    /**
     * ASCII punctuation is considered to have neutral direction:
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     */
    UnicodeUtils.neutralBidirectionalRanges = [
        [0x0020, 0x002f],
        [0x003a, 0x0040],
        [0x005b, 0x0060],
        [0x007b, 0x007e]
    ];
    /**
     * Latin and arabic numerals are considered to have weak directionality:
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     * https://en.wikipedia.org/wiki/Arabic_(Unicode_block)#Block
     */
    UnicodeUtils.weakBidirectionalRanges = [[0x0030, 0x0039], [0x0660, 0x0669], [0x06f0, 0x06f9]];
    /**
     * Returns the Unicode's character direction.
     *
     * @param codePoint Character's Unicode code point.
     * @param block Character's Unicode block.
     *
     * @returns Character's direction.
     */
    function getDirection(codePoint, block) {
        // Test for neutral and weak code points first (they're inside LTR/RTL ranges).
        for (const weakRange of UnicodeUtils.weakBidirectionalRanges) {
            if (codePoint >= weakRange[0] && codePoint <= weakRange[1]) {
                return Direction.Weak;
            }
        }
        for (const neutralRange of UnicodeUtils.neutralBidirectionalRanges) {
            if (codePoint >= neutralRange[0] && codePoint <= neutralRange[1]) {
                return Direction.Neutral;
            }
        }
        // Check for RTL/LTR.
        const rtl = UnicodeUtils.rtlBlocks.find(element => {
            return element === block;
        });
        if (rtl !== undefined) {
            return Direction.RTL;
        }
        else {
            return Direction.LTR;
        }
    }
    UnicodeUtils.getDirection = getDirection;
    /**
     * Some punctuation characters (like: (, ), <, >, [,], {, }) need to be mirrored when rendering
     * a RTL string to preserve their intrinsic meaning.
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     */
    UnicodeUtils.rtlMirroredCodePoints = [
        0x0028,
        0x0029,
        0x003c,
        0x003e,
        0x005b,
        0x005d,
        0x007b,
        0x007d
    ];
    /**
     * Checks if a character should be mirrored on an RTL run.
     *
     * @param codePoint Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isRtlMirrored(codePoint) {
        return (UnicodeUtils.rtlMirroredCodePoints.find(element => {
            return element === codePoint;
        }) !== undefined);
    }
    UnicodeUtils.isRtlMirrored = isRtlMirrored;
})(UnicodeUtils = exports.UnicodeUtils || (exports.UnicodeUtils = {}));


/***/ }),

/***/ "./node_modules/@here/harp-transfer-manager/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-transfer-manager/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./src/TransferManager */ "./node_modules/@here/harp-transfer-manager/src/TransferManager.js"));


/***/ }),

/***/ "./node_modules/@here/harp-transfer-manager/src/TransferManager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-transfer-manager/src/TransferManager.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/** @module
 *
 * This module provides classes to ease downloading URLs. In particular, following redirects,
 * retrying on HTTP errors, and limiting the number of parallel concurrent downloads.
 */
__webpack_require__(/*! @here/harp-fetch */ "./node_modules/@here/harp-fetch/index.web.js");
/** @internal
 * DeferredPromise takes an executor function for executing it later, when [[exec]] is called.
 * This class allows wrapping other promises or long running functions for later execution.
 */
class DeferredPromise {
    constructor(executor) {
        this.executor = executor;
        this.doExec = false;
        this.promise = new Promise((resolve, reject) => {
            this.resolveFunc = resolve;
            this.rejectFunc = reject;
            if (this.doExec) {
                this.execInnerPromise(this.resolveFunc, this.rejectFunc);
            }
        });
    }
    /**
     * When `exec` is called the deferred executor function is executed.
     */
    exec() {
        if (this.resolveFunc === undefined || this.rejectFunc === undefined) {
            // deferred promise not yet initialized - handle it in callback above
            this.doExec = true;
            return;
        }
        this.execInnerPromise(this.resolveFunc, this.rejectFunc);
    }
    execInnerPromise(resolveFunc, rejectFunc) {
        this.executor()
            .then(result => resolveFunc(result))
            .catch(err => rejectFunc(err));
    }
}
/**
 * `TransferManager` for downloading URLs.
 *
 * Features:
 *
 * * Merges JSON downloads, for example, the same URL if requested as JSON will only be downloaded
 *   once.
 * * Limits the amount of parallel downloads, useful when requesting a large amount of URLs that
 *   would otherwise stall the browser.
 * * Retries the downloads with an increasing timeout on HTTP 503 replies.
 *
 * The static method [[instance]] can be used to get a default constructed instance.
 */
class TransferManager {
    /**
     * Constructs a new [[TransferManager]].
     *
     * @param fetchFunction The default fetch function to use.
     * @param maxRetries The maximum amount to try to re-fetch a resource.
     */
    constructor(fetchFunction = fetch, maxRetries = 5) {
        this.fetchFunction = fetchFunction;
        this.maxRetries = maxRetries;
        this.activeDownloadCount = 0;
        this.downloadQueue = new Array();
        this.activeDownloads = new Map();
    }
    /**
     * Returns a default instance of [[TransferManager]].
     */
    static instance() {
        return TransferManager.defaultInstance;
    }
    static fetchRepeatedly(fetchFunction, retryCount, maxRetries, url, init) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield fetchFunction(url, init);
                if (response.status !== 503 || retryCount > maxRetries) {
                    return response;
                }
            }
            catch (err) {
                if (err.hasOwnProperty("isCancelled") ||
                    (err.hasOwnProperty("name") && err.name === "AbortError") ||
                    retryCount > maxRetries) {
                    throw err;
                }
            }
            return TransferManager.waitFor(TransferManager.retryTimeout * retryCount).then(() => TransferManager.fetchRepeatedly(fetchFunction, maxRetries, retryCount + 1, url, init));
        });
    }
    static waitFor(milliseconds) {
        return new Promise(resolve => setTimeout(resolve, milliseconds));
    }
    /**
     * Downloads a JSON object. Merges downloads if requested multiple times.
     *
     * Note: This method merges multiple downloads of the same resource to
     * only one request. The init parameter is ignored if the download is merged.
     * Call [[download]] instead to download the resource without merging.
     *
     * @param url The URL to download
     * @param init Optional extra parameters for the download.
     */
    downloadJson(url, init) {
        return this.downloadAs(response => response.json(), url, init);
    }
    /**
     * Downloads a binary object. Merges downloads if requested multiple times.
     *
     * Note: This method merges multiple downloads of the same resource to
     * only one request. The init parameter is ignored if the download is merged.
     * Call [[download]] instead to download the resource without merging.
     *
     * @param url The URL to download
     * @param init Optional extra parameters for the download
     */
    downloadArrayBuffer(url, init) {
        return this.download(url, init).then(response => response.arrayBuffer());
    }
    /**
     * Downloads a URL and returns the response.
     *
     * Does not merge multiple requests to the same URL.
     *
     * @param url The URL to download.
     * @param init Optional extra parameters for the download.
     */
    download(url, init) {
        if (this.activeDownloadCount >= TransferManager.maxParallelDownloads) {
            const deferred = new DeferredPromise(() => this.doDownload(url, init));
            this.downloadQueue.push(deferred);
            return deferred.promise;
        }
        return this.doDownload(url, init);
    }
    doDownload(url, init) {
        ++this.activeDownloadCount;
        return TransferManager.fetchRepeatedly(this.fetchFunction, 0, this.maxRetries, url, init)
            .then(response => {
            this.onDownloadDone();
            return response;
        })
            .catch(err => {
            this.onDownloadDone();
            throw err;
        });
    }
    onDownloadDone() {
        --this.activeDownloadCount;
        this.execDeferredDownload();
    }
    execDeferredDownload() {
        const future = this.downloadQueue.pop();
        if (future === undefined) {
            return;
        }
        future.exec();
    }
    downloadAs(converter, url, init) {
        const cacheKey = url;
        const pendingFetch = this.activeDownloads.get(cacheKey);
        if (pendingFetch !== undefined) {
            return Promise.resolve(pendingFetch);
        }
        const newFetch = this.download(url, init)
            .then(response => {
            this.activeDownloads.delete(cacheKey);
            if (response.ok) {
                return converter(response);
            }
            throw new Error(JSON.stringify(response));
        })
            .catch(err => {
            this.activeDownloads.delete(cacheKey);
            throw err;
        });
        this.activeDownloads.set(cacheKey, newFetch);
        return newFetch;
    }
}
/**
 * The timeout in milliseconds to wait between retries. This timeout is multiplied with the
 * number of retries. First retry waits for 0 ms, second retry for 500 ms, third for 1000 ms and
 * so on.
 */
TransferManager.retryTimeout = 500;
/**
 * The amount of maximum parallel downloads to allow.
 */
TransferManager.maxParallelDownloads = 16;
TransferManager.defaultInstance = new TransferManager();
exports.TransferManager = TransferManager;


/***/ }),

/***/ "./node_modules/@here/harp-utils/index.js":
/*!************************************************!*\
  !*** ./node_modules/@here/harp-utils/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/GroupedPriorityList */ "./node_modules/@here/harp-utils/lib/GroupedPriorityList.js"));
__export(__webpack_require__(/*! ./lib/Logger */ "./node_modules/@here/harp-utils/lib/Logger/index.js"));
__export(__webpack_require__(/*! ./lib/Math2D */ "./node_modules/@here/harp-utils/lib/Math2D.js"));
__export(__webpack_require__(/*! ./lib/MathUtils */ "./node_modules/@here/harp-utils/lib/MathUtils.js"));
__export(__webpack_require__(/*! ./lib/Mixins */ "./node_modules/@here/harp-utils/lib/Mixins.js"));
__export(__webpack_require__(/*! ./lib/assert */ "./node_modules/@here/harp-utils/lib/assert.js"));
__export(__webpack_require__(/*! ./lib/PerformanceTimer */ "./node_modules/@here/harp-utils/lib/PerformanceTimer.js"));
__export(__webpack_require__(/*! ./lib/OptionsUtils */ "./node_modules/@here/harp-utils/lib/OptionsUtils.js"));
__export(__webpack_require__(/*! ./lib/UrlResolver */ "./node_modules/@here/harp-utils/lib/UrlResolver.js"));
__export(__webpack_require__(/*! ./lib/UrlUtils */ "./node_modules/@here/harp-utils/lib/UrlUtils.js"));
__export(__webpack_require__(/*! ./lib/Functions */ "./node_modules/@here/harp-utils/lib/Functions.js"));


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Functions.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Functions.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Chains two functions for further assigning as one wrapped callback function
 */
function chainCallbacks(f1, f2) {
    return function (...args) {
        if (f1) {
            f1.apply(this, args);
        }
        return f2.apply(this, args);
    };
}
exports.chainCallbacks = chainCallbacks;


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/GroupedPriorityList.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/GroupedPriorityList.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The `PriorityListGroup` contains a list of [[PriorityListElement]]s that all have the same
 * (integer) priority.
 */
class PriorityListGroup {
    constructor(priority, elements = new Array()) {
        this.priority = priority;
        this.elements = elements;
    }
    /**
     * Create and return a deep copy of the `PriorityListGroup<T>`.
     *
     * @returns A clone of the `PriorityListGroup<T>`.
     */
    clone() {
        return new PriorityListGroup(this.priority, this.elements.slice());
    }
}
exports.PriorityListGroup = PriorityListGroup;
/**
 * The `GroupedPriorityList` contains a [[PriorityListGroupMap]] to manage a larger number of items
 * in priority groups.
 */
class GroupedPriorityList {
    constructor() {
        this.groups = new Map();
    }
    /**
     * Add an element to the `GroupedPriorityList`. Selects group based on the elements priority.
     *
     * @param element Element to be added.
     */
    add(element) {
        this.getGroup(element.priority).elements.push(element);
    }
    /**
     * Remove an element from the `GroupedPriorityList`.
     *
     * Note: It is required that the priority is the same as it was when the element has been added.
     * Otherwise, the removal will fail.
     *
     * @param element Element to be removed.
     * @returns `True` if the element was removed, `false` otherwise.
     */
    remove(element) {
        const group = this.getGroup(element.priority);
        if (group !== undefined) {
            const foundIndex = group.elements.indexOf(element);
            if (foundIndex >= 0) {
                group.elements.splice(foundIndex, 1);
                if (group.elements.length === 0) {
                    const normalizedPriority = Math.floor(element.priority);
                    this.groups.delete(normalizedPriority);
                }
                return true;
            }
        }
        return false;
    }
    /**
     * Remove all internal [[PriorityListGroup]]s.
     */
    clear() {
        this.groups.clear();
    }
    /**
     * Merge another [[GroupedPriorityList]] into this one.
     *
     * @param other Other group to merge.
     */
    merge(other) {
        for (const otherGroup of other.groups) {
            const group = this.findGroup(otherGroup[1].priority);
            if (group === undefined) {
                this.groups.set(Math.floor(otherGroup[1].priority), otherGroup[1].clone());
                continue;
            }
            group.elements = group.elements.concat(otherGroup[1].elements);
        }
        return this;
    }
    /**
     * Return a sorted list of [[PriorityListGroup]]s.
     */
    get sortedGroups() {
        const groups = [];
        for (const priorityList of this.groups) {
            groups.push(priorityList[1]);
        }
        groups.sort((a, b) => {
            return b.priority - a.priority;
        });
        return groups;
    }
    /**
     * Apply function to all elements in this `GroupedPriorityList`.
     *
     * @param {(element: T) => void} fun Function to apply.
     */
    forEach(fun) {
        for (const group of this.groups) {
            group[1].elements.forEach(fun);
        }
    }
    /**
     * Count the number of elements in this `GroupedPriorityList`.
     */
    count() {
        let n = 0;
        for (const group of this.groups) {
            n += group[1].elements.length;
        }
        return n;
    }
    /**
     * Get group of elements that have the same (integer) priority.
     *
     * @param priority The priority to retrieve all elements from.
     */
    findGroup(priority) {
        const normalizedPriority = Math.floor(priority);
        const group = this.groups.get(normalizedPriority);
        return group;
    }
    /**
     * Get group of elements that have the same (integer) priority.
     *
     * @param priority The priority to retrieve all elements from.
     */
    getGroup(priority) {
        let group = this.findGroup(priority);
        if (group === undefined) {
            const normalizedPriority = Math.floor(priority);
            group = new PriorityListGroup(normalizedPriority);
            this.groups.set(normalizedPriority, group);
        }
        return group;
    }
}
exports.GroupedPriorityList = GroupedPriorityList;


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class for the default console channel.
 */
class ConsoleChannel {
    error(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.error(message, ...optionalParams);
    }
    debug(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.debug(message, ...optionalParams);
    }
    info(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.info(message, ...optionalParams);
    }
    log(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.log(message, ...optionalParams);
    }
    trace(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.trace(message, ...optionalParams);
    }
    warn(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.warn(message, ...optionalParams);
    }
}
exports.ConsoleChannel = ConsoleChannel;


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/ILogger.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/ILogger.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Enum log levels
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Trace"] = 0] = "Trace";
    LogLevel[LogLevel["Debug"] = 1] = "Debug";
    LogLevel[LogLevel["Log"] = 2] = "Log";
    LogLevel[LogLevel["Info"] = 3] = "Info";
    LogLevel[LogLevel["Warn"] = 4] = "Warn";
    LogLevel[LogLevel["Error"] = 5] = "Error";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
/**
 * Logger options to configure logger
 */
class LoggerOptions {
}
exports.LoggerOptions = LoggerOptions;


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/Logger.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/Logger.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ILogger_1 = __webpack_require__(/*! ./ILogger */ "./node_modules/@here/harp-utils/lib/Logger/ILogger.js");
/**
 * Logger class.
 */
class Logger {
    constructor(name, m_channel, options) {
        this.name = name;
        this.m_channel = m_channel;
        this.enabled = true;
        this.level = ILogger_1.LogLevel.Trace;
        if (options !== undefined) {
            this.update(options);
        }
    }
    error(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Error) {
            this.m_channel.error(this.prefix, message, ...optionalParams);
        }
    }
    debug(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Debug) {
            this.m_channel.debug(this.prefix, message, ...optionalParams);
        }
    }
    info(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Info) {
            this.m_channel.info(this.prefix, message, ...optionalParams);
        }
    }
    log(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Log) {
            this.m_channel.log(this.prefix, message, ...optionalParams);
        }
    }
    trace(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Trace) {
            this.m_channel.trace(this.prefix, message, ...optionalParams);
        }
    }
    warn(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Warn) {
            this.m_channel.warn(this.prefix, message, ...optionalParams);
        }
    }
    update(options) {
        this.enabled = options.enabled === undefined ? this.enabled : options.enabled;
        this.level = options.level === undefined ? this.level : options.level;
    }
    get prefix() {
        return this.name + ":";
    }
}
exports.Logger = Logger;


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const LoggerManagerImpl_1 = __webpack_require__(/*! ./LoggerManagerImpl */ "./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js");
/**
 * The LoggerManager class implements a singleton object that handles logging.
 *
 * Example:
 *
 * ```typescript
 *
 * const logger = LoggerManager.instance.create("MyFontLoaderClass");
 * if (missingFonts.length > 0) {
 *     logger.error("These fonts can not be loaded: ", missingFonts);
 * } else {
 *     logger.log("All fonts have been loaded.");
 * }
 * ```
 */
class LoggerManager {
    static get instance() {
        return this.m_instance || (this.m_instance = new LoggerManagerImpl_1.LoggerManagerImpl());
    }
}
exports.LoggerManager = LoggerManager;


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ConsoleChannel_1 = __webpack_require__(/*! ./ConsoleChannel */ "./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/@here/harp-utils/lib/Logger/Logger.js");
const WorkerChannel_1 = __webpack_require__(/*! ./WorkerChannel */ "./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js");
/**
 * LoggerManagerImpl is the class for the singleton instance of the logger manager.
 * It handles channels and loggers.
 */
class LoggerManagerImpl {
    constructor() {
        this.m_loggers = [];
        this.channel =
            typeof self === "undefined" || typeof self.document !== "undefined"
                ? new ConsoleChannel_1.ConsoleChannel()
                : new WorkerChannel_1.WorkerChannel();
    }
    getLoggerNames() {
        return this.m_loggers.map(logger => logger.name);
    }
    getLogger(name) {
        return this.m_loggers.find(logger => logger.name === name);
    }
    create(loggerName, options) {
        const logger = new Logger_1.Logger(loggerName, this.channel, options);
        this.m_loggers.push(logger);
        return logger;
    }
    dispose(logger) {
        const found = this.m_loggers.indexOf(logger);
        if (found < 0) {
            throw new Error(`Cannot unregister "${logger}" : no such logger registered.`);
        }
        this.m_loggers.splice(found, 1);
    }
    updateAll(options) {
        for (const logger of this.m_loggers) {
            logger.update(options);
        }
    }
    update(loggerName, config) {
        for (const logger of this.m_loggers) {
            if (logger.name === loggerName) {
                logger.update(config);
            }
        }
    }
    enableAll(enabled) {
        for (const logger of this.m_loggers) {
            logger.enabled = enabled;
        }
    }
    enable(loggerName, value) {
        this.update(loggerName, { enabled: value });
    }
    setLogLevelForAll(level) {
        for (const logger of this.m_loggers) {
            logger.level = level;
        }
    }
    setLogLevel(loggerName, level) {
        this.update(loggerName, { level });
    }
    setChannel(channel) {
        this.channel = channel;
    }
}
exports.LoggerManagerImpl = LoggerManagerImpl;


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class allowing mixing several channels.
 */
class MultiChannel {
    constructor(...channels) {
        this.channels = [];
        this.channels = channels;
    }
    error(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.error(message, ...optionalParams);
        }
    }
    debug(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.debug(message, ...optionalParams);
        }
    }
    info(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.info(message, ...optionalParams);
        }
    }
    log(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.log(message, ...optionalParams);
        }
    }
    trace(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.trace(message, ...optionalParams);
        }
    }
    warn(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.warn(message, ...optionalParams);
        }
    }
}
exports.MultiChannel = MultiChannel;


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ILogger_1 = __webpack_require__(/*! ./ILogger */ "./node_modules/@here/harp-utils/lib/Logger/ILogger.js");
exports.WORKERCHANNEL_MSG_TYPE = "worker-channel-message";
/**
 * The class for the worker channel.
 */
class WorkerChannel {
    error(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Error
        };
        self.postMessage(workerMessage);
    }
    debug(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Debug
        };
        self.postMessage(workerMessage);
    }
    info(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Info
        };
        self.postMessage(workerMessage);
    }
    log(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Log
        };
        self.postMessage(workerMessage);
    }
    trace(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Trace
        };
        self.postMessage(workerMessage);
    }
    warn(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Warn
        };
        self.postMessage(workerMessage);
    }
}
exports.WorkerChannel = WorkerChannel;


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./ConsoleChannel */ "./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js"));
__export(__webpack_require__(/*! ./ILogger */ "./node_modules/@here/harp-utils/lib/Logger/ILogger.js"));
__export(__webpack_require__(/*! ./Logger */ "./node_modules/@here/harp-utils/lib/Logger/Logger.js"));
__export(__webpack_require__(/*! ./LoggerManager */ "./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js"));
__export(__webpack_require__(/*! ./MultiChannel */ "./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js"));
__export(__webpack_require__(/*! ./WorkerChannel */ "./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js"));


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Math2D.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Math2D.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Math2D;
(function (Math2D) {
    /**
     * Alternative 2D box object with less memory impact (four numbers instead of two min/max
     * objects with two numbers each). Should be faster.
     */
    class Box {
        /**
         * Alternative 2D box object with less memory impact (four numbers instead of two min/max
         * objects with two numbers each). Should be faster.
         *
         * @param x New X value.
         * @param y New y value.
         * @param w New w value.
         * @param h New h value.
         */
        constructor(x = 0, y = 0, w = 0, h = 0) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        /**
         * Set new values to all properties of the box.
         *
         * @param x New X value.
         * @param y New y value.
         * @param w New w value.
         * @param h New h value.
         */
        set(x, y, w, h) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        /**
         * Test box for inclusion of point.
         *
         * @param x X coordinate of point.
         * @param y Y coordinate of point.
         */
        contains(x, y) {
            return this.x <= x && this.x + this.w >= x && this.y <= y && this.y + this.h >= y;
        }
        /**
         * Test two boxes for intersection.
         *
         * @param other Box 2 to test for intersection.
         */
        intersects(other) {
            return (this.x <= other.x + other.w &&
                this.x + this.w >= other.x &&
                this.y <= other.y + other.h &&
                this.y + this.h >= other.y);
        }
    }
    Math2D.Box = Box;
    /**
     * Compute squared distance between two 2D points `a` and `b`.
     *
     * @param ax Point a.x
     * @param ay Point a.y
     * @param bx Point b.x
     * @param by Point b.y
     * @returns Squared distance between the two points
     */
    function distSquared(ax, ay, bx, by) {
        return (ax - bx) * (ax - bx) + (ay - by) * (ay - by);
    }
    Math2D.distSquared = distSquared;
    /**
     * Computes the squared length of a line.
     *
     * @param line An array of that forms a line via [x,y,z,x,y,z,...] tuples.
     */
    function computeSquaredLineLength(line) {
        let squaredLineLength = 0;
        const length = line.length - 4;
        for (let i = 0; i < length; i += 3) {
            const xDiff = line[i + 3] - line[i];
            const yDiff = line[i + 4] - line[i + 1];
            squaredLineLength += xDiff * xDiff + yDiff * yDiff;
        }
        return squaredLineLength;
    }
    Math2D.computeSquaredLineLength = computeSquaredLineLength;
    /**
     * Compute squared distance between a 2D point and a 2D line segment.
     *
     * @param px Test point X
     * @param py Test point y
     * @param l0x Line segment start X
     * @param l0y Line segment start Y
     * @param l1x Line segment end X
     * @param l1y Line segment end Y
     * @returns Squared distance between point and line segment
     */
    function distToSegmentSquared(px, py, l0x, l0y, l1x, l1y) {
        const lineLengthSuared = distSquared(l0x, l0y, l1x, l1y);
        if (lineLengthSuared === 0) {
            return distSquared(px, py, l0x, l0y);
        }
        let t = ((px - l0x) * (l1x - l0x) + (py - l0y) * (l1y - l0y)) / lineLengthSuared;
        t = Math.max(0, Math.min(1, t));
        return distSquared(px, py, l0x + t * (l1x - l0x), l0y + t * (l1y - l0y));
    }
    Math2D.distToSegmentSquared = distToSegmentSquared;
})(Math2D = exports.Math2D || (exports.Math2D = {}));


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/MathUtils.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/MathUtils.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var MathUtils;
(function (MathUtils) {
    /**
     * Ensures that input value fits in a given range.
     *
     * @param value The value to be clamped.
     * @param min Minimum value.
     * @param max Maximum value.
     *
     * @returns Clamped value.
     */
    function clamp(value, min, max) {
        return value < min ? min : value > max ? max : value;
    }
    MathUtils.clamp = clamp;
    /**
     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation
     * factor x. `0 <= x <= 1`.
     * @see https://en.wikipedia.org/wiki/Smoothstep
     *
     * @param edge0
     * @param edge1
     * @param x
     */
    function smoothStep(edge0, edge1, x) {
        // Scale, bias and saturate x to 0..1 range
        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
        // Evaluate polynomial
        return x * x * (3 - 2 * x);
    }
    MathUtils.smoothStep = smoothStep;
    /**
     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation
     * factor x. `0 <= x <= 1`.
     *
     * Improved version by Ken Perlin, which has zero 1st- and 2nd-order derivatives at `x = 0` and
     * `x = 1`:
     *
     * @see https://en.wikipedia.org/wiki/Smoothstep
     *
     * @param edge0
     * @param edge1
     * @param x
     */
    function smootherStep(edge0, edge1, x) {
        // Scale, and clamp x to 0..1 range
        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
        // Evaluate polynomial
        return x * x * x * (x * (x * 6 - 15) + 10);
    }
    MathUtils.smootherStep = smootherStep;
    /**
     * Maps a number from one range to another.
     *
     * @param val The incoming value to be converted.
     * @param inMin Lower bound of the value's current range.
     * @param inMax Upper bound of the value's current range.
     * @param outMin Lower bound of the value's target range.
     * @param outMax Upper bound of the value's target range.
     */
    function lerp(val, inMin, inMax, outMin, outMax) {
        return ((val - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
    }
    MathUtils.lerp = lerp;
    /**
     * Returns the smaller of the two given numbers. Both numbers may be undefined, in which case
     * the result is undefined. If only one of the numbers is undefined, the other number is
     * returned.
     *
     * @param a First number.
     * @param b Second number.
     */
    function min2(a, b) {
        let result;
        if (a !== undefined) {
            result = a;
        }
        if (b !== undefined) {
            result = result === undefined ? b : Math.min(result, b);
        }
        return result;
    }
    MathUtils.min2 = min2;
    /**
     * Returns the larger of the two given numbers. Both numbers may be undefined, in which case
     * the result is undefined. If only one of the numbers is undefined, the other number is
     * returned.
     *
     * @param a First number.
     * @param b Second number.
     */
    function max2(a, b) {
        let result;
        if (a !== undefined) {
            result = a;
        }
        if (b !== undefined) {
            result = result === undefined ? b : Math.max(result, b);
        }
        return result;
    }
    MathUtils.max2 = max2;
    /**
     * Checks if the value of a given number is inside an upper or lower bound. The bounds may be
     * undefined, in which case their value is ignored.
     *
     * @param value Value to check.
     * @param lowerBound The lower bound to check the value against.
     * @param upperBound The upper bound to check the value against.
     *
     * @returns `true` if value is inside the bounds or if the bounds are `undefined`, `false`
     *          otherwise.
     */
    function isClamped(value, lowerBound, upperBound) {
        if (lowerBound !== undefined && value < lowerBound) {
            return false;
        }
        if (upperBound !== undefined && value > upperBound) {
            return false;
        }
        return true;
    }
    MathUtils.isClamped = isClamped;
    /**
     * Smoothly interpolates between two values using cubic formula
     *
     * @param startValue
     * @param endValue
     * @param time
     * @returns Result of the interpolation within the range of `[startValue, endValue]`
     */
    function easeInOutCubic(startValue, endValue, time) {
        const timeValue = time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;
        return startValue + (endValue - startValue) * timeValue;
    }
    MathUtils.easeInOutCubic = easeInOutCubic;
})(MathUtils = exports.MathUtils || (exports.MathUtils = {}));


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Mixins.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Mixins.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copy methods and properties from one prototype into another.
 *
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 *
 * @param derivedCtor Class to mix methods and properties into.
 * @param baseCtors Class to take all methods and properties from.
 */
function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach(baseCtor => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
        });
    });
}
exports.applyMixins = applyMixins;
/**
 * Copy methods from one prototype into another.
 *
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 *
 * @param derivedCtor Class to mix methods into.
 * @param baseCtors Class to take all methods from.
 */
function applyMixinsWithoutProperties(derivedCtor, baseCtors) {
    baseCtors.forEach(baseCtor => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
            const descriptor = Object.getOwnPropertyDescriptor(baseCtor.prototype, name);
            if (descriptor !== undefined && descriptor.get === undefined) {
                derivedCtor.prototype[name] = baseCtor.prototype[name];
            }
        });
    });
}
exports.applyMixinsWithoutProperties = applyMixinsWithoutProperties;


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/OptionsUtils.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/OptionsUtils.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
function getOptionValue(...values) {
    for (const candidate of values) {
        if (candidate !== undefined && candidate !== null) {
            return candidate;
        }
    }
    return undefined;
}
exports.getOptionValue = getOptionValue;
/**
 * Merge options into existing parameters object.
 *
 * Convenience helper with _similar_ semantics as:
 *
 *     const finalParams1 = { ...defaults, ... options };
 *     const finalParams2 = Object.assign({}, defaults, options);
 *
 * This function doesn't copy _extra_ properties of `options` that doesn't exist in `defaults`.
 * `defaults` is used as _parameters_ template.
 *
 * This doc uses following notion of `option` and `parameter` terms:
 * * `parameter` is a variable, or 'almost constant' of procedure/function/algorith/object
 *    * `parameter` usually have sensible and usually used default
 *    * `parameter` is always defined (no `undefined`, `null` or `?` in type)
 *    * `parameter` can be overriden by specyfying `option` with same name
 * * `option` means value that may be passed optionally, overrides `parameter` value with same name
 *
 * Usage:
 *
 *     interface FooParams {
 *         useTextures: boolean;
 *         opacity: number;
 *     }
 *
 *     const FOO_DEFAULTS: FooParams = {
 *         useTextures: true,
 *         opacity: 0.8
 *     };
 *
 *     type FooOptions = Partial<FooParams>;
 *
 *     function doSomething(options: FooOptions) {
 *         const params = mergeWithOptions(FOO_DEFAULTS, options);
 *             // typeof params === FooParams
 *             // params.opacity = 0.5
 *             // params.useTextures = true
 *             // params.someOtherOptionFromOtherApi is not defined
 *     }
 *     const opt = {opacity: 0.5, someOtherOptionFromOtherApi: 'aaa'};
 *     doSomething(opt);
 *
 * Rationale:
 *   * both `Object.assign` and spread operator copy extra options
 *   * `Object.assign` & `spread operator` may copy `undefined` and `null`s if they really exist
 *     in options object
 *
 * @param parameters parmeters template object holding all expected parameters
 * @param options options object
 * @returns new object with `parameters` overriden by values from `options`
 */
function mergeWithOptions(parameters, options) {
    // NOTE: `as object` needed due to TypeScript bug:
    //       https://github.com/Microsoft/TypeScript/issues/14409
    // tslint:disable-next-line:no-object-literal-type-assertion
    const result = Object.assign({}, parameters);
    if (options === undefined || options === null) {
        return result;
    }
    for (const prop in parameters) {
        if (parameters.hasOwnProperty(prop)) {
            const optionValue = options[prop];
            if (optionValue !== undefined && optionValue !== null) {
                result[prop] = optionValue;
            }
        }
    }
    return result;
}
exports.mergeWithOptions = mergeWithOptions;


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/PerformanceTimer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/PerformanceTimer.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:max-line-length */
/**
 * See:
 * https://developers.google.com/web/updates/2012/08/When-milliseconds-are-not-enough-performance-now
 */
/* tslint:ensable:max-line-length */
class PerformanceTimer {
    /**
     * Returns timestamp in milliseconds since page load.
     *
     * If the [[DOMHighResTimeStamp]] is supported, the resolution is up to 5 microseconds,
     * otherwise it is in milliseconds. Timespans are computed by taking the difference between two
     * samples.
     *
     * Example:
     * ```typescript
     * const now = PerformanceTimer.now();
     * // call some expensive function for which you want to check the duration.
     * const end = PerformanceTimer.now();
     * const elapsedTime = end - now;
     * ```
     */
    static now() {
        return PerformanceTimer.nowFunc();
    }
    static getNowFunc() {
        if (typeof performance !== "undefined" && typeof performance.now !== "undefined") {
            return () => performance.now();
        }
        // fall back to Date.getTime()
        return () => {
            return new Date().getTime();
        };
    }
}
// tslint:disable-next-line:no-unused-variable
PerformanceTimer.instance = new PerformanceTimer();
PerformanceTimer.nowFunc = PerformanceTimer.getNowFunc();
exports.PerformanceTimer = PerformanceTimer;


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/UrlResolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/UrlResolver.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Resolves URL using default URL resolver.
 *
 * By default URL resolver is just identity function, it can be changed using
 * [[setDefaultUrlResolver].
 */
function defaultUrlResolver(url) {
    if (customDefaultUrlResolver !== undefined) {
        return customDefaultUrlResolver(url);
    }
    else {
        return url;
    }
}
exports.defaultUrlResolver = defaultUrlResolver;
/**
 * Change resolver used by [[defaultUrlResolver]].
 *
 * `undefined` resets default resolver to identity function.
 *
 * @param resolver
 */
function setDefaultUrlResolver(resolver) {
    customDefaultUrlResolver = resolver;
}
exports.setDefaultUrlResolver = setDefaultUrlResolver;
let customDefaultUrlResolver;
/**
 * Compose URL resolvers.
 *
 * Creates new `UrlResolver` that applies resolvers in orders or arguments.
 *
 * Example:
 *
 *     const themeUrl = ...; // url of parent object
 *     const childUrlResolver = composeUrlResolvers(
 *           (childUrl: string) => resolveReferenceUrl(themeUrl, childUrl),
 *           defaultUrlResolver
 *     );
 */
function composeUrlResolvers(...resolvers) {
    return (originalUrl) => {
        return resolvers.reduce((url, resolver) => {
            if (resolver !== undefined) {
                return resolver(url);
            }
            else {
                return url;
            }
        }, originalUrl);
    };
}
exports.composeUrlResolvers = composeUrlResolvers;


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/UrlUtils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/UrlUtils.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Resolve URL of referenced object.
 *
 * Resolves `childUrl` as it would be loaded from location specified by `parentUrl`.
 *
 * If `childUrl` is absolute, then it is returned unchanged.
 * If `childUrl` is origin-absolute path, then only origin path is taken from `parentUrl`.
 *
 * See [[baseUrl]] for reference how base URL of `parentUrl` is determined.
 *
 * Examples:
 *
 *     // normal case, child is sibling
 *     https://foo.com/themes/day.json + images/foo.png -> https://foo.com/themes/images/foo.png
 *
 *     // parent is "folder", so child is just located in this folder
 *     https://foo.com/themes/ + images/foo.png -> https://foo.com/themes/images/foo.png
 *
 *     // parent looks like leaf, so last component is stripped
 *     https://foo.com/themes + images/foo.png -> https://foo.com/images/foo.png
 *
 *     // origin-absolute URL, takes only origin from parent
 *     https://foo.com/themes/day.json + /fonts/foo.json -> https://foo.com/fonts/foo.json
 *
 * @param parentUrl URL of parent resource
 * @param childUrl URL of child as referenced from parent resource
 * @return `childUrl` as if anchored in location of `parentUrl`
 */
function resolveReferenceUrl(parentUrl, childUrl) {
    if (absoluteUrlWithOriginRe.test(childUrl)) {
        return childUrl;
    }
    else if (childUrl.startsWith("/")) {
        const origin = getUrlOrigin(parentUrl);
        return origin + childUrl;
    }
    else {
        if (childUrl.startsWith("./")) {
            childUrl = childUrl.substr(2);
        }
        const parentBaseUrl = baseUrl(parentUrl);
        return parentBaseUrl + childUrl;
    }
}
exports.resolveReferenceUrl = resolveReferenceUrl;
const absoluteUrlWithOriginRe = new RegExp("^(?:[a-z]+:)?//", "i");
/**
 * Returns base URL of given resource URL.
 *
 * `Url` with trailing slash are considered genuine 'locations', they are returned as is, however if
 * `url` ends with name component it is treated as "leaf", so last path component is removed.
 *
 * Standalone files (without any folder structure) are considered relative to `./`.
 *
 * Examples:
 * ```
 *     https://foo.com/themes/a.json -> https://foo.com/themes/
 *     https://foo.com/themes/ -> https://foo.com/themes/
 *     https://foo.com/themes -> https://foo.com/ // note, themes is treated as leaf
 *     themes/day.json -> themes/
 *     themes -> ./
 * ```
 */
function baseUrl(url) {
    if (url === undefined) {
        return "./";
    }
    const idx = url.lastIndexOf("/");
    if (idx === -1) {
        return "./";
    }
    else {
        return url.substring(0, idx + 1);
    }
}
exports.baseUrl = baseUrl;
/**
 * Get `origin` part of URL.
 *
 * @example
 *    https://example.com/foo -> https://example.com
 *    //example.com:8080/ -> //example.com:8080
 *    file:///etc/hosts ->
 *
 * @param url input URL
 * @return origin of given URL
 */
function getUrlOrigin(url) {
    if (url === undefined) {
        return "";
    }
    const parsed = getUrlHostAndProtocol(url);
    if (parsed.protocol === "file:") {
        return "file://";
    }
    else if (parsed.host && parsed.protocol) {
        return parsed.protocol + "//" + parsed.host;
    }
    else if (parsed.host) {
        return "//" + parsed.host;
    }
    else if (parsed.protocol) {
        return parsed.protocol + "//";
    }
    else {
        return "";
    }
}
exports.getUrlOrigin = getUrlOrigin;
/**
 * Parse `host` and `protocol` part from URL.
 */
function getUrlHostAndProtocol(url) {
    const urlOriginRe = new RegExp(/^(?:([a-z]+:))?\/\/([^\/]*)/, "i");
    const match = url.match(urlOriginRe);
    if (!match) {
        throw new Error(`getUrlHostAndProtocol: unable to parse URL '${url}'`);
    }
    return {
        protocol: match[1],
        host: match[2]
    };
}
exports.getUrlHostAndProtocol = getUrlHostAndProtocol;


/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/assert.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/assert.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
// cache value, because access to process.env.NODE_ENV is SLOW!
const isProduction = "development" === "production";
//TODO: Make assertHandler configurable
/**
 * Implementation of assert as a development help
 *
 * Note - this is deliberately a global function so that minimizers remove the
 * entire call when building for production.
 *
 * @hidden
 * @param condition Condition to match, if false, throws an Error(message)
 * @param message Optional message, defaults to "ASSERTION failed"
 */
function assert(condition, message) {
    if (!isProduction) {
        if (!condition) {
            throw new Error(message !== undefined ? message : "ASSERTION failed");
        }
    }
}
exports.assert = assert;
function assertExists(element, message) {
    if (!isProduction) {
        if (element === undefined || element === null) {
            throw new Error(message !== undefined ? message : "ASSERTION failed: Element is undefined or null");
        }
    }
    return element;
}
exports.assertExists = assertExists;


/***/ }),

/***/ "./node_modules/@tweenjs/tween.js/src/Tween.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tweenjs/tween.js/src/Tween.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */


var _Group = function () {
	this._tweens = {};
	this._tweensAddedDuringUpdate = {};
};

_Group.prototype = {
	getAll: function () {

		return Object.keys(this._tweens).map(function (tweenId) {
			return this._tweens[tweenId];
		}.bind(this));

	},

	removeAll: function () {

		this._tweens = {};

	},

	add: function (tween) {

		this._tweens[tween.getId()] = tween;
		this._tweensAddedDuringUpdate[tween.getId()] = tween;

	},

	remove: function (tween) {

		delete this._tweens[tween.getId()];
		delete this._tweensAddedDuringUpdate[tween.getId()];

	},

	update: function (time, preserve) {

		var tweenIds = Object.keys(this._tweens);

		if (tweenIds.length === 0) {
			return false;
		}

		time = time !== undefined ? time : TWEEN.now();

		// Tweens are updated in "batches". If you add a new tween during an update, then the
		// new tween will be updated in the next batch.
		// If you remove a tween during an update, it may or may not be updated. However,
		// if the removed tween was added during the current batch, then it will not be updated.
		while (tweenIds.length > 0) {
			this._tweensAddedDuringUpdate = {};

			for (var i = 0; i < tweenIds.length; i++) {

				var tween = this._tweens[tweenIds[i]];

				if (tween && tween.update(time) === false) {
					tween._isPlaying = false;

					if (!preserve) {
						delete this._tweens[tweenIds[i]];
					}
				}
			}

			tweenIds = Object.keys(this._tweensAddedDuringUpdate);
		}

		return true;

	}
};

var TWEEN = new _Group();

TWEEN.Group = _Group;
TWEEN._nextId = 0;
TWEEN.nextId = function () {
	return TWEEN._nextId++;
};


// Include a performance.now polyfill.
// In node.js, use process.hrtime.
if (typeof (self) === 'undefined' && typeof (process) !== 'undefined' && process.hrtime) {
	TWEEN.now = function () {
		var time = process.hrtime();

		// Convert [seconds, nanoseconds] to milliseconds.
		return time[0] * 1000 + time[1] / 1000000;
	};
}
// In a browser, use self.performance.now if it is available.
else if (typeof (self) !== 'undefined' &&
         self.performance !== undefined &&
		 self.performance.now !== undefined) {
	// This must be bound, because directly assigning this function
	// leads to an invocation exception in Chrome.
	TWEEN.now = self.performance.now.bind(self.performance);
}
// Use Date.now if it is available.
else if (Date.now !== undefined) {
	TWEEN.now = Date.now;
}
// Otherwise, use 'new Date().getTime()'.
else {
	TWEEN.now = function () {
		return new Date().getTime();
	};
}


TWEEN.Tween = function (object, group) {
	this._object = object;
	this._valuesStart = {};
	this._valuesEnd = {};
	this._valuesStartRepeat = {};
	this._duration = 1000;
	this._repeat = 0;
	this._repeatDelayTime = undefined;
	this._yoyo = false;
	this._isPlaying = false;
	this._reversed = false;
	this._delayTime = 0;
	this._startTime = null;
	this._easingFunction = TWEEN.Easing.Linear.None;
	this._interpolationFunction = TWEEN.Interpolation.Linear;
	this._chainedTweens = [];
	this._onStartCallback = null;
	this._onStartCallbackFired = false;
	this._onUpdateCallback = null;
	this._onRepeatCallback = null;
	this._onCompleteCallback = null;
	this._onStopCallback = null;
	this._group = group || TWEEN;
	this._id = TWEEN.nextId();

};

TWEEN.Tween.prototype = {
	getId: function () {
		return this._id;
	},

	isPlaying: function () {
		return this._isPlaying;
	},

	to: function (properties, duration) {

		this._valuesEnd = Object.create(properties);

		if (duration !== undefined) {
			this._duration = duration;
		}

		return this;

	},

	duration: function duration(d) {
		this._duration = d;
		return this;
	},

	start: function (time) {

		this._group.add(this);

		this._isPlaying = true;

		this._onStartCallbackFired = false;

		this._startTime = time !== undefined ? typeof time === 'string' ? TWEEN.now() + parseFloat(time) : time : TWEEN.now();
		this._startTime += this._delayTime;

		for (var property in this._valuesEnd) {

			// Check if an Array was provided as property value
			if (this._valuesEnd[property] instanceof Array) {

				if (this._valuesEnd[property].length === 0) {
					continue;
				}

				// Create a local copy of the Array with the start value at the front
				this._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);

			}

			// If `to()` specifies a property that doesn't exist in the source object,
			// we should not set that property in the object
			if (this._object[property] === undefined) {
				continue;
			}

			// Save the starting value.
			this._valuesStart[property] = this._object[property];

			if ((this._valuesStart[property] instanceof Array) === false) {
				this._valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
			}

			this._valuesStartRepeat[property] = this._valuesStart[property] || 0;

		}

		return this;

	},

	stop: function () {

		if (!this._isPlaying) {
			return this;
		}

		this._group.remove(this);
		this._isPlaying = false;

		if (this._onStopCallback !== null) {
			this._onStopCallback(this._object);
		}

		this.stopChainedTweens();
		return this;

	},

	end: function () {

		this.update(Infinity);
		return this;

	},

	stopChainedTweens: function () {

		for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
			this._chainedTweens[i].stop();
		}

	},

	group: function (group) {
		this._group = group;
		return this;
	},

	delay: function (amount) {

		this._delayTime = amount;
		return this;

	},

	repeat: function (times) {

		this._repeat = times;
		return this;

	},

	repeatDelay: function (amount) {

		this._repeatDelayTime = amount;
		return this;

	},

	yoyo: function (yoyo) {

		this._yoyo = yoyo;
		return this;

	},

	easing: function (easingFunction) {

		this._easingFunction = easingFunction;
		return this;

	},

	interpolation: function (interpolationFunction) {

		this._interpolationFunction = interpolationFunction;
		return this;

	},

	chain: function () {

		this._chainedTweens = arguments;
		return this;

	},

	onStart: function (callback) {

		this._onStartCallback = callback;
		return this;

	},

	onUpdate: function (callback) {

		this._onUpdateCallback = callback;
		return this;

	},

	onRepeat: function onRepeat(callback) {

		this._onRepeatCallback = callback;
		return this;

	},

	onComplete: function (callback) {

		this._onCompleteCallback = callback;
		return this;

	},

	onStop: function (callback) {

		this._onStopCallback = callback;
		return this;

	},

	update: function (time) {

		var property;
		var elapsed;
		var value;

		if (time < this._startTime) {
			return true;
		}

		if (this._onStartCallbackFired === false) {

			if (this._onStartCallback !== null) {
				this._onStartCallback(this._object);
			}

			this._onStartCallbackFired = true;
		}

		elapsed = (time - this._startTime) / this._duration;
		elapsed = (this._duration === 0 || elapsed > 1) ? 1 : elapsed;

		value = this._easingFunction(elapsed);

		for (property in this._valuesEnd) {

			// Don't update properties that do not exist in the source object
			if (this._valuesStart[property] === undefined) {
				continue;
			}

			var start = this._valuesStart[property] || 0;
			var end = this._valuesEnd[property];

			if (end instanceof Array) {

				this._object[property] = this._interpolationFunction(end, value);

			} else {

				// Parses relative end values with start as base (e.g.: +10, -3)
				if (typeof (end) === 'string') {

					if (end.charAt(0) === '+' || end.charAt(0) === '-') {
						end = start + parseFloat(end);
					} else {
						end = parseFloat(end);
					}
				}

				// Protect against non numeric properties.
				if (typeof (end) === 'number') {
					this._object[property] = start + (end - start) * value;
				}

			}

		}

		if (this._onUpdateCallback !== null) {
			this._onUpdateCallback(this._object, elapsed);
		}

		if (elapsed === 1) {

			if (this._repeat > 0) {

				if (isFinite(this._repeat)) {
					this._repeat--;
				}

				// Reassign starting values, restart by making startTime = now
				for (property in this._valuesStartRepeat) {

					if (typeof (this._valuesEnd[property]) === 'string') {
						this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
					}

					if (this._yoyo) {
						var tmp = this._valuesStartRepeat[property];

						this._valuesStartRepeat[property] = this._valuesEnd[property];
						this._valuesEnd[property] = tmp;
					}

					this._valuesStart[property] = this._valuesStartRepeat[property];

				}

				if (this._yoyo) {
					this._reversed = !this._reversed;
				}

				if (this._repeatDelayTime !== undefined) {
					this._startTime = time + this._repeatDelayTime;
				} else {
					this._startTime = time + this._delayTime;
				}

				if (this._onRepeatCallback !== null) {
					this._onRepeatCallback(this._object);
				}

				return true;

			} else {

				if (this._onCompleteCallback !== null) {

					this._onCompleteCallback(this._object);
				}

				for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
					// Make the chained tweens start exactly at the time they should,
					// even if the `update()` method was called way past the duration of the tween
					this._chainedTweens[i].start(this._startTime + this._duration);
				}

				return false;

			}

		}

		return true;

	}
};


TWEEN.Easing = {

	Linear: {

		None: function (k) {

			return k;

		}

	},

	Quadratic: {

		In: function (k) {

			return k * k;

		},

		Out: function (k) {

			return k * (2 - k);

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k;
			}

			return - 0.5 * (--k * (k - 2) - 1);

		}

	},

	Cubic: {

		In: function (k) {

			return k * k * k;

		},

		Out: function (k) {

			return --k * k * k + 1;

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k;
			}

			return 0.5 * ((k -= 2) * k * k + 2);

		}

	},

	Quartic: {

		In: function (k) {

			return k * k * k * k;

		},

		Out: function (k) {

			return 1 - (--k * k * k * k);

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k;
			}

			return - 0.5 * ((k -= 2) * k * k * k - 2);

		}

	},

	Quintic: {

		In: function (k) {

			return k * k * k * k * k;

		},

		Out: function (k) {

			return --k * k * k * k * k + 1;

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k * k;
			}

			return 0.5 * ((k -= 2) * k * k * k * k + 2);

		}

	},

	Sinusoidal: {

		In: function (k) {

			return 1 - Math.cos(k * Math.PI / 2);

		},

		Out: function (k) {

			return Math.sin(k * Math.PI / 2);

		},

		InOut: function (k) {

			return 0.5 * (1 - Math.cos(Math.PI * k));

		}

	},

	Exponential: {

		In: function (k) {

			return k === 0 ? 0 : Math.pow(1024, k - 1);

		},

		Out: function (k) {

			return k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);

		},

		InOut: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			if ((k *= 2) < 1) {
				return 0.5 * Math.pow(1024, k - 1);
			}

			return 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);

		}

	},

	Circular: {

		In: function (k) {

			return 1 - Math.sqrt(1 - k * k);

		},

		Out: function (k) {

			return Math.sqrt(1 - (--k * k));

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return - 0.5 * (Math.sqrt(1 - k * k) - 1);
			}

			return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);

		}

	},

	Elastic: {

		In: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);

		},

		Out: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;

		},

		InOut: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			k *= 2;

			if (k < 1) {
				return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
			}

			return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;

		}

	},

	Back: {

		In: function (k) {

			var s = 1.70158;

			return k * k * ((s + 1) * k - s);

		},

		Out: function (k) {

			var s = 1.70158;

			return --k * k * ((s + 1) * k + s) + 1;

		},

		InOut: function (k) {

			var s = 1.70158 * 1.525;

			if ((k *= 2) < 1) {
				return 0.5 * (k * k * ((s + 1) * k - s));
			}

			return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);

		}

	},

	Bounce: {

		In: function (k) {

			return 1 - TWEEN.Easing.Bounce.Out(1 - k);

		},

		Out: function (k) {

			if (k < (1 / 2.75)) {
				return 7.5625 * k * k;
			} else if (k < (2 / 2.75)) {
				return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
			} else if (k < (2.5 / 2.75)) {
				return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
			} else {
				return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
			}

		},

		InOut: function (k) {

			if (k < 0.5) {
				return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
			}

			return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;

		}

	}

};

TWEEN.Interpolation = {

	Linear: function (v, k) {

		var m = v.length - 1;
		var f = m * k;
		var i = Math.floor(f);
		var fn = TWEEN.Interpolation.Utils.Linear;

		if (k < 0) {
			return fn(v[0], v[1], f);
		}

		if (k > 1) {
			return fn(v[m], v[m - 1], m - f);
		}

		return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);

	},

	Bezier: function (v, k) {

		var b = 0;
		var n = v.length - 1;
		var pw = Math.pow;
		var bn = TWEEN.Interpolation.Utils.Bernstein;

		for (var i = 0; i <= n; i++) {
			b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
		}

		return b;

	},

	CatmullRom: function (v, k) {

		var m = v.length - 1;
		var f = m * k;
		var i = Math.floor(f);
		var fn = TWEEN.Interpolation.Utils.CatmullRom;

		if (v[0] === v[m]) {

			if (k < 0) {
				i = Math.floor(f = m * (1 + k));
			}

			return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);

		} else {

			if (k < 0) {
				return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
			}

			if (k > 1) {
				return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
			}

			return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);

		}

	},

	Utils: {

		Linear: function (p0, p1, t) {

			return (p1 - p0) * t + p0;

		},

		Bernstein: function (n, i) {

			var fc = TWEEN.Interpolation.Utils.Factorial;

			return fc(n) / fc(i) / fc(n - i);

		},

		Factorial: (function () {

			var a = [1];

			return function (n) {

				var s = 1;

				if (a[n]) {
					return a[n];
				}

				for (var i = n; i > 1; i--) {
					s *= i;
				}

				a[n] = s;
				return s;

			};

		})(),

		CatmullRom: function (p0, p1, p2, p3, t) {

			var v0 = (p2 - p0) * 0.5;
			var v1 = (p3 - p1) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;

			return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;

		}

	}

};

// UMD (Universal Module Definition)
(function (root) {

	if (true) {

		// AMD
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return TWEEN;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	} else {}

})(this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/rtree/lib/geojson.js":
/*!*******************************************!*\
  !*** ./node_modules/rtree/lib/geojson.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var rectangle = __webpack_require__(/*! ./rectangle */ "./node_modules/rtree/lib/rectangle.js");
var bbox = function (ar, obj) {
  if (obj && obj.bbox) {
    return {
      leaf: obj,
      x: obj.bbox[0],
      y: obj.bbox[1],
      w: obj.bbox[2] - obj.bbox[0],
      h: obj.bbox[3] - obj.bbox[1]
    };
  }
  var len = ar.length;
  var i = 0;
  var a = new Array(len);
  while (i < len) {
    a[i] = [ar[i][0], ar[i][1]];
    i++;
  }
  var first = a[0];
  len = a.length;
  i = 1;
  var temp = {
    min: [].concat(first),
    max: [].concat(first)
  };
  while (i < len) {
    if (a[i][0] < temp.min[0]) {
      temp.min[0] = a[i][0];
    }
    else if (a[i][0] > temp.max[0]) {
      temp.max[0] = a[i][0];
    }
    if (a[i][1] < temp.min[1]) {
      temp.min[1] = a[i][1];
    }
    else if (a[i][1] > temp.max[1]) {
      temp.max[1] = a[i][1];
    }
    i++;
  }
  var out = {
    x: temp.min[0],
    y: temp.min[1],
    w: (temp.max[0] - temp.min[0]),
    h: (temp.max[1] - temp.min[1])
  };
  if (obj) {
    out.leaf = obj;
  }
  return out;
};
var geoJSON = {};
geoJSON.point = function (obj, self) {
  return (self.insertSubtree({
    x: obj.geometry.coordinates[0],
    y: obj.geometry.coordinates[1],
    w: 0,
    h: 0,
    leaf: obj
  }, self.root));
};
geoJSON.multiPointLineString = function (obj, self) {
  return (self.insertSubtree(bbox(obj.geometry.coordinates, obj), self.root));
};
geoJSON.multiLineStringPolygon = function (obj, self) {
  return (self.insertSubtree(bbox(Array.prototype.concat.apply([], obj.geometry.coordinates), obj), self.root));
};
geoJSON.multiPolygon = function (obj, self) {
  return (self.insertSubtree(bbox(Array.prototype.concat.apply([], Array.prototype.concat.apply([], obj.geometry.coordinates)), obj), self.root));
};
geoJSON.makeRec = function (obj) {
  return rectangle(obj.x, obj.y, obj.w, obj.h);
};
geoJSON.geometryCollection = function (obj, self) {
  if (obj.bbox) {
    return (self.insertSubtree({
      leaf: obj,
      x: obj.bbox[0],
      y: obj.bbox[1],
      w: obj.bbox[2] - obj.bbox[0],
      h: obj.bbox[3] - obj.bbox[1]
    }, self.root));
  }
  var geos = obj.geometry.geometries;
  var i = 0;
  var len = geos.length;
  var temp = [];
  var g;
  while (i < len) {
    g = geos[i];
    switch (g.type) {
    case 'Point':
      temp.push(geoJSON.makeRec({
        x: g.coordinates[0],
        y: g.coordinates[1],
        w: 0,
        h: 0
      }));
      break;
    case 'MultiPoint':
      temp.push(geoJSON.makeRec(bbox(g.coordinates)));
      break;
    case 'LineString':
      temp.push(geoJSON.makeRec(bbox(g.coordinates)));
      break;
    case 'MultiLineString':
      temp.push(geoJSON.makeRec(bbox(Array.prototype.concat.apply([], g.coordinates))));
      break;
    case 'Polygon':
      temp.push(geoJSON.makeRec(bbox(Array.prototype.concat.apply([], g.coordinates))));
      break;
    case 'MultiPolygon':
      temp.push(geoJSON.makeRec(bbox(Array.prototype.concat.apply([], Array.prototype.concat.apply([], g.coordinates)))));
      break;
    case 'GeometryCollection':
      geos = geos.concat(g.geometries);
      len = geos.length;
      break;
    }
    i++;
  }
  var first = temp[0];
  i = 1;
  len = temp.length;
  while (i < len) {
    first.expand(temp[i]);
    i++;
  }
  return self.insertSubtree({
    leaf: obj,
    x: first.x(),
    y: first.y(),
    h: first.h(),
    w: first.w()
  }, self.root);
};
exports.geoJSON = function (prelim) {
  var that = this;
  var features, feature;
  if (Array.isArray(prelim)) {
    features = prelim.slice();
  }
  else if (prelim.features && Array.isArray(prelim.features)) {
    features = prelim.features.slice();
  }
  else if (prelim instanceof Object) {
    features = [prelim];
  } else {
    throw ('this isn\'t what we\'re looking for');
  }
  var len = features.length;
  var i = 0;
  while (i < len) {
    feature = features[i];
    if (feature.type === 'Feature') {
      switch (feature.geometry.type) {
      case 'Point':
        geoJSON.point(feature, that);
        break;
      case 'MultiPoint':
        geoJSON.multiPointLineString(feature, that);
        break;
      case 'LineString':
        geoJSON.multiPointLineString(feature, that);
        break;
      case 'MultiLineString':
        geoJSON.multiLineStringPolygon(feature, that);
        break;
      case 'Polygon':
        geoJSON.multiLineStringPolygon(feature, that);
        break;
      case 'MultiPolygon':
        geoJSON.multiPolygon(feature, that);
        break;
      case 'GeometryCollection':
        geoJSON.geometryCollection(feature, that);
        break;
      }
    }
    i++;
  }
};
exports.bbox = function () {
  var x1, y1, x2, y2;
  switch (arguments.length) {
  case 1:
    x1 = arguments[0][0][0];
    y1 = arguments[0][0][1];
    x2 = arguments[0][1][0];
    y2 = arguments[0][1][1];
    break;
  case 2:
    x1 = arguments[0][0];
    y1 = arguments[0][1];
    x2 = arguments[1][0];
    y2 = arguments[1][1];
    break;
  case 4:
    x1 = arguments[0];
    y1 = arguments[1];
    x2 = arguments[2];
    y2 = arguments[3];
    break;
  }

  return this.search({
    x: x1,
    y: y1,
    w: x2 - x1,
    h: y2 - y1
  });
};


/***/ }),

/***/ "./node_modules/rtree/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/rtree/lib/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var RTree = __webpack_require__(/*! ./rtree */ "./node_modules/rtree/lib/rtree.js");
var geojson = __webpack_require__(/*! ./geojson */ "./node_modules/rtree/lib/geojson.js");
RTree.prototype.bbox = geojson.bbox;
RTree.prototype.geoJSON = geojson.geoJSON;
RTree.Rectangle = __webpack_require__(/*! ./rectangle */ "./node_modules/rtree/lib/rectangle.js");
module.exports = RTree;

/***/ }),

/***/ "./node_modules/rtree/lib/rectangle.js":
/*!*********************************************!*\
  !*** ./node_modules/rtree/lib/rectangle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function Rectangle(x, y, w, h) { // new Rectangle(bounds) or new Rectangle(x, y, w, h)
  if (!(this instanceof Rectangle)) {
    return new Rectangle(x, y, w, h);
  }
  var x2, y2, p;

  if (x.x) {
    w = x.w;
    h = x.h;
    y = x.y;
    if (x.w !== 0 && !x.w && x.x2) {
      w = x.x2 - x.x;
      h = x.y2 - x.y;
    }
    else {
      w = x.w;
      h = x.h;
    }
    x = x.x;
    // For extra fastitude
    x2 = x + w;
    y2 = y + h;
    p = (h + w) ? false : true;
  }
  else {
    // For extra fastitude
    x2 = x + w;
    y2 = y + h;
    p = (h + w) ? false : true;
  }

  this.x1 = this.x = function () {
    return x;
  };
  this.y1 = this.y = function () {
    return y;
  };
  this.x2 = function () {
    return x2;
  };
  this.y2 = function () {
    return y2;
  };
  this.w = function () {
    return w;
  };
  this.h = function () {
    return h;
  };
  this.p = function () {
    return p;
  };

  this.overlap = function (a) {
    if (p || a.p()) {
      return x <= a.x2() && x2 >= a.x() && y <= a.y2() && y2 >= a.y();
    }
    return x < a.x2() && x2 > a.x() && y < a.y2() && y2 > a.y();
  };

  this.expand = function (a) {
    var nx, ny;
    var ax = a.x();
    var ay = a.y();
    var ax2 = a.x2();
    var ay2 = a.y2();
    if (x > ax) {
      nx = ax;
    }
    else {
      nx = x;
    }
    if (y > ay) {
      ny = ay;
    }
    else {
      ny = y;
    }
    if (x2 > ax2) {
      w = x2 - nx;
    }
    else {
      w = ax2 - nx;
    }
    if (y2 > ay2) {
      h = y2 - ny;
    }
    else {
      h = ay2 - ny;
    }
    x = nx;
    y = ny;
    return this;
  };

  //End of RTree.Rectangle
}


/* returns true if rectangle 1 overlaps rectangle 2
 * [ boolean ] = overlapRectangle(rectangle a, rectangle b)
 * @static function
 */
Rectangle.overlapRectangle = function (a, b) {
  //if(!((a.h||a.w)&&(b.h||b.w))){ not faster resist the urge!
  if ((a.h === 0 && a.w === 0) || (b.h === 0 && b.w === 0)) {
    return a.x <= (b.x + b.w) && (a.x + a.w) >= b.x && a.y <= (b.y + b.h) && (a.y + a.h) >= b.y;
  }
  else {
    return a.x < (b.x + b.w) && (a.x + a.w) > b.x && a.y < (b.y + b.h) && (a.y + a.h) > b.y;
  }
};

/* returns true if rectangle a is contained in rectangle b
 * [ boolean ] = containsRectangle(rectangle a, rectangle b)
 * @static function
 */
Rectangle.containsRectangle = function (a, b) {
  return (a.x + a.w) <= (b.x + b.w) && a.x >= b.x && (a.y + a.h) <= (b.y + b.h) && a.y >= b.y;
};

/* expands rectangle A to include rectangle B, rectangle B is untouched
 * [ rectangle a ] = expandRectangle(rectangle a, rectangle b)
 * @static function
 */
Rectangle.expandRectangle = function (a, b) {
  var nx, ny;
  var axw = a.x + a.w;
  var bxw = b.x + b.w;
  var ayh = a.y + a.h;
  var byh = b.y + b.h;
  if (a.x > b.x) {
    nx = b.x;
  }
  else {
    nx = a.x;
  }
  if (a.y > b.y) {
    ny = b.y;
  }
  else {
    ny = a.y;
  }
  if (axw > bxw) {
    a.w = axw - nx;
  }
  else {
    a.w = bxw - nx;
  }
  if (ayh > byh) {
    a.h = ayh - ny;
  }
  else {
    a.h = byh - ny;
  }
  a.x = nx;
  a.y = ny;
  return a;
};

/* generates a minimally bounding rectangle for all rectangles in
 * array 'nodes'. If rect is set, it is modified into the MBR. Otherwise,
 * a new rectangle is generated and returned.
 * [ rectangle a ] = makeMBR(rectangle array nodes, rectangle rect)
 * @static function
 */
Rectangle.makeMBR = function (nodes, rect) {
  if (!nodes.length) {
    return {
      x: 0,
      y: 0,
      w: 0,
      h: 0
    };
  }
  rect = rect || {};
  rect.x = nodes[0].x;
  rect.y = nodes[0].y;
  rect.w = nodes[0].w;
  rect.h = nodes[0].h;

  for (var i = 1, len = nodes.length; i < len; i++) {
    Rectangle.expandRectangle(rect, nodes[i]);
  }

  return rect;
};
Rectangle.squarifiedRatio = function (l, w, fill) {
  // Area of new enlarged rectangle
  var lperi = (l + w) / 2.0; // Average size of a side of the new rectangle
  var larea = l * w; // Area of new rectangle
  // return the ratio of the perimeter to the area - the closer to 1 we are,
  // the more 'square' a rectangle is. conversly, when approaching zero the
  // more elongated a rectangle is
  var lgeo = larea / (lperi * lperi);
  return larea * fill / lgeo;
};
module.exports = Rectangle;

/***/ }),

/***/ "./node_modules/rtree/lib/rtree.js":
/*!*****************************************!*\
  !*** ./node_modules/rtree/lib/rtree.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var rectangle = __webpack_require__(/*! ./rectangle */ "./node_modules/rtree/lib/rectangle.js");
function RTree(width) {
  if (!(this instanceof RTree)) {
    return new RTree(width);
  }
  // Variables to control tree-dimensions
  var minWidth = 3;  // Minimum width of any node before a merge
  var maxWidth = 6;  // Maximum width of any node before a split
  if (!isNaN(width)) {
    minWidth = Math.floor(width / 2.0);
    maxWidth = width;
  }
  // Start with an empty root-tree
  var rootTree = {x: 0, y: 0, w: 0, h: 0, id: 'root', nodes: [] };
  this.root = rootTree;


  // This is my special addition to the world of r-trees
  // every other (simple) method I found produced crap trees
  // this skews insertions to prefering squarer and emptier nodes
  var flatten = function (tree) {
    var todo = tree.slice();
    var done = [];
    var current;
    while (todo.length) {
      current = todo.pop();
      if (current.nodes) {
        todo = todo.concat(current.nodes);
      } else if (current.leaf) {
        done.push(current);
      }
    }
    return done;
  };
  /* find the best specific node(s) for object to be deleted from
   * [ leaf node parent ] = removeSubtree(rectangle, object, root)
   * @private
   */
  var removeSubtree = function (rect, obj, root) {
    var hitStack = []; // Contains the elements that overlap
    var countStack = []; // Contains the elements that overlap
    var retArray = [];
    var currentDepth = 1;
    var tree, i, ltree;
    if (!rect || !rectangle.overlapRectangle(rect, root)) {
      return retArray;
    }
    var retObj = {x: rect.x, y: rect.y, w: rect.w, h: rect.h, target: obj};

    countStack.push(root.nodes.length);
    hitStack.push(root);
    while (hitStack.length > 0) {
      tree = hitStack.pop();
      i = countStack.pop() - 1;
      if ('target' in retObj) { // will this ever be false?
        while (i >= 0) {
          ltree = tree.nodes[i];
          if (rectangle.overlapRectangle(retObj, ltree)) {
            if ((retObj.target && 'leaf' in ltree && ltree.leaf === retObj.target) || (!retObj.target && ('leaf' in ltree || rectangle.containsRectangle(ltree, retObj)))) {
              // A Match !!
            // Yup we found a match...
            // we can cancel search and start walking up the list
              if ('nodes' in ltree) {// If we are deleting a node not a leaf...
                retArray = flatten(tree.nodes.splice(i, 1));
              } else {
                retArray = tree.nodes.splice(i, 1);
              }
              // Resize MBR down...
              rectangle.makeMBR(tree.nodes, tree);
              delete retObj.target;
              //if (tree.nodes.length < minWidth) { // Underflow
              //  retObj.nodes = searchSubtree(tree, true, [], tree);
              //}
              break;
            } else if ('nodes' in ltree) { // Not a Leaf
              currentDepth++;
              countStack.push(i);
              hitStack.push(tree);
              tree = ltree;
              i = ltree.nodes.length;
            }
          }
          i--;
        }

      } else if ('nodes' in retObj) { // We are unsplitting

        tree.nodes.splice(i + 1, 1); // Remove unsplit node
        if (tree.nodes.length > 0) {
          rectangle.makeMBR(tree.nodes, tree);
        }
        for (var t = 0;t < retObj.nodes.length;t++) {
          insertSubtree(retObj.nodes[t], tree);
        }
        retObj.nodes = [];
        if (hitStack.length === 0 && tree.nodes.length <= 1) { // Underflow..on root!
          retObj.nodes = searchSubtree(tree, true, retObj.nodes, tree);
          tree.nodes = [];
          hitStack.push(tree);
          countStack.push(1);
        } else if (hitStack.length > 0 && tree.nodes.length < minWidth) { // Underflow..AGAIN!
          retObj.nodes = searchSubtree(tree, true, retObj.nodes, tree);
          tree.nodes = [];
        } else {
          delete retObj.nodes; // Just start resizing
        }
      } else { // we are just resizing
        rectangle.makeMBR(tree.nodes, tree);
      }
      currentDepth -= 1;
    }
    return retArray;
  };

  /* choose the best damn node for rectangle to be inserted into
   * [ leaf node parent ] = chooseLeafSubtree(rectangle, root to start search at)
   * @private
   */
  var chooseLeafSubtree = function (rect, root) {
    var bestChoiceIndex = -1;
    var bestChoiceStack = [];
    var bestChoiceArea;
    var first = true;
    bestChoiceStack.push(root);
    var nodes = root.nodes;

    while (first || bestChoiceIndex !== -1) {
      if (first) {
        first = false;
      } else {
        bestChoiceStack.push(nodes[bestChoiceIndex]);
        nodes = nodes[bestChoiceIndex].nodes;
        bestChoiceIndex = -1;
      }

      for (var i = nodes.length - 1; i >= 0; i--) {
        var ltree = nodes[i];
        if ('leaf' in ltree) {
          // Bail out of everything and start inserting
          bestChoiceIndex = -1;
          break;
        }
        // Area of new enlarged rectangle
        var oldLRatio = rectangle.squarifiedRatio(ltree.w, ltree.h, ltree.nodes.length + 1);

        // Enlarge rectangle to fit new rectangle
        var nw = Math.max(ltree.x + ltree.w, rect.x + rect.w) - Math.min(ltree.x, rect.x);
        var nh = Math.max(ltree.y + ltree.h, rect.y + rect.h) - Math.min(ltree.y, rect.y);

        // Area of new enlarged rectangle
        var lratio = rectangle.squarifiedRatio(nw, nh, ltree.nodes.length + 2);

        if (bestChoiceIndex < 0 || Math.abs(lratio - oldLRatio) < bestChoiceArea) {
          bestChoiceArea = Math.abs(lratio - oldLRatio);
          bestChoiceIndex = i;
        }
      }
    }

    return bestChoiceStack;
  };

  /* split a set of nodes into two roughly equally-filled nodes
   * [ an array of two new arrays of nodes ] = linearSplit(array of nodes)
   * @private
   */
  var linearSplit = function (nodes) {
    var n = pickLinear(nodes);
    while (nodes.length > 0) {
      pickNext(nodes, n[0], n[1]);
    }
    return n;
  };

  /* insert the best source rectangle into the best fitting parent node: a or b
   * [] = pickNext(array of source nodes, target node array a, target node array b)
   * @private
   */
  var pickNext = function (nodes, a, b) {
  // Area of new enlarged rectangle
    var areaA = rectangle.squarifiedRatio(a.w, a.h, a.nodes.length + 1);
    var areaB = rectangle.squarifiedRatio(b.w, b.h, b.nodes.length + 1);
    var highAreaDelta;
    var highAreaNode;
    var lowestGrowthGroup;

    for (var i = nodes.length - 1; i >= 0;i--) {
      var l = nodes[i];
      var newAreaA = {};
      newAreaA.x = Math.min(a.x, l.x);
      newAreaA.y = Math.min(a.y, l.y);
      newAreaA.w = Math.max(a.x + a.w, l.x + l.w) - newAreaA.x;
      newAreaA.h = Math.max(a.y + a.h, l.y + l.h) - newAreaA.y;
      var changeNewAreaA = Math.abs(rectangle.squarifiedRatio(newAreaA.w, newAreaA.h, a.nodes.length + 2) - areaA);

      var newAreaB = {};
      newAreaB.x = Math.min(b.x, l.x);
      newAreaB.y = Math.min(b.y, l.y);
      newAreaB.w = Math.max(b.x + b.w, l.x + l.w) - newAreaB.x;
      newAreaB.h = Math.max(b.y + b.h, l.y + l.h) - newAreaB.y;
      var changeNewAreaB = Math.abs(rectangle.squarifiedRatio(newAreaB.w, newAreaB.h, b.nodes.length + 2) - areaB);

      if (!highAreaNode || !highAreaDelta || Math.abs(changeNewAreaB - changeNewAreaA) < highAreaDelta) {
        highAreaNode = i;
        highAreaDelta = Math.abs(changeNewAreaB - changeNewAreaA);
        lowestGrowthGroup = changeNewAreaB < changeNewAreaA ? b : a;
      }
    }
    var tempNode = nodes.splice(highAreaNode, 1)[0];
    if (a.nodes.length + nodes.length + 1 <= minWidth) {
      a.nodes.push(tempNode);
      rectangle.expandRectangle(a, tempNode);
    }  else if (b.nodes.length + nodes.length + 1 <= minWidth) {
      b.nodes.push(tempNode);
      rectangle.expandRectangle(b, tempNode);
    }
    else {
      lowestGrowthGroup.nodes.push(tempNode);
      rectangle.expandRectangle(lowestGrowthGroup, tempNode);
    }
  };

  /* pick the 'best' two starter nodes to use as seeds using the 'linear' criteria
   * [ an array of two new arrays of nodes ] = pickLinear(array of source nodes)
   * @private
   */
  var pickLinear = function (nodes) {
    var lowestHighX = nodes.length - 1;
    var highestLowX = 0;
    var lowestHighY = nodes.length - 1;
    var highestLowY = 0;
    var t1, t2;

    for (var i = nodes.length - 2; i >= 0;i--) {
      var l = nodes[i];
      if (l.x > nodes[highestLowX].x) {
        highestLowX = i;
      } else if (l.x + l.w < nodes[lowestHighX].x + nodes[lowestHighX].w) {
        lowestHighX = i;
      }
      if (l.y > nodes[highestLowY].y) {
        highestLowY = i;
      } else if (l.y + l.h < nodes[lowestHighY].y + nodes[lowestHighY].h) {
        lowestHighY = i;
      }
    }
    var dx = Math.abs((nodes[lowestHighX].x + nodes[lowestHighX].w) - nodes[highestLowX].x);
    var dy = Math.abs((nodes[lowestHighY].y + nodes[lowestHighY].h) - nodes[highestLowY].y);
    if (dx > dy)  {
      if (lowestHighX > highestLowX)  {
        t1 = nodes.splice(lowestHighX, 1)[0];
        t2 = nodes.splice(highestLowX, 1)[0];
      }  else {
        t2 = nodes.splice(highestLowX, 1)[0];
        t1 = nodes.splice(lowestHighX, 1)[0];
      }
    }  else {
      if (lowestHighY > highestLowY)  {
        t1 = nodes.splice(lowestHighY, 1)[0];
        t2 = nodes.splice(highestLowY, 1)[0];
      }  else {
        t2 = nodes.splice(highestLowY, 1)[0];
        t1 = nodes.splice(lowestHighY, 1)[0];
      }
    }
    return [
      {x: t1.x, y: t1.y, w: t1.w, h: t1.h, nodes: [t1]},
      {x: t2.x, y: t2.y, w: t2.w, h: t2.h, nodes: [t2]}
    ];
  };

  var attachData = function (node, moreTree) {
    node.nodes = moreTree.nodes;
    node.x = moreTree.x;
    node.y = moreTree.y;
    node.w = moreTree.w;
    node.h = moreTree.h;
    return node;
  };

  /* non-recursive internal search function
  * [ nodes | objects ] = searchSubtree(rectangle, [return node data], [array to fill], root to begin search at)
   * @private
   */
  var searchSubtree = function (rect, returnNode, returnArray, root) {
    var hitStack = []; // Contains the elements that overlap

    if (!rectangle.overlapRectangle(rect, root)) {
      return returnArray;
    }


    hitStack.push(root.nodes);

    while (hitStack.length > 0) {
      var nodes = hitStack.pop();

      for (var i = nodes.length - 1; i >= 0; i--) {
        var ltree = nodes[i];
        if (rectangle.overlapRectangle(rect, ltree)) {
          if ('nodes' in ltree) { // Not a Leaf
            hitStack.push(ltree.nodes);
          } else if ('leaf' in ltree) { // A Leaf !!
            if (!returnNode) {
              returnArray.push(ltree.leaf);
            } else {
              returnArray.push(ltree);
            }
          }
        }
      }
    }

    return returnArray;
  };

  /* non-recursive internal insert function
   * [] = insertSubtree(rectangle, object to insert, root to begin insertion at)
   * @private
   */
  var insertSubtree = function (node, root) {
    var bc; // Best Current node
    // Initial insertion is special because we resize the Tree and we don't
    // care about any overflow (seriously, how can the first object overflow?)
    if (root.nodes.length === 0) {
      root.x = node.x;
      root.y = node.y;
      root.w = node.w;
      root.h = node.h;
      root.nodes.push(node);
      return;
    }

    // Find the best fitting leaf node
    // chooseLeaf returns an array of all tree levels (including root)
    // that were traversed while trying to find the leaf
    var treeStack = chooseLeafSubtree(node, root);
    var retObj = node;//{x:rect.x,y:rect.y,w:rect.w,h:rect.h, leaf:obj};
    var pbc;
    // Walk back up the tree resizing and inserting as needed
    while (treeStack.length > 0) {
      //handle the case of an empty node (from a split)
      if (bc && 'nodes' in bc && bc.nodes.length === 0) {
        pbc = bc; // Past bc
        bc = treeStack.pop();
        for (var t = 0;t < bc.nodes.length;t++) {
          if (bc.nodes[t] === pbc || bc.nodes[t].nodes.length === 0) {
            bc.nodes.splice(t, 1);
            break;
          }
        }
      } else {
        bc = treeStack.pop();
      }

      // If there is data attached to this retObj
      if ('leaf' in retObj || 'nodes' in retObj || Array.isArray(retObj)) {
        // Do Insert
        if (Array.isArray(retObj)) {
          for (var ai = 0; ai < retObj.length; ai++) {
            rectangle.expandRectangle(bc, retObj[ai]);
          }
          bc.nodes = bc.nodes.concat(retObj);
        } else {
          rectangle.expandRectangle(bc, retObj);
          bc.nodes.push(retObj); // Do Insert
        }

        if (bc.nodes.length <= maxWidth)  { // Start Resizeing Up the Tree
          retObj = {x: bc.x, y: bc.y, w: bc.w, h: bc.h};
        }  else { // Otherwise Split this Node
          // linearSplit() returns an array containing two new nodes
          // formed from the split of the previous node's overflow
          var a = linearSplit(bc.nodes);
          retObj = a;//[1];

          if (treeStack.length < 1)  { // If are splitting the root..
            bc.nodes.push(a[0]);
            treeStack.push(bc);  // Reconsider the root element
            retObj = a[1];
          } /*else {
            delete bc;
          }*/
        }
      } else { // Otherwise Do Resize
        //Just keep applying the new bounding rectangle to the parents..
        rectangle.expandRectangle(bc, retObj);
        retObj = {x: bc.x, y: bc.y, w: bc.w, h: bc.h};
      }
    }
  };

  this.insertSubtree = insertSubtree;
  /* quick 'n' dirty function for plugins or manually drawing the tree
   * [ tree ] = RTree.getTree(): returns the raw tree data. useful for adding
   * @public
   * !! DEPRECATED !!
   */
  this.getTree = function () {
    return rootTree;
  };

  /* quick 'n' dirty function for plugins or manually loading the tree
   * [ tree ] = RTree.setTree(sub-tree, where to attach): returns the raw tree data. useful for adding
   * @public
   * !! DEPRECATED !!
   */
  this.setTree = function (newTree, where) {
    if (!where) {
      where = rootTree;
    }
    return attachData(where, newTree);
  };

  /* non-recursive search function
  * [ nodes | objects ] = RTree.search(rectangle, [return node data], [array to fill])
   * @public
   */
  this.search = function (rect, returnNode, returnArray) {
    returnArray = returnArray || [];
    return searchSubtree(rect, returnNode, returnArray, rootTree);
  };


  var removeArea = function (rect) {
    var numberDeleted = 1,
    retArray = [],
    deleted;
    while (numberDeleted > 0) {
      deleted = removeSubtree(rect, false, rootTree);
      numberDeleted = deleted.length;
      retArray = retArray.concat(deleted);
    }
    return retArray;
  };

  var removeObj = function (rect, obj) {
    var retArray = removeSubtree(rect, obj, rootTree);
    return retArray;
  };
    /* non-recursive delete function
   * [deleted object] = RTree.remove(rectangle, [object to delete])
   */
  this.remove = function (rect, obj) {
    if (!obj || typeof obj === 'function') {
      return removeArea(rect, obj);
    } else {
      return removeObj(rect, obj);
    }
  };

  /* non-recursive insert function
   * [] = RTree.insert(rectangle, object to insert)
   */
  this.insert = function (rect, obj) {
    var retArray = insertSubtree({x: rect.x, y: rect.y, w: rect.w, h: rect.h, leaf: obj}, rootTree);
    return retArray;
  };
}
RTree.prototype.toJSON = function (printing) {
  return JSON.stringify(this.root, false, printing);
};

RTree.fromJSON = function (json) {
  var rt = new RTree();
  rt.setTree(JSON.parse(json));
  return rt;
};

module.exports = RTree;


/**
 * Polyfill for the Array.isArray function
 * todo: Test on IE7 and IE8
 * Taken from https://github.com/geraintluff/tv4/issues/20
 */
if (typeof Array.isArray !== 'function') {
  Array.isArray = function (a) {
    return typeof a === 'object' && {}.toString.call(a) === '[object Array]';
  };
}


/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = THREE;

/***/ })

/******/ });
//# sourceMappingURL=mapview.bundle.js.map